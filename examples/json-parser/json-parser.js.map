{
  "version": 3,
  "sources": [
    "C:\\Users\\Administrator\\nyigoro\\parsergen-starter\\examples\\json-parser\\json-parser.lm"
  ],
  "names": [],
  "mappings": ";AA4EO;AACD,cAAmB;AACvB,wBAAM,WAAW,OAAO,GAAG;;;;AACF,aAAO,wBAAU,oBAAoB;;;;;AACzC,aAAO,yBAAW;;;;;;;;AAKtC;AACG,mBAAW,gBAAgB,OAAO;AAClC,cAAM,WAAW;AAErB,MAAI,CAAA,YAAY;AACd,WAAO,wBAAU,2BAAU,iBAAW;;AAGxC,wBAAM,YAAY,OAAO;;;;AAErB,UAAI,OAAO,GAAG;AACZ,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,uBAAiB;;AAEpE,UAAI,OAAO,GAAG;AACZ,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,wBAAkB;;AAErE,UAAI,OAAO,GAAG;AACZ,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,yBAAmB;;AAEtE,UAAI,OAAO,GAAG;AACZ,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,0BAAoB;;AAEvE,UAAI,OAAO,GAAG;AACZ,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,mBAAa;;AAEhE,UAAI,OAAO,GAAG;AACZ,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,mBAAa;;AAEhE,UAAI,OAAO,GAAG;AACZ,8BAAM,WAAW,OAAO,CAAA,WAAW,IAAG;;;;AAChB,mBAAO,WAAW,OAAO,SAAS,2BAAU,WAAW;;;;;AACxD,mBAAO,yBAAW;;;;;;;;AAGzC,UAAI,CAAA,aAAa,MAAM,OAAO,GAAG;AAC/B,8BAAM,WAAW,OAAO,UAAU;;;;AACZ,mBAAO,WAAW,OAAO,SAAS,2BAAU,WAAW;;;;;AACxD,mBAAO,yBAAW;;;;;;;;AAGzC,UAAI,CAAA,cAAc,OAAO,UAAU,WAAW,aAAa,OAAO,CAAA,WAAW;AAC3E,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,qBAAe;;AAElE,UAAI,CAAA,cAAc,OAAO,UAAU,YAAY,aAAa,OAAO,CAAA,WAAW;AAC5E,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,sBAAgB;;AAEnE,UAAI,CAAA,cAAc,OAAO,UAAU,WAAW,aAAa,OAAO,CAAA,WAAW;AAC3E,eAAO,WAAW,OAAO,CAAA,WAAW,IAAG,2BAAU,qBAAe;;AAGlE,aAAO,yBAAW,qCAA0B,GAAG;;;;AAEhC,aAAO,yBAAW;;;;;;;;AAKpC;AACD,wBAAM,YAAY,OAAO;;;;AAErB,UAAI,kBAAkB;AACpB,eAAO,gBAAgB,OAAO,CAAA,MAAM;;AAEtC,aAAO;;;;AAEQ,aAAO;;;;;;;;AAKzB;AACD,SAAO,iBAAiB,OAAO,KAAK,SAAS;;AAG5C;AACD,wBAAM,YAAY,SAAS;;;AACR,aAAO;;;;;AAEtB,4BAAM,YAAY,OAAO,CAAA,MAAM;;;;AAE3B,cAAI,OAAO,GAAG;AACZ,mBAAO,iBAAiB,OAAO,KAAK,SAAS,CAAA,MAAM;;AAErD,iBAAO;;;;AAEQ,iBAAO;;;;;;;;;;;;;;AAM7B;AACD,wBAAM,YAAY,OAAO;;;AACN,aAAO;;;;;AAEtB,UAAI,kBAAkB;AAAM,eAAO;;AACnC,UAAI,OAAO,GAAG;AAAQ,eAAO;;AAC7B,UAAI,OAAO,GAAG;AAAQ,eAAO;;AAC7B,UAAI,OAAO,GAAG;AAAQ,eAAO;;AAC7B,UAAI,OAAO,GAAG;AAAQ,eAAO;;AAC7B,aAAO;;;;;;;;AAKV;AACD,MAAI,OAAO,GAAG;AAAS,WAAO,0BAAY;;AAC1C,MAAI,OAAO,GAAG;AAAS,WAAO,0BAAY;;AAC1C,MAAI,OAAO,GAAG;AAAQ,WAAO,0BAAY;;AACzC,MAAI,OAAO,GAAG;AAAQ,WAAO,0BAAY;;AACzC,MAAI,OAAO,GAAG;AAAQ,WAAO,0BAAY;;AACzC,MAAI,OAAO,GAAG;AAAQ,WAAO,0BAAY;;AACzC,MAAI,OAAO,GAAG;AAAQ,WAAO,0BAAY;;AACzC,MAAI,OAAO,GAAG;AAAQ,WAAO,0BAAY;;AACzC,SAAO;;AAIN;AACD,wBAAM,YAAY,OAAO;;;AACN,aAAO,yBAAW;;;;;AAEjC,UAAI,OAAO,GAAG;AACZ,eAAO,wBAAU,SAAmB,+BAAgB,YAAW,CAAA,MAAM;;AAEvE,UAAI,OAAO,GAAG;AACZ,8BAAM,YAAY,OAAO,CAAA,MAAM;;;AACZ,mBAAO,yBAAW;;;;;AAEjC,mCAAM,YAAY;;;;AACU,uBAAO,WAAW,OAAO,CAAA,MAAM,IAAG,WAAW,KAAK;;;;AAC3D,uBAAO,yBAAW,mCAAyB;;;;;;;;;;;;;;AAMpE,aAAO,WAAW,OAAO,CAAA,MAAM,IAAG,WAAW,KAAK;;;;;;;;AAKrD;AACD,yBAAM,YAAY,OAAO;;;;AAErB,UAAI,aAAa;AACf,eAAO,YAAY,OAAO,CAAA,MAAM,IAAG,WAAW,KAAK,IAAI;;AAEzD,aAAO,QAAkB,UAAU,YAAY;;;;AAEhC,aAAO,QAAkB,UAAU,YAAY;;;;;;;;AAKjE;AACO,iBAAW;AACX,aAAO;AAEf,yBAAM,YAAY,OAAO;;;;AAErB,UAAI,OAAO,GAAG;AACZ,QAAA,OAAO,WAAW,MAAM;AACxB,QAAA,WAAW,CAAA,WAAW;;;;;AAGT,aAAO,yBAAW;;;;;;;AAG7B,aAAO,YAAY,OAAO,UAAU,MAAM;AAClD,MAAI,CAAA,cAAc;AAChB,WAAO,yBAAW,mCAAyB;;AAG7C,EAAA,WAAW;AACX,EAAA,OAAO;AAEP,yBAAM,YAAY,OAAO;;;;AAErB,UAAI,OAAO,GAAG;AACZ,QAAA,OAAO,YAAY,OAAO,CAAA,WAAW,IAAG,WAAW,MAAM,MAAM;AAC/D,YAAI,CAAA,cAAc;AAChB,iBAAO,yBAAW,mCAAyB;;AAE7C,QAAA,WAAW;AACX,QAAA,OAAO;;;;;;;;;;;AAMb,yBAAM,YAAY,OAAO;;;;AAErB,UAAI,CAAA,OAAO,GAAG,QAAQ,OAAO,GAAG;AAC9B,QAAA,OAAO,WAAW,MAAM;AACxB,QAAA,WAAW,CAAA,WAAW;AACtB,+BAAM,YAAY,OAAO;;;;AAErB,gBAAI,CAAA,OAAO,MAAM,QAAQ,OAAO,MAAM;AACpC,cAAA,OAAO,WAAW,MAAM;AACxB,cAAA,WAAW,CAAA,WAAW;;;;;;;;;;;AAK5B,QAAA,OAAO,YAAY,OAAO,UAAU,MAAM;AAC1C,YAAI,CAAA,cAAc;AAChB,iBAAO,yBAAW,mCAAyB;;AAE7C,QAAA,WAAW;AACX,QAAA,OAAO;;;;;;;;;;;AAMb,yBAAM,aAAa;;;;AACC,aAAO,wBAAU,SAAmB,+BAAgB,UAAS;;;;AAC5D,aAAO,yBAAW,mCAAyB;;;;;;;;AAI/D;AACD,SAAO;;AAGN;AACD,SAAO,yBAAyB,MAAM;;AAGrC;AACD,yBAAM;;;AACU,aAAO;;;;;;AACM,aAAO,yBAAyB,MAAM,2BAAU,MAAM;;;;;;;;AAqB9E;AACL,yBAAM,IAAI;;;;AAEN,6BAAM,YAAY;;;;AAEd,iCAAM;;;;AAEF,kBAAI,SAAS,KAAK;AAChB,uBAAO,wBAAU;;AAEnB,qBAAO,yBAAW,sCAA2B,WAAW,MAAM;;;;AAElD,qBAAO,wBAAU;;;;;;;;;;;AAGhB,iBAAO,yBAAW;;;;;;;;;;;AAGtB,aAAO,yBAAW;;;;;;;;AAKtC;AACD,yBAAM;;;AACU,aAAO,yBAAW;;;;;;AAE9B,6BAAM;;;AACe,iBAAO,wBAAU,SAAqB,wBAAsB;;;;AAC5D,iBAAO,wBAAU,SAAqB,0BAAe,cAAa;;;;AACjE,iBAAO,wBAAU,SAAqB,0BAAe,eAAc;;;;;AAC/D,iBAAO,wBAAU,SAAqB,4BAAiB,WAAU;;;;;AACjE,iBAAO,wBAAU,SAAqB,4BAAiB,WAAU;;;;AACpE,iBAAO,aAAa;;;;AAClB,iBAAO,YAAY;;;;AACnC,iBAAO,yBAAW,sCAA2B,WAAW,MAAM;;;;;;;;;;;AAO1E;AACD,yBAAM;;;AACU,aAAO,yBAAW;;;;;AAE9B,UAAI,SAAS,KAAK;AAChB,eAAO,wBAAU,SAAqB,4BAAiB,yBAAiB;;AAE1E,6BAAM,cAAc,QAAQ;;;;AAExB,iCAAM,aAAa,kBAAkB;;;;AAEjC,qBAAO,wBAAU,SACR,4BAAiB,qBAAqB,8BACvC;;;;;AAGS,qBAAO,yBAAW;;;;;;;;;;;AAGtB,iBAAO,yBAAW;;;;;;;;;;;;;;AAO1C;AACD,yBAAM;;;;;AAEF,6BAAM;;;;AAEF,iCAAM,aAAa,OAAO;;;;AAEtB,qCAAM,YAAY;;;;AAEV,gCAAQ,OAAa,YAAY;AACrC,yCAAM;;;;;AAEF,0BAAI,SAAS,MAAM;AACjB,+BAAO,cAAc,OAAO,2BAAU,OAAO;;AAE/C,6BAAO,wBAAU,WAAyB,2BAAU,OAAO,cAAY;;;;AAGvE,6BAAO,wBAAU,WAAyB,2BAAU,OAAO,cAAY;;;;;;;;;;;AAI1D,yBAAO,yBAAW;;;;;;;;;;;AAGtB,qBAAO,yBAAW;;;;;;;;;;AAGlC,iBAAO,yBAAW,sCAA2B,WAAW,MAAM;;;;;;;AAG3D,aAAO,yBAAW;;;;;;;;AAKjC;AACD,yBAAM;;;AACU,aAAO,yBAAW;;;;;AAE9B,UAAI,SAAS,KAAK;AAChB,eAAO,wBAAU,SAAqB,2BAAgB,yBAAiB;;AAEzE,6BAAM,eAAe,QAAQ;;;;AAEzB,iCAAM,aAAa,gBAAgB;;;;AAE/B,qBAAO,wBAAU,SACR,2BAAgB,oBAAoB,6BACrC;;;;;AAGS,qBAAO,yBAAW;;;;;;;;;;;AAGtB,iBAAO,yBAAW;;;;;;;;;;;;;;AAO1C;AACD,yBAAM,YAAY;;;;AAEd,6BAAM;;;;;AAEF,cAAI,SAAS,KAAK;AAChB,mBAAO,eAAe,MAAM,2BAAU,eAAe;;AAEvD,iBAAO,wBAAU,YAA2B,2BAAU,eAAe,cAAY;;;;AAErE,iBAAO,wBAAU,YAA2B,2BAAU,eAAe,cAAY;;;;;;;;;;;AAGhF,aAAO,yBAAW;;;;;;;;AAKtC;AACD,yBAAM;;;AACU,aAAO,yBAAW;;;;;;AAE9B,UAAI,SAAS,KAAK;AAChB,eAAO,wBAAU;;AAEnB,aAAO,yBAAW,sCAA2B,WAAW,MAAM;;;;;;;;AAMjE;AACD,yBAAM;;;AAEF,6BAAM;;;AACiB,iBAAO;;;;AACrB,iBAAO;;;;;;;AAIhB,6BAAM;;;AACkB,iBAAO;;;;AACtB,iBAAO;;;;;;;AAIhB,6BAAM;;;AACmB,iBAAO;;;;AACvB,iBAAO;;;;;;;AAIhB,6BAAM;;;AACoB,iBAAO;;;;AACxB,iBAAO;;;;;;;AAIhB,6BAAM;;;AACa,iBAAO;;;;AACjB,iBAAO;;;;;;;AAIhB,6BAAM;;;AACa,iBAAO;;;;AACjB,iBAAO;;;;;;;AAIhB,6BAAM;;;AACW,iBAAO;;;;AACf,iBAAO;;;;;;;AAGX,aAAO;;;;;AAKf;AACD,yBAAM;;;AACiB,aAAO;;;;AACN,aAAO;;;;AACN,aAAO;;;;AACN,aAAO;;;;AACd,aAAO;;;;AACP,aAAO;;;;AACA,aAAO;;;;AACP,aAAO;;;;AACZ,aAAO;;;;AACN,aAAO;;;;AACR,aAAO;;;;AACX,aAAO;;;;;;;;AAKvB;AACD,SAAO;;AAGN;AACD,SAAO,0BAA0B,MAAM;;AAGtC;AACD,yBAAM;;;AACU,aAAO;;;;;;AACM,aAAO,0BAA0B,MAAM,2BAAU,MAAM;;;;;;;;AAInF;AACD,SAAO;;AAGN;AACD,SAAO,yBAAyB,MAAM;;AAGrC;AACD,yBAAM;;;AACU,aAAO;;;;;;AACM,aAAO,yBAAyB,MAAM,2BAAU,MAAM;;;;;;;;AAM9E;AACL,SAAO,iBAAiB,OAAO;;AAI9B;AACD,yBAAM;;;AACgB,aAAO;;;;;AAEzB,UAAI;AAAK,eAAO;;AAChB,aAAO;;;;;AAEgB,aAAO,eAAe;;;;;AACtB,aAAO,WAAW,WAAW,MAAM,cAAc,KAAK;;;;;AACnD,aAAO,gBAAgB,OAAO;;;;;AAC3B,aAAO,iBAAiB,SAAS;;;;;;;;AAKjE;AACD,yBAAM;;;AACU,aAAO;;;;AAEf,oBAAQ,mBAAmB,OAAO,CAAA,SAAS,IAAG;AAClD,aAAO,WAAW,WAAW,cAAW,QAAQ,WAAW,aAAU,WAAW,YAAY,SAAS;;;;;AAMxG;AACD,yBAAM;;;AACU,aAAO;;;;;;AAEf,qBAAS,WAAW;AACpB,uBAAW,WAAW,YAAY,SAAS,iBAAiB,MAAM;AACtE,6BAAM;;;AACU,iBAAO,WAAW,QAAQ;;;;AACjC,iBAAO,WAAW,WAAW,QAAQ,WAAW,mBAAmB,MAAM,QAAQ;;;;;;;;;;;AAO7F;AACD,yBAAM;;;AACU,aAAO;;;;AAEf,oBAAQ,kBAAkB,SAAS,CAAA,SAAS,IAAG;AACnD,aAAO,WAAW,WAAW,cAAW,QAAQ,WAAW,aAAU,WAAW,YAAY,SAAS;;;;;AAMxG;AACD,yBAAM;;;AACU,aAAO;;;;;;AAEf,qBAAS,WAAW;AACpB,sBAAU,WAAW,WAAW,MAAM,cAAc,YAAY;AAChE,sBAAU,iBAAiB,YAAY;AACvC,yBAAa,WAAW,YAAY,SAAS,WAAW,SAAS,WAAW,MAAM;AACtF,6BAAM;;;AACU,iBAAO,WAAW,QAAQ;;;;AACjC,iBAAO,WAAW,WAAW,QAAQ,aAAa,kBAAkB,MAAM,QAAQ;;;;;;;;;;;AAM9F;AACD,MAAI;AAAS,WAAO;;AACpB,SAAO;;AAIN;AACD,MAAI,CAAA,SAAS;AAAK,WAAO;;AACzB,SAAO,WAAW,MAAM,YAAY,CAAA,QAAQ;;AAI3C;AACD,SAAO,iBAAiB,GAAG,GAAG;;AAG7B;AACD,yBAAM,YAAY,GAAG;;;AACF,aAAO;;;;;AAElB,sBAAU,iBAAiB;AAC/B,aAAO,iBAAiB,GAAG,CAAA,MAAM,IAAG,WAAW,KAAK;;;;;;;;AAKvD;AACD,MAAI,OAAO,GAAG;AAAS,WAAO;;AAC9B,MAAI,OAAO,GAAG;AAAS,WAAO;;AAC9B,MAAI,OAAO,GAAG;AAAa,WAAO;;AAClC,MAAI,OAAO,GAAG;AAAa,WAAO;;AAClC,MAAI,OAAO,GAAG;AAAa,WAAO;;AAClC,SAAO;;AAIF;AACL,EAAA,WAAW;AACX,EAAA,WAAW;AACX,EAAA,WAAW;AAEX,EAAA;;AAGC;AACD,EAAA,SAAS;AAET,yBAAM;;;;AAEF,UAAI,OAAO,OAAO;AAChB,QAAA,WAAW;;AAEX,YAAI,OAAO,OAAO;AAChB,UAAA;;AAEA,UAAA,cAAc;AACd,UAAA;;;;;;AAKJ,MAAA,WAAW;AACX,MAAA;;;;;;;;AAKH;AACD,yBAAM,MAAM;;;;AAER,MAAA,WAAW;AACX,MAAA,WAAW,UAAU;AACrB,MAAA,WAAW;;;;;AAGX,MAAA,WAAW;AACX,MAAA,WAAW,aAAa;AACxB,MAAA,WAAW;;;;;;;;AAKd;AACD,yBAAM;;;;;AAEF,aAAO,WAAW,sBAAsB,WAAW,KAAK,WAAW,iBAAiB,aAAa;;;;AAErE,aAAO;;;;;AACJ,aAAO,WAAW,oBAAoB;;;;;AACtC,aAAO,WAAW,oBAAoB;;;;;;AAErE,aAAO,WAAW,0BAA0B,WAAW,GAAG,WAAW,iBAAiB,aAAa;;;;;;;;AAKzG",
  "sourcesContent": [
    "import { io, str } from \"@std\"\r\n\r\n// Core data structures for JSON parsing\r\n\r\n// Recursive list type\r\npub enum List<T> {\r\n  Nil,\r\n  Cons(T, List<T>)\r\n}\r\n\r\n// Standard option type\r\npub enum Option<T> {\r\n  Some(T),\r\n  None\r\n}\r\n\r\n// Standard result type\r\npub enum Result<T, E> {\r\n  Ok(T),\r\n  Err(E)\r\n}\r\n\r\n// Key-value pair for JSON objects\r\npub struct Entry {\r\n  key: string,\r\n  value: JsonValue\r\n}\r\n\r\n// JSON value representation\r\npub enum JsonValue {\r\n  Null,\r\n  Bool(bool),\r\n  Number(float),\r\n  String(string),\r\n  Array(List<JsonValue>),\r\n  Object(List<Entry>)\r\n}\r\n\r\n// Lexer tokens\r\npub enum Token {\r\n  LeftBrace,\r\n  RightBrace,\r\n  LeftBracket,\r\n  RightBracket,\r\n  Colon,\r\n  Comma,\r\n  StringLit(string),\r\n  NumberLit(float),\r\n  TrueLit,\r\n  FalseLit,\r\n  NullLit,\r\n  Eof\r\n}\r\n\r\n// Parse errors with context\r\npub enum ParseError {\r\n  UnexpectedToken(string, int),\r\n  UnexpectedEof,\r\n  InvalidNumber(string),\r\n  InvalidString(string),\r\n  UnexpectedChar(string, int)\r\n}\r\n\r\n\r\nstruct LexResult {\r\n  token: Token,\r\n  pos: int\r\n}\r\n\r\nstruct DigitScan {\r\n  text: string,\r\n  pos: int,\r\n  found: bool\r\n}\r\n\r\n// Main lexer entry point\r\npub fn lex(input: string) -> Result<List<Token>, ParseError> {\r\n  let acc: List<Token> = List.Nil\r\n  match lex_tokens(input, 0, acc) {\r\n    Result.Ok(tokens) => { return Result.Ok(list_reverse_tokens(tokens)) },\r\n    Result.Err(e) => { return Result.Err(e) }\r\n  }\r\n}\r\n\r\n// Recursive tokenization (accumulates in reverse)\r\nfn lex_tokens(input: string, pos: int, acc: List<Token>) -> Result<List<Token>, ParseError> {\r\n  let next_pos = skip_whitespace(input, pos)\r\n  let len = str.length(input)\r\n\r\n  if (next_pos >= len) {\r\n    return Result.Ok(List.Cons(Token.Eof, acc))\r\n  }\r\n\r\n  match str.char_at(input, next_pos) {\r\n    Option.Some(c) => {\r\n      if (str.eq(c, \"{\")) {\r\n        return lex_tokens(input, next_pos + 1, List.Cons(Token.LeftBrace, acc))\r\n      }\r\n      if (str.eq(c, \"}\")) {\r\n        return lex_tokens(input, next_pos + 1, List.Cons(Token.RightBrace, acc))\r\n      }\r\n      if (str.eq(c, \"[\")) {\r\n        return lex_tokens(input, next_pos + 1, List.Cons(Token.LeftBracket, acc))\r\n      }\r\n      if (str.eq(c, \"]\")) {\r\n        return lex_tokens(input, next_pos + 1, List.Cons(Token.RightBracket, acc))\r\n      }\r\n      if (str.eq(c, \":\")) {\r\n        return lex_tokens(input, next_pos + 1, List.Cons(Token.Colon, acc))\r\n      }\r\n      if (str.eq(c, \",\")) {\r\n        return lex_tokens(input, next_pos + 1, List.Cons(Token.Comma, acc))\r\n      }\r\n      if (str.eq(c, \"\\\"\")) {\r\n        match lex_string(input, next_pos + 1, \"\") {\r\n          Result.Ok(res) => { return lex_tokens(input, res.pos, List.Cons(res.token, acc)) },\r\n          Result.Err(e) => { return Result.Err(e) }\r\n        }\r\n      }\r\n      if (str.is_digit(c) || str.eq(c, \"-\")) {\r\n        match lex_number(input, next_pos, \"\") {\r\n          Result.Ok(res) => { return lex_tokens(input, res.pos, List.Cons(res.token, acc)) },\r\n          Result.Err(e) => { return Result.Err(e) }\r\n        }\r\n      }\r\n      if (match_literal(input, next_pos, \"true\") && is_delimiter(input, next_pos + 4)) {\r\n        return lex_tokens(input, next_pos + 4, List.Cons(Token.TrueLit, acc))\r\n      }\r\n      if (match_literal(input, next_pos, \"false\") && is_delimiter(input, next_pos + 5)) {\r\n        return lex_tokens(input, next_pos + 5, List.Cons(Token.FalseLit, acc))\r\n      }\r\n      if (match_literal(input, next_pos, \"null\") && is_delimiter(input, next_pos + 4)) {\r\n        return lex_tokens(input, next_pos + 4, List.Cons(Token.NullLit, acc))\r\n      }\r\n\r\n      return Result.Err(ParseError.UnexpectedChar(c, next_pos))\r\n    },\r\n    Option.None => { return Result.Err(ParseError.UnexpectedEof) }\r\n  }\r\n}\r\n\r\n// Helper: skip whitespace\r\nfn skip_whitespace(input: string, pos: int) -> int {\r\n  match str.char_at(input, pos) {\r\n    Option.Some(c) => {\r\n      if (str.is_whitespace(c)) {\r\n        return skip_whitespace(input, pos + 1)\r\n      }\r\n      return pos\r\n    },\r\n    Option.None => { return pos }\r\n  }\r\n}\r\n\r\n// Helper: match literal string at position\r\nfn match_literal(input: string, pos: int, literal: string) -> bool {\r\n  return match_literal_at(input, pos, literal, 0)\r\n}\r\n\r\nfn match_literal_at(input: string, pos: int, literal: string, idx: int) -> bool {\r\n  match str.char_at(literal, idx) {\r\n    Option.None => { return true },\r\n    Option.Some(ch) => {\r\n      match str.char_at(input, pos + idx) {\r\n        Option.Some(c) => {\r\n          if (str.eq(c, ch)) {\r\n            return match_literal_at(input, pos, literal, idx + 1)\r\n          }\r\n          return false\r\n        },\r\n        Option.None => { return false }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfn is_delimiter(input: string, pos: int) -> bool {\r\n  match str.char_at(input, pos) {\r\n    Option.None => { return true },\r\n    Option.Some(c) => {\r\n      if (str.is_whitespace(c)) { return true }\r\n      if (str.eq(c, \",\")) { return true }\r\n      if (str.eq(c, \"]\")) { return true }\r\n      if (str.eq(c, \"}\")) { return true }\r\n      if (str.eq(c, \":\")) { return true }\r\n      return false\r\n    }\r\n  }\r\n}\r\n\r\nfn escape_char(c: string) -> Option<string> {\r\n  if (str.eq(c, \"\\\"\")) { return Option.Some(\"\\\"\") }\r\n  if (str.eq(c, \"\\\\\")) { return Option.Some(\"\\\\\") }\r\n  if (str.eq(c, \"/\")) { return Option.Some(\"/\") }\r\n  if (str.eq(c, \"b\")) { return Option.Some(\"\\u0008\") }\r\n  if (str.eq(c, \"f\")) { return Option.Some(\"\\u000C\") }\r\n  if (str.eq(c, \"n\")) { return Option.Some(\"\\u000A\") }\r\n  if (str.eq(c, \"r\")) { return Option.Some(\"\\u000D\") }\r\n  if (str.eq(c, \"t\")) { return Option.Some(\"\\u0009\") }\r\n  return Option.None\r\n}\r\n\r\n// Lex string literal (basic escapes)\r\nfn lex_string(input: string, pos: int, acc: string) -> Result<LexResult, ParseError> {\r\n  match str.char_at(input, pos) {\r\n    Option.None => { return Result.Err(ParseError.UnexpectedEof) },\r\n    Option.Some(c) => {\r\n      if (str.eq(c, \"\\\"\")) {\r\n        return Result.Ok(LexResult { token: Token.StringLit(acc), pos: pos + 1 })\r\n      }\r\n      if (str.eq(c, \"\\\\\")) {\r\n        match str.char_at(input, pos + 1) {\r\n          Option.None => { return Result.Err(ParseError.UnexpectedEof) },\r\n          Option.Some(esc) => {\r\n            match escape_char(esc) {\r\n              Option.Some(decoded) => { return lex_string(input, pos + 2, str.concat(acc, decoded)) },\r\n              Option.None => { return Result.Err(ParseError.InvalidString(acc)) }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return lex_string(input, pos + 1, str.concat(acc, c))\r\n    }\r\n  }\r\n}\r\n\r\nfn take_digits(input: string, pos: int, acc: string, found: bool) -> DigitScan {\r\n  match str.char_at(input, pos) {\r\n    Option.Some(c) => {\r\n      if (str.is_digit(c)) {\r\n        return take_digits(input, pos + 1, str.concat(acc, c), true)\r\n      }\r\n      return DigitScan { text: acc, pos: pos, found: found }\r\n    },\r\n    Option.None => { return DigitScan { text: acc, pos: pos, found: found } }\r\n  }\r\n}\r\n\r\n// Lex number literal\r\nfn lex_number(input: string, pos: int, acc: string) -> Result<LexResult, ParseError> {\r\n  let mut scan_pos = pos\r\n  let mut text = acc\r\n\r\n  match str.char_at(input, scan_pos) {\r\n    Option.Some(c) => {\r\n      if (str.eq(c, \"-\")) {\r\n        text = str.concat(text, \"-\")\r\n        scan_pos = scan_pos + 1\r\n      }\r\n    },\r\n    Option.None => { return Result.Err(ParseError.UnexpectedEof) }\r\n  }\r\n\r\n  let mut scan = take_digits(input, scan_pos, text, false)\r\n  if (scan.found == false) {\r\n    return Result.Err(ParseError.InvalidNumber(scan.text))\r\n  }\r\n\r\n  scan_pos = scan.pos\r\n  text = scan.text\r\n\r\n  match str.char_at(input, scan_pos) {\r\n    Option.Some(c) => {\r\n      if (str.eq(c, \".\")) {\r\n        scan = take_digits(input, scan_pos + 1, str.concat(text, \".\"), false)\r\n        if (scan.found == false) {\r\n          return Result.Err(ParseError.InvalidNumber(scan.text))\r\n        }\r\n        scan_pos = scan.pos\r\n        text = scan.text\r\n      }\r\n    },\r\n    Option.None => {}\r\n  }\r\n\r\n  match str.char_at(input, scan_pos) {\r\n    Option.Some(c) => {\r\n      if (str.eq(c, \"e\") || str.eq(c, \"E\")) {\r\n        text = str.concat(text, c)\r\n        scan_pos = scan_pos + 1\r\n        match str.char_at(input, scan_pos) {\r\n          Option.Some(sign) => {\r\n            if (str.eq(sign, \"+\") || str.eq(sign, \"-\")) {\r\n              text = str.concat(text, sign)\r\n              scan_pos = scan_pos + 1\r\n            }\r\n          },\r\n          Option.None => {}\r\n        }\r\n        scan = take_digits(input, scan_pos, text, false)\r\n        if (scan.found == false) {\r\n          return Result.Err(ParseError.InvalidNumber(scan.text))\r\n        }\r\n        scan_pos = scan.pos\r\n        text = scan.text\r\n      }\r\n    },\r\n    Option.None => {}\r\n  }\r\n\r\n  match str.to_float(text) {\r\n    Result.Ok(n) => { return Result.Ok(LexResult { token: Token.NumberLit(n), pos: scan_pos }) },\r\n    Result.Err(_) => { return Result.Err(ParseError.InvalidNumber(text)) }\r\n  }\r\n}\r\n\r\nfn list_nil_tokens() -> List<Token> {\r\n  return List.Nil\r\n}\r\n\r\nfn list_reverse_tokens(list: List<Token>) -> List<Token> {\r\n  return list_reverse_tokens_into(list, list_nil_tokens())\r\n}\r\n\r\nfn list_reverse_tokens_into(list: List<Token>, acc: List<Token>) -> List<Token> {\r\n  match list {\r\n    List.Nil => { return acc },\r\n    List.Cons(head, tail) => { return list_reverse_tokens_into(tail, List.Cons(head, acc)) }\r\n  }\r\n}\r\n\r\n\r\nstruct ParseResult {\r\n  value: JsonValue,\r\n  rest: List<Token>\r\n}\r\n\r\nstruct MembersResult {\r\n  members: List<Entry>,\r\n  rest: List<Token>\r\n}\r\n\r\nstruct ElementsResult {\r\n  elements: List<JsonValue>,\r\n  rest: List<Token>\r\n}\r\n\r\n// Main parse entry point\r\npub fn parse(input: string) -> Result<JsonValue, ParseError> {\r\n  match lex(input) {\r\n    Result.Ok(tokens) => {\r\n      match parse_value(tokens) {\r\n        Result.Ok(res) => {\r\n          match res.rest {\r\n            List.Cons(tok, _) => {\r\n              if (token_eq(tok, Token.Eof)) {\r\n                return Result.Ok(res.value)\r\n              }\r\n              return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0))\r\n            },\r\n            List.Nil => { return Result.Ok(res.value) }\r\n          }\r\n        },\r\n        Result.Err(e) => { return Result.Err(e) }\r\n      }\r\n    },\r\n    Result.Err(e) => { return Result.Err(e) }\r\n  }\r\n}\r\n\r\n// Parse any JSON value\r\nfn parse_value(tokens: List<Token>) -> Result<ParseResult, ParseError> {\r\n  match tokens {\r\n    List.Nil => { return Result.Err(ParseError.UnexpectedEof) },\r\n    List.Cons(tok, rest) => {\r\n      match tok {\r\n        Token.NullLit => { return Result.Ok(ParseResult { value: JsonValue.Null, rest: rest }) },\r\n        Token.TrueLit => { return Result.Ok(ParseResult { value: JsonValue.Bool(true), rest: rest }) },\r\n        Token.FalseLit => { return Result.Ok(ParseResult { value: JsonValue.Bool(false), rest: rest }) },\r\n        Token.NumberLit(n) => { return Result.Ok(ParseResult { value: JsonValue.Number(n), rest: rest }) },\r\n        Token.StringLit(s) => { return Result.Ok(ParseResult { value: JsonValue.String(s), rest: rest }) },\r\n        Token.LeftBrace => { return parse_object(rest) },\r\n        Token.LeftBracket => { return parse_array(rest) },\r\n        _ => { return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0)) }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Parse object: { \"key\": value, ... }\r\nfn parse_object(tokens: List<Token>) -> Result<ParseResult, ParseError> {\r\n  match tokens {\r\n    List.Nil => { return Result.Err(ParseError.UnexpectedEof) },\r\n    List.Cons(tok, _) => {\r\n      if (token_eq(tok, Token.RightBrace)) {\r\n        return Result.Ok(ParseResult { value: JsonValue.Object(List.Nil), rest: tokens })\r\n      }\r\n      match parse_members(tokens, List.Nil) {\r\n        Result.Ok(members_res) => {\r\n          match expect_token(members_res.rest, Token.RightBrace) {\r\n            Result.Ok(rest) => {\r\n              return Result.Ok(ParseResult {\r\n                value: JsonValue.Object(list_reverse_entries(members_res.members)),\r\n                rest: rest\r\n              })\r\n            },\r\n            Result.Err(e) => { return Result.Err(e) }\r\n          }\r\n        },\r\n        Result.Err(e) => { return Result.Err(e) }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Parse object members\r\nfn parse_members(tokens: List<Token>, acc: List<Entry>) -> Result<MembersResult, ParseError> {\r\n  match tokens {\r\n    List.Cons(tok, rest1) => {\r\n      match tok {\r\n        Token.StringLit(key) => {\r\n          match expect_token(rest1, Token.Colon) {\r\n            Result.Ok(rest2) => {\r\n              match parse_value(rest2) {\r\n                Result.Ok(val_res) => {\r\n                  let entry = Entry { key: key, value: val_res.value }\r\n                  match val_res.rest {\r\n                    List.Cons(next, rest3) => {\r\n                      if (token_eq(next, Token.Comma)) {\r\n                        return parse_members(rest3, List.Cons(entry, acc))\r\n                      }\r\n                      return Result.Ok(MembersResult { members: List.Cons(entry, acc), rest: val_res.rest })\r\n                    },\r\n                    List.Nil => {\r\n                      return Result.Ok(MembersResult { members: List.Cons(entry, acc), rest: val_res.rest })\r\n                    }\r\n                  }\r\n                },\r\n                Result.Err(e) => { return Result.Err(e) }\r\n              }\r\n            },\r\n            Result.Err(e) => { return Result.Err(e) }\r\n          }\r\n        },\r\n        _ => { return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0)) }\r\n      }\r\n    },\r\n    List.Nil => { return Result.Err(ParseError.UnexpectedEof) }\r\n  }\r\n}\r\n\r\n// Parse array: [ value, ... ]\r\nfn parse_array(tokens: List<Token>) -> Result<ParseResult, ParseError> {\r\n  match tokens {\r\n    List.Nil => { return Result.Err(ParseError.UnexpectedEof) },\r\n    List.Cons(tok, _) => {\r\n      if (token_eq(tok, Token.RightBracket)) {\r\n        return Result.Ok(ParseResult { value: JsonValue.Array(List.Nil), rest: tokens })\r\n      }\r\n      match parse_elements(tokens, List.Nil) {\r\n        Result.Ok(elems_res) => {\r\n          match expect_token(elems_res.rest, Token.RightBracket) {\r\n            Result.Ok(rest) => {\r\n              return Result.Ok(ParseResult {\r\n                value: JsonValue.Array(list_reverse_values(elems_res.elements)),\r\n                rest: rest\r\n              })\r\n            },\r\n            Result.Err(e) => { return Result.Err(e) }\r\n          }\r\n        },\r\n        Result.Err(e) => { return Result.Err(e) }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Parse array elements\r\nfn parse_elements(tokens: List<Token>, acc: List<JsonValue>) -> Result<ElementsResult, ParseError> {\r\n  match parse_value(tokens) {\r\n    Result.Ok(val_res) => {\r\n      match val_res.rest {\r\n        List.Cons(tok, rest) => {\r\n          if (token_eq(tok, Token.Comma)) {\r\n            return parse_elements(rest, List.Cons(val_res.value, acc))\r\n          }\r\n          return Result.Ok(ElementsResult { elements: List.Cons(val_res.value, acc), rest: val_res.rest })\r\n        },\r\n        List.Nil => { return Result.Ok(ElementsResult { elements: List.Cons(val_res.value, acc), rest: val_res.rest }) }\r\n      }\r\n    },\r\n    Result.Err(e) => { return Result.Err(e) }\r\n  }\r\n}\r\n\r\n// Expect a specific token\r\nfn expect_token(tokens: List<Token>, expected: Token) -> Result<List<Token>, ParseError> {\r\n  match tokens {\r\n    List.Nil => { return Result.Err(ParseError.UnexpectedEof) },\r\n    List.Cons(tok, rest) => {\r\n      if (token_eq(tok, expected)) {\r\n        return Result.Ok(rest)\r\n      }\r\n      return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0))\r\n    }\r\n  }\r\n}\r\n\r\n// Token equality check\r\nfn token_eq(a: Token, b: Token) -> bool {\r\n  match a {\r\n    Token.LeftBrace => {\r\n      match b {\r\n        Token.LeftBrace => { return true },\r\n        _ => { return false }\r\n      }\r\n    },\r\n    Token.RightBrace => {\r\n      match b {\r\n        Token.RightBrace => { return true },\r\n        _ => { return false }\r\n      }\r\n    },\r\n    Token.LeftBracket => {\r\n      match b {\r\n        Token.LeftBracket => { return true },\r\n        _ => { return false }\r\n      }\r\n    },\r\n    Token.RightBracket => {\r\n      match b {\r\n        Token.RightBracket => { return true },\r\n        _ => { return false }\r\n      }\r\n    },\r\n    Token.Colon => {\r\n      match b {\r\n        Token.Colon => { return true },\r\n        _ => { return false }\r\n      }\r\n    },\r\n    Token.Comma => {\r\n      match b {\r\n        Token.Comma => { return true },\r\n        _ => { return false }\r\n      }\r\n    },\r\n    Token.Eof => {\r\n      match b {\r\n        Token.Eof => { return true },\r\n        _ => { return false }\r\n      }\r\n    },\r\n    _ => { return false }\r\n  }\r\n}\r\n\r\n// Get token name for error messages\r\nfn token_name(tok: Token) -> string {\r\n  match tok {\r\n    Token.LeftBrace => { return \"{\" },\r\n    Token.RightBrace => { return \"}\" },\r\n    Token.LeftBracket => { return \"[\" },\r\n    Token.RightBracket => { return \"]\" },\r\n    Token.Colon => { return \":\" },\r\n    Token.Comma => { return \",\" },\r\n    Token.StringLit(_) => { return \"string\" },\r\n    Token.NumberLit(_) => { return \"number\" },\r\n    Token.TrueLit => { return \"true\" },\r\n    Token.FalseLit => { return \"false\" },\r\n    Token.NullLit => { return \"null\" },\r\n    Token.Eof => { return \"EOF\" }\r\n  }\r\n}\r\n\r\n// List reverse helper\r\nfn list_nil_entries() -> List<Entry> {\r\n  return List.Nil\r\n}\r\n\r\nfn list_reverse_entries(list: List<Entry>) -> List<Entry> {\r\n  return list_reverse_entries_into(list, list_nil_entries())\r\n}\r\n\r\nfn list_reverse_entries_into(list: List<Entry>, acc: List<Entry>) -> List<Entry> {\r\n  match list {\r\n    List.Nil => { return acc },\r\n    List.Cons(head, tail) => { return list_reverse_entries_into(tail, List.Cons(head, acc)) }\r\n  }\r\n}\r\n\r\nfn list_nil_values() -> List<JsonValue> {\r\n  return List.Nil\r\n}\r\n\r\nfn list_reverse_values(list: List<JsonValue>) -> List<JsonValue> {\r\n  return list_reverse_values_into(list, list_nil_values())\r\n}\r\n\r\nfn list_reverse_values_into(list: List<JsonValue>, acc: List<JsonValue>) -> List<JsonValue> {\r\n  match list {\r\n    List.Nil => { return acc },\r\n    List.Cons(head, tail) => { return list_reverse_values_into(tail, List.Cons(head, acc)) }\r\n  }\r\n}\r\n\r\n\r\n// Main stringify entry point (pretty-printed with 2-space indent)\r\npub fn stringify(value: JsonValue) -> string {\r\n  return stringify_indent(value, 0)\r\n}\r\n\r\n// Stringify with indentation level\r\nfn stringify_indent(value: JsonValue, indent: int) -> string {\r\n  match value {\r\n    JsonValue.Null => { return \"null\" },\r\n    JsonValue.Bool(b) => {\r\n      if (b) { return \"true\" }\r\n      return \"false\"\r\n    },\r\n    JsonValue.Number(n) => { return str.from_float(n) },\r\n    JsonValue.String(s) => { return str.concat(str.concat(\"\\\"\", escape_string(s)), \"\\\"\") },\r\n    JsonValue.Array(elems) => { return stringify_array(elems, indent) },\r\n    JsonValue.Object(members) => { return stringify_object(members, indent) }\r\n  }\r\n}\r\n\r\n// Stringify array with indentation\r\nfn stringify_array(elems: List<JsonValue>, indent: int) -> string {\r\n  match elems {\r\n    List.Nil => { return \"[]\" },\r\n    _ => {\r\n      let inner = stringify_elements(elems, indent + 1, true)\r\n      return str.concat(str.concat(\"[\\u000A\", inner), str.concat(\"\\u000A\", str.concat(make_indent(indent), \"]\")))\r\n    }\r\n  }\r\n}\r\n\r\n// Stringify array elements\r\nfn stringify_elements(elems: List<JsonValue>, indent: int, first: bool) -> string {\r\n  match elems {\r\n    List.Nil => { return \"\" },\r\n    List.Cons(head, tail) => {\r\n      let prefix = prefix_for(first)\r\n      let elem_str = str.concat(make_indent(indent), stringify_indent(head, indent))\r\n      match tail {\r\n        List.Nil => { return str.concat(prefix, elem_str) },\r\n        _ => { return str.concat(str.concat(prefix, elem_str), stringify_elements(tail, indent, false)) }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Stringify object with indentation\r\nfn stringify_object(members: List<Entry>, indent: int) -> string {\r\n  match members {\r\n    List.Nil => { return \"{}\" },\r\n    _ => {\r\n      let inner = stringify_members(members, indent + 1, true)\r\n      return str.concat(str.concat(\"{\\u000A\", inner), str.concat(\"\\u000A\", str.concat(make_indent(indent), \"}\")))\r\n    }\r\n  }\r\n}\r\n\r\n// Stringify object members\r\nfn stringify_members(members: List<Entry>, indent: int, first: bool) -> string {\r\n  match members {\r\n    List.Nil => { return \"\" },\r\n    List.Cons(head, tail) => {\r\n      let prefix = prefix_for(first)\r\n      let key_str = str.concat(str.concat(\"\\\"\", escape_string(head.key)), \"\\\"\")\r\n      let val_str = stringify_indent(head.value, indent)\r\n      let member_str = str.concat(make_indent(indent), str.concat(key_str, str.concat(\": \", val_str)))\r\n      match tail {\r\n        List.Nil => { return str.concat(prefix, member_str) },\r\n        _ => { return str.concat(str.concat(prefix, member_str), stringify_members(tail, indent, false)) }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfn prefix_for(first: bool) -> string {\r\n  if (first) { return \"\" }\r\n  return \",\\u000A\"\r\n}\r\n\r\n// Create indentation string (2 spaces per level)\r\nfn make_indent(level: int) -> string {\r\n  if (level <= 0) { return \"\" }\r\n  return str.concat(\"  \", make_indent(level - 1))\r\n}\r\n\r\n// Escape string for JSON\r\nfn escape_string(s: string) -> string {\r\n  return escape_string_at(s, 0, \"\")\r\n}\r\n\r\nfn escape_string_at(s: string, pos: int, acc: string) -> string {\r\n  match str.char_at(s, pos) {\r\n    Option.None => { return acc },\r\n    Option.Some(c) => {\r\n      let escaped = escape_json_char(c)\r\n      return escape_string_at(s, pos + 1, str.concat(acc, escaped))\r\n    }\r\n  }\r\n}\r\n\r\nfn escape_json_char(c: string) -> string {\r\n  if (str.eq(c, \"\\\"\")) { return \"\\\\\\\"\" }\r\n  if (str.eq(c, \"\\\\\")) { return \"\\\\\\\\\" }\r\n  if (str.eq(c, \"\\u000A\")) { return \"\\\\n\" }\r\n  if (str.eq(c, \"\\u000D\")) { return \"\\\\r\" }\r\n  if (str.eq(c, \"\\u0009\")) { return \"\\\\t\" }\r\n  return c\r\n}\r\n\r\n\r\npub fn main() -> void {\r\n  io.println(\"Lumina JSON Parser\")\r\n  io.println(\"Enter JSON (or 'exit' to quit):\")\r\n  io.println(\"\")\r\n\r\n  repl()\r\n}\r\n\r\nfn repl() -> void {\r\n  io.print(\"> \")\r\n\r\n  match io.readLine() {\r\n    Option.Some(input) => {\r\n      if (str.eq(input, \"exit\")) {\r\n        io.println(\"Goodbye!\")\r\n      } else {\r\n        if (str.eq(input, \"\")) {\r\n          repl()\r\n        } else {\r\n          process_input(input)\r\n          repl()\r\n        }\r\n      }\r\n    },\r\n    Option.None => {\r\n      io.println(\"No input available\")\r\n      repl()\r\n    }\r\n  }\r\n}\r\n\r\nfn process_input(input: string) -> void {\r\n  match parse(input) {\r\n    Result.Ok(value) => {\r\n      io.println(\"Parsed successfully:\")\r\n      io.println(stringify(value))\r\n      io.println(\"\")\r\n    },\r\n    Result.Err(error) => {\r\n      io.println(\"Parse error:\")\r\n      io.println(format_error(error))\r\n      io.println(\"\")\r\n    }\r\n  }\r\n}\r\n\r\nfn format_error(error: ParseError) -> string {\r\n  match error {\r\n    ParseError.UnexpectedToken(tok, pos) => {\r\n      return str.concat(\"Unexpected token: \", str.concat(tok, str.concat(\" at position \", str.from_int(pos))))\r\n    },\r\n    ParseError.UnexpectedEof => { return \"Unexpected end of input\" },\r\n    ParseError.InvalidNumber(s) => { return str.concat(\"Invalid number: \", s) },\r\n    ParseError.InvalidString(s) => { return str.concat(\"Invalid string: \", s) },\r\n    ParseError.UnexpectedChar(c, pos) => {\r\n      return str.concat(\"Unexpected character: \", str.concat(c, str.concat(\" at position \", str.from_int(pos))))\r\n    }\r\n  }\r\n}\r\n\r\nmain()\r\n\r\n"
  ]
}