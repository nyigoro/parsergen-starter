{
  let nodeId = 0;
  function createNode(type, data, loc) {
    const resolvedLoc = data && data.location ? data.location : loc();
    return { id: ++nodeId, type: type, ...data, location: resolvedLoc };
  }

  function expectedStatementTokens() {
    return [
      "fn", "async", "struct", "enum", "type", "extern", "import", "pub", "trait", "impl",
      "let", "if", "while", "match", "return",
      "identifier", "number", "string", "true", "false",
      "{", "}"
    ];
  }
}
Start
  = _ statements:TopStatementList _ { return createNode("Program", { body: statements }, location); }

TopStatementList
  = head:RecoverableTopStatement tail:(_ RecoverableTopStatement)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

RecoverableTopStatement
  = stmt:Statement { return stmt; }
  / error:InvalidStatement { return error; }
  / _ "}" {
      return createNode("ErrorNode", {
        message: "Unexpected closing brace. Possible double-closing of a block or function.",
        expected: expectedStatementTokens()
      }, location);
    }

StatementList
  = head:RecoverableStatement tail:(_ RecoverableStatement)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

RecoverableStatement
  = stmt:Statement { return stmt; }
  / error:InvalidStatement { return error; }

SyncKeyword
  = "fn" / "struct" / "enum" / "type" / "extern" / "import" / "pub" / "trait" / "impl"

InvalidStatement
  = tokens:(!(";" / "}" / SyncKeyword) .)+ (";" / &"}" / &SyncKeyword / !.) {
      return createNode("ErrorNode", {
        message: "Invalid syntax",
        expected: expectedStatementTokens()
      }, location);
    }

Statement
  = Import
  / TraitDecl
  / ImplDecl
  / StructDecl
  / EnumDecl
  / AdtTypeDecl
  / TypeDecl
  / ExternTypeDecl
  / FnDecl
  / ExternFnDecl
  / LetStmt
  / AssignStmt
  / IfStmt
  / WhileStmt
  / ReturnStmt
  / MatchStmt
  / ExprStmt
  / Block

Import
  = "import" _ spec:ImportSpec _ "from" _ source:String _ ";"? {
      return createNode("Import", { spec, source }, location);
    }

ImportSpec
  = "{" _ list:ImportList _ "}" { return list; }
  / NamespaceImport
  / Identifier

ImportList
  = head:ImportItem tail:(_ "," _ ImportItem)* { return [head].concat(tail.map(t => t[3])); }

ImportItem
  = name:IdName _ "as" _ alias:IdName { return { name: name.name, alias: alias.name, location: name.location }; }
  / name:IdName { return { name: name.name, location: name.location }; }

NamespaceImport
  = "*" _ "as" _ alias:IdName { return { name: alias.name, namespace: true, location: alias.location }; }

TypeDecl
  = visibility:Visibility? _ "type" _ node:IdName _ tparams:TypeParams? _ "=" _ body:TypeBody _ ";"? {
      return createNode("TypeDecl", { name: node.name, body, typeParams: tparams || [], visibility: visibility ?? "private", extern: false, location: node.location }, location);
    }

TraitDecl
  = visibility:Visibility? _ "trait" _ node:IdName _ tparams:TypeParams? _ "{" _ items:TraitItemList? _ "}" _ ";"? {
      const methods = [];
      const associatedTypes = [];
      for (const item of items || []) {
        if (item && item.type === "TraitMethod") methods.push(item);
        if (item && item.type === "TraitAssocType") associatedTypes.push(item);
      }
      return createNode("TraitDecl", { name: node.name, typeParams: tparams || [], methods, associatedTypes, visibility: visibility ?? "private", location: node.location }, location);
    }

TraitItemList
  = head:TraitItem tail:(_ TraitItem)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

TraitItem
  = TraitAssocType / TraitMethod

TraitAssocType
  = "type" _ node:IdName _ defaultType:(_ "=" _ TypeName)? _ ";"? {
      return createNode("TraitAssocType", { name: node.name, typeName: defaultType ? defaultType[3] : null, location: node.location }, location);
    }

TraitMethod
  = "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ body:TraitMethodBody {
      return createNode("TraitMethod", { name: node.name, params: params || [], returnType: ret || null, typeParams: tparams || [], body, location: node.location }, location);
    }

TraitMethodBody
  = _ body:Block { return body; }
  / _ ";"? { return null; }

ImplDecl
  = visibility:Visibility? _ "impl" _ tparams:TypeParams? _ traitType:TypeName _ _ "for" _ forType:TypeName _ "{" _ items:ImplItemList? _ "}" _ ";"? {
      const methods = [];
      const associatedTypes = [];
      for (const item of items || []) {
        if (item && item.type === "FnDecl") methods.push(item);
        if (item && item.type === "ImplAssocType") associatedTypes.push(item);
      }
      return createNode("ImplDecl", { traitType, forType, typeParams: tparams || [], methods, associatedTypes, visibility: visibility ?? "private", location: location() }, location);
    }

ImplItemList
  = head:ImplItem tail:(_ ImplItem)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

ImplItem
  = ImplAssocType / ImplMethod

ImplAssocType
  = "type" _ node:IdName _ "=" _ typeName:TypeName _ ";"? {
      return createNode("ImplAssocType", { name: node.name, typeName, location: node.location }, location);
    }

ImplMethod
  = visibility:Visibility? _ async:("async" __)? "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ body:Block {
      return createNode("FnDecl", { name: node.name, async: !!async, params: params || [], returnType: ret || null, body, typeParams: tparams || [], visibility: visibility ?? "private", extern: false, location: node.location }, location);
    }

AdtTypeDecl
  = visibility:Visibility? _ "type" _ node:IdName _ tparams:TypeParams? _ "=" _ variants:AdtVariantList _ ";"? {
      return createNode("EnumDecl", { name: node.name, variants: variants || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location }, location);
    }

StructDecl
  = visibility:Visibility? _ "struct" _ node:IdName _ tparams:TypeParams? _ "{" _ fields:TypeFieldList? _ "}" _ ";"? {
      return createNode("StructDecl", { name: node.name, body: fields || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location }, location);
    }

EnumDecl
  = visibility:Visibility? _ "enum" _ node:IdName _ tparams:TypeParams? _ "{" _ variants:EnumVariantList? _ "}" _ ";"? {
      return createNode("EnumDecl", { name: node.name, variants: variants || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location }, location);
    }

ExternTypeDecl
  = visibility:Visibility? _ "extern" _ "type" _ node:IdName _ tparams:TypeParams? _ source:FromClause? _ ";"? {
      return createNode("TypeDecl", { name: node.name, body: [], typeParams: tparams || [], visibility: visibility ?? "public", extern: true, externModule: source ?? null, location: node.location }, location);
    }

TypeBody
  = "{" _ fields:TypeFieldList? _ "}" { return fields || []; }

TypeFieldList
  = head:TypeField tail:(_ "," _ TypeField)* { return [head].concat(tail.map(t => t[3])); }

TypeField
  = node:IdName _ ":" _ typeName:TypeName { return { name: node.name, typeName, location: node.location }; }

TypeName
  = "_" { return { kind: "TypeHole", location: location() }; }
  / path:TypePath _ args:TypeArgs? {
      const base = path.join("::");
      if (!args) return base;
      const rendered = args.map(arg => typeof arg === "string" ? arg : "_");
      return `${base}<${rendered.join(",")}>`;
    }

TypePath
  = head:IdName tail:(_ "::" _ IdName)* { return [head.name].concat(tail.map(t => t[3].name)); }

FnDecl
  = visibility:Visibility? _ async:("async" __)? "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ body:Block {
      return createNode("FnDecl", { name: node.name, async: !!async, params: params || [], returnType: ret || null, body, typeParams: tparams || [], visibility: visibility ?? "private", extern: false, location: node.location }, location);
    }

ExternFnDecl
  = visibility:Visibility? _ "extern" _ "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ source:FromClause? _ ";"? {
      return createNode("FnDecl", { name: node.name, params: params || [], returnType: ret || "any", body: createNode("Block", { body: [] }, location), typeParams: tparams || [], visibility: visibility ?? "public", extern: true, externModule: source ?? null, location: node.location }, location);
    }

FromClause
  = _ "from" _ source:String { return source.value; }

ReturnType
  = "->" _ type:TypeName { return type; }

TypeArgs
  = "<" _ head:TypeName tail:(_ "," _ TypeName)* _ ">" { return [head].concat(tail.map(t => t[3])); }

TypeParams
  = "<" _ head:TypeParam tail:(_ "," _ TypeParam)* _ ">" { return [head].concat(tail.map(t => t[3])); }

TypeParam
  = name:IdName _ ":" _ bound:TypeBounds { return { name: name.name, bound }; }
  / name:IdName { return { name: name.name }; }

TypeBounds
  = head:TypeName tail:(_ ("&" / "+") _ TypeName)* { return [head].concat(tail.map(t => t[3])); }

EnumVariantList
  = head:EnumVariant tail:(_ "," _ EnumVariant)* _ ","? { return [head].concat(tail.map(t => t[3])); }

EnumVariant
  = node:IdName _ params:EnumVariantParams? { return { name: node.name, params: params || [], location: node.location }; }

EnumVariantParams
  = "(" _ head:TypeName tail:(_ "," _ TypeName)* _ ")" { return [head].concat(tail.map(t => t[3])); }

AdtVariantList
  = head:AdtVariant tail:(_ "|" _ AdtVariant)* { return [head].concat(tail.map(t => t[3])); }

AdtVariant
  = node:IdName _ params:EnumVariantParams? { return { name: node.name, params: params || [], location: node.location }; }

ParamList
  = head:Param tail:(_ "," _ Param)* { return [head].concat(tail.map(t => t[3])); }

Param
  = leading:ParamRef? node:IdName _ typeAnn:(_ ":" _ trailing:ParamRef? typeName:TypeName {
      return { typeName, ref: !!trailing, refMut: !!(trailing && trailing.mut) };
    })? {
      const refFlag = !!leading || !!(typeAnn && typeAnn.ref);
      const refMut = !!(leading && leading.mut) || !!(typeAnn && typeAnn.refMut);
      return { name: node.name, typeName: typeAnn ? typeAnn.typeName : null, ref: refFlag, refMut, location: node.location };
    }

ParamRef
  = "ref" __ mut:("mut" __)? { return { mut: !!mut }; }

Block
  = "{" _ statements:StatementList _ "}" { return createNode("Block", { body: statements }, location); }

LetStmt
  = "let" _ mut:("mut" __)? node:IdName _ typeAnn:(_ ":" _ typeName:TypeName { return typeName; })? _ "=" _ value:Expr _ ";"? {
      return createNode("Let", { name: node.name, typeName: typeAnn || null, value, mutable: !!mut, location: node.location }, location);
    }

ReturnStmt
  = "return" _ value:Expr _ ";"? { return createNode("Return", { value }, location); }

MatchStmt
  = "match" _ value:Expr _ "{" _ arms:MatchArmList? _ "}" {
      return createNode("MatchStmt", { value, arms: arms || [] }, location);
    }

WhileStmt
  = "while" _ "(" _ condition:Expr _ ")" _ body:Block {
      return createNode("While", { condition, body }, location);
    }

AssignStmt
  = target:(Member / Identifier) _ "=" _ value:Expr _ ";"? { return createNode("Assign", { target, value }, location); }

IfStmt
  = "if" _ "(" _ condition:Expr _ ")" _ thenBlock:Block _ elsePart:(_ "else" _ elseBlock:Block)? {
      return createNode("If", { condition, thenBlock, elseBlock: elsePart ? elsePart[3] : null }, location);
    }

ExprStmt
  = expr:Expr _ ";"? { return createNode("ExprStmt", { expr }, location); }

Expr
  = LogicOr

LogicOr
  = head:LogicAnd tail:(_ "||" _ LogicAnd)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

LogicAnd
  = head:Pipe tail:(_ "&&" _ Pipe)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

Pipe
  = head:CastExpr tail:(_ "|>" _ PipeTarget)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: "|>", left: acc, right: t[3] }, location), head);
    }

CastExpr
  = head:Equality tail:(_ "as" _ TypeName)* {
      return tail.reduce((acc, t) => createNode("Cast", { expr: acc, targetType: t[3] }, location), head);
    }

PipeTarget
  = callee:IdName _ "(" _ args:ArgList? _ ")" {
      return createNode("Call", { callee: createNode("Identifier", { name: callee.name, location: callee.location }, location), args: args || [], typeArgs: [] }, location);
    }
  / callee:IdName {
      return createNode("Call", { callee: createNode("Identifier", { name: callee.name, location: callee.location }, location), args: [], typeArgs: [] }, location);
    }

Equality
  = head:IsExpr tail:(_ ("==" / "!=") _ IsExpr)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

IsExpr
  = head:Relational _ "is" _ qual:QualifiedVariant {
      return createNode("IsExpr", { value: head, variant: qual.variant, enumName: qual.enumName }, location);
    }
  / Relational

Relational
  = head:Range tail:(_ ("<=" / ">=" / "<" / ">") _ Range)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

Range
  = start:Add _ "..=" _ end:Add {
      return createNode("Range", { start, end, inclusive: true }, location);
    }
  / "..=" _ end:Add {
      return createNode("Range", { start: null, end, inclusive: true }, location);
    }
  / start:Add _ ".." _ end:Add {
      return createNode("Range", { start, end, inclusive: false }, location);
    }
  / ".." _ end:Add {
      return createNode("Range", { start: null, end, inclusive: false }, location);
    }
  / start:Add _ ".." {
      return createNode("Range", { start, end: null, inclusive: false }, location);
    }
  / ".." {
      return createNode("Range", { start: null, end: null, inclusive: false }, location);
    }
  / Add

Add
  = head:Mul tail:(_ ("+" / "-") _ Mul)* {
      const loc = location();
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3], location: loc }, location), head);
    }

Mul
  = head:Primary tail:(_ ("*" / "/") _ Primary)* {
      const loc = location();
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3], location: loc }, location), head);
    }

Primary
  = TryExpr

TryExpr
  = head:AwaitExpr tail:(_ "?")* {
      return tail.reduce((acc) => createNode("Try", { value: acc }, location), head);
    }
  / head:PrimaryNoAwait tail:(_ "?")* {
      return tail.reduce((acc) => createNode("Try", { value: acc }, location), head);
    }

PrimaryNoAwait
  = Postfix

Postfix
  = head:PrimaryAtom tail:PostfixPart* {
      return tail.reduce((acc, part) => {
        if (part.kind === "member") {
          return createNode("Member", { object: acc, property: part.name }, location);
        }
        if (part.kind === "index") {
          return createNode("Index", { object: acc, index: part.index }, location);
        }
        if (part.kind === "call") {
          if (acc.type === "Identifier") {
            return createNode("Call", { callee: acc, args: part.args, typeArgs: part.typeArgs }, location);
          }
          if (acc.type === "Member") {
            const callee = createNode("Identifier", { name: acc.property, location: acc.location }, location);
            return createNode("Call", { callee, args: part.args, typeArgs: part.typeArgs, receiver: acc.object }, location);
          }
          return createNode("Call", { callee: createNode("Identifier", { name: "__invalid__", location: location() }, location), args: part.args, typeArgs: part.typeArgs }, location);
        }
        return acc;
      }, head);
    }

PostfixPart
  = _ "." _ name:IdName { return { kind: "member", name: name.name }; }
  / _ "[" _ index:Expr _ "]" { return { kind: "index", index }; }
  / _ targs:TypeArgs? _ "(" _ args:ArgList? _ ")" { return { kind: "call", args: args || [], typeArgs: targs || [] }; }

PrimaryAtom
  = MatchExpr
  / ArrayLiteral
  / StructLiteral
  / LambdaExpr
  / MoveExpr
  / QualifiedCall
  / Call
  / String
  / Identifier
  / Number
  / Boolean
  / "(" _ expr:Expr _ ")" { return expr; }

AwaitExpr
  = "await" __ value:PrimaryNoAwait {
      return createNode("Await", { value }, location);
    }

StructLiteral
  = name:IdName _ targs:TypeArgs? &(_ "{") _ "{" _ fields:StructLiteralFieldList? _ "}" {
      return createNode("StructLiteral", { name: name.name, typeArgs: targs || [], fields: fields || [], location: location() }, location);
    }

ArrayLiteral
  = "[" _ elements:ArrayElements? _ "]" {
      return createNode("ArrayLiteral", { elements: elements || [] }, location);
    }

ArrayElements
  = head:Expr tail:(_ "," _ Expr)* _ ","? { return [head].concat(tail.map(t => t[3])); }

LambdaExpr
  = async:("async" __)? "fn" _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ body:Block {
      return createNode("Lambda", {
        async: !!async,
        params: params || [],
        returnType: ret || null,
        body,
        typeParams: tparams || [],
      }, location);
    }

StructLiteralFieldList
  = head:StructLiteralField tail:(_ "," _ StructLiteralField)* _ ","? { return [head].concat(tail.map(t => t[3])); }

StructLiteralField
  = field:IdName _ ":" _ value:Expr { return { name: field.name, value, location: field.location }; }

Keyword
  = ("fn" / "async" / "await" / "struct" / "enum" / "type" / "extern" / "import" / "pub" / "trait" / "impl" / "let" / "mut" / "ref" / "move"
    / "if" / "else" / "while" / "match" / "return" / "for" / "in" / "true" / "false" / "from" / "as" / "is") ![a-zA-Z0-9_]

IdName
  = !Keyword name:$([a-zA-Z_][a-zA-Z0-9_]*) { return { name, location: location() }; }

Identifier
  = node:IdName { return createNode("Identifier", { name: node.name, location: node.location }, location); }

Number
  = "0x" digits:$([0-9a-fA-F] [0-9a-fA-F_]*) suffix:NumericSuffix? {
      const cleaned = digits.replace(/_/g, "");
      const suffixValue = suffix ?? null;
      const isFloat = typeof suffixValue === "string" && suffixValue.startsWith("f");
      return createNode("Number", { value: parseInt(cleaned, 16), raw: `0x${cleaned}`, suffix: suffixValue, isFloat }, location);
    }
  / "0b" digits:$([01] [01_]*) suffix:NumericSuffix? {
      const cleaned = digits.replace(/_/g, "");
      const suffixValue = suffix ?? null;
      const isFloat = typeof suffixValue === "string" && suffixValue.startsWith("f");
      return createNode("Number", { value: parseInt(cleaned, 2), raw: `0b${cleaned}`, suffix: suffixValue, isFloat }, location);
    }
  / int:$([0-9] [0-9_]*) frac:("." digits:$([0-9_]+))? exp:ExponentPart? suffix:NumericSuffix? {
      const intPart = int.replace(/_/g, "");
      const fracPart = frac ? frac[1].replace(/_/g, "") : "";
      const expPart = exp ? exp.replace(/_/g, "") : "";
      const suffixValue = suffix ?? null;
      const hasFloat = !!frac || !!exp || (typeof suffixValue === "string" && suffixValue.startsWith("f"));
      const raw = frac ? `${intPart}.${fracPart}` : intPart;
      const rawWithExp = expPart ? `${raw}${expPart}` : raw;
      const value = hasFloat ? parseFloat(rawWithExp) : parseInt(rawWithExp, 10);
      return createNode("Number", { value, raw: rawWithExp, suffix: suffixValue, isFloat: hasFloat }, location);
    }

ExponentPart
  = [eE] sign:("+" / "-")? digits:$([0-9] [0-9_]*) { return `e${sign ?? ""}${digits}`; }

NumericSuffix
  = "i8" / "i16" / "i32" / "i64" / "i128"
  / "u8" / "u16" / "u32" / "u64" / "u128"
  / "f32" / "f64"

Boolean
  = "true" { return createNode("Boolean", { value: true }, location); }
  / "false" { return createNode("Boolean", { value: false }, location); }

String
  = RawString / TripleString / NormalString

RawString
  = "r\"" chars:RawChar* "\"" {
      return createNode("String", { value: chars.join("") }, location);
    }

RawChar
  = !"\"" char:. { return char; }

TripleString
  = "\"\"\"" parts:TriplePart* "\"\"\"" {
      const hasExpr = parts.some(part => part && part.kind === "expr");
      if (!hasExpr) {
        const text = parts.map(part => part.value).join("");
        return createNode("String", { value: text }, location);
      }
      const normalized = [];
      for (const part of parts) {
        if (!part) continue;
        if (part.kind === "text") {
          if (part.value.length > 0) normalized.push(part.value);
        } else {
          normalized.push(part.value);
        }
      }
      return createNode("InterpolatedString", { parts: normalized }, location);
    }

TriplePart
  = InterpolatedExpr / TripleText

TripleText
  = chars:TripleChar+ { return { kind: "text", value: chars.join("") }; }

TripleChar
  = !("\"\"\"" / "\\" / "{") char:. { return char; }
  / "\\" seq:EscapeSequence { return seq; }

NormalString
  = "\"" parts:InterpolatedPart* "\"" {
      const hasExpr = parts.some(part => part && part.kind === "expr");
      if (!hasExpr) {
        const text = parts.map(part => part.value).join("");
        return createNode("String", { value: text }, location);
      }
      const normalized = [];
      for (const part of parts) {
        if (!part) continue;
        if (part.kind === "text") {
          if (part.value.length > 0) normalized.push(part.value);
        } else {
          normalized.push(part.value);
        }
      }
      return createNode("InterpolatedString", { parts: normalized }, location);
    }

InterpolatedPart
  = InterpolatedExpr / InterpolatedText

InterpolatedExpr
  = "{" _ expr:Expr _ "}" { return { kind: "expr", value: expr }; }

InterpolatedText
  = chars:InterpolatedChar+ { return { kind: "text", value: chars.join("") }; }

InterpolatedChar
  = !("\"" / "\\" / "{") char:. { return char; }
  / "\\" seq:EscapeSequence { return seq; }

EscapeSequence
  = "\"" { return "\""; }
  / "\\" { return "\\"; }
  / "{" { return String.fromCharCode(123); }
  / "}" { return String.fromCharCode(125); }
  / "b" { return "\b"; }
  / "f" { return "\f"; }
  / "v" { return "\v"; }
  / "e" { return "\x1B"; }
  / "n" { return "\n"; }
  / "r" { return "\r"; }
  / "t" { return "\t"; }
  / "0" { return "\0"; }
  / "x" hex:$([0-9a-fA-F] [0-9a-fA-F]) { return String.fromCharCode(parseInt(hex.replace(/\s+/g, ""), 16)); }
  / "u" "{" hex:$([0-9a-fA-F]+) "}" {
      if (hex.length > 6) throw new Error("Invalid unicode escape");
      return String.fromCodePoint(parseInt(hex, 16));
    }
  / "u" hex:$([0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]) { return String.fromCharCode(parseInt(hex.replace(/\s+/g, ""), 16)); }

_ = (WS / Comment)*
__ = (WS / Comment)+
WS = [ \t\r\n]+
Comment = "//" [^\n]* "\n"?
  / "/*" (!"*/" .)* "*/"

MatchArmList
  = head:MatchArm tail:(_ "," _ MatchArm)* _ ","? { return [head].concat(tail.map(t => t[3])); }

MatchArm
  = pattern:MatchPattern _ "=>" _ body:Block _ ";"? { return { pattern, body, location: location() }; }

MatchPattern
  = "_" { return createNode("WildcardPattern", {}, location); }
  / qual:QualifiedVariant _ binds:MatchBindingList? { return createNode("EnumPattern", { variant: qual.variant, enumName: qual.enumName, bindings: binds || [], location: qual.location }, location); }

QualifiedVariant
  = enumName:IdName _ "." _ variant:IdName { return { enumName: enumName.name, variant: variant.name, location: enumName.location }; }
  / variant:IdName { return { enumName: null, variant: variant.name, location: variant.location }; }

MatchBindingList
  = "(" _ head:MatchBinding tail:(_ "," _ MatchBinding)* _ ")" { return [head].concat(tail.map(t => t[3])); }

MatchBinding
  = name:IdName { return name.name; }
  / "_" { return "_"; }

MatchExpr
  = "match" _ value:Expr _ "{" _ arms:MatchExprArmList? _ "}" {
      return createNode("MatchExpr", { value, arms: arms || [] }, location);
    }

MatchExprArmList
  = head:MatchExprArm tail:(_ "," _ MatchExprArm)* _ ","? { return [head].concat(tail.map(t => t[3])); }

MatchExprArm
  = pattern:MatchPattern _ "=>" _ body:Expr { return { pattern, body, location: location() }; }

Member
  = base:Identifier tail:(_ "." _ IdName)* {
      return tail.reduce((acc, t) => createNode("Member", { object: acc, property: t[3].name }, location), base);
    }
Call
  = callee:IdName _ targs:TypeArgs? _ "(" _ args:ArgList? _ ")" {
      return createNode("Call", { callee: createNode("Identifier", { name: callee.name, location: callee.location }, location), args: args || [], typeArgs: targs || [] }, location);
    }

QualifiedCall
  = enumName:IdName _ "." _ variant:IdName _ targs:TypeArgs? _ "(" _ args:ArgList? _ ")" {
      return createNode("Call", {
        callee: createNode("Identifier", { name: variant.name, location: variant.location }, location),
        args: args || [],
        typeArgs: targs || [],
        enumName: enumName.name
      }, location);
    }


ArgList
  = head:Expr tail:(_ "," _ Expr)* { return [head].concat(tail.map(t => t[3])); }
Visibility
  = "pub" { return "public"; }
MoveExpr
  = "move" __ target:(Member / Identifier) {
      return createNode("Move", { target }, location);
    }
