{
  let nodeId = 0;
  function createNode(type, data, loc) {
    const resolvedLoc = data && data.location ? data.location : loc();
    return { id: ++nodeId, type: type, ...data, location: resolvedLoc };
  }

  function expectedStatementTokens() {
    return [
      "fn", "async", "struct", "enum", "type", "extern", "import", "pub",
      "let", "if", "while", "match", "return",
      "identifier", "number", "string", "true", "false",
      "{", "}"
    ];
  }
}
Start
  = _ statements:TopStatementList _ { return createNode("Program", { body: statements }, location); }

TopStatementList
  = head:RecoverableTopStatement tail:(_ RecoverableTopStatement)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

RecoverableTopStatement
  = stmt:Statement { return stmt; }
  / error:InvalidStatement { return error; }
  / _ "}" {
      return createNode("ErrorNode", {
        message: "Unexpected closing brace. Possible double-closing of a block or function.",
        expected: expectedStatementTokens()
      }, location);
    }

StatementList
  = head:RecoverableStatement tail:(_ RecoverableStatement)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

RecoverableStatement
  = stmt:Statement { return stmt; }
  / error:InvalidStatement { return error; }

SyncKeyword
  = "fn" / "struct" / "enum" / "type" / "extern" / "import" / "pub"

InvalidStatement
  = tokens:(!(";" / "}" / SyncKeyword) .)+ (";" / &"}" / &SyncKeyword / !.) {
      return createNode("ErrorNode", {
        message: "Invalid syntax",
        expected: expectedStatementTokens()
      }, location);
    }

Statement
  = Import
  / StructDecl
  / EnumDecl
  / AdtTypeDecl
  / TypeDecl
  / ExternTypeDecl
  / FnDecl
  / ExternFnDecl
  / LetStmt
  / AssignStmt
  / IfStmt
  / WhileStmt
  / ReturnStmt
  / MatchStmt
  / ExprStmt
  / Block

Import
  = "import" _ spec:ImportSpec _ "from" _ source:String _ ";"? {
      return createNode("Import", { spec, source }, location);
    }

ImportSpec
  = "{" _ list:ImportList _ "}" { return list; }
  / NamespaceImport
  / Identifier

ImportList
  = head:ImportItem tail:(_ "," _ ImportItem)* { return [head].concat(tail.map(t => t[3])); }

ImportItem
  = name:IdName _ "as" _ alias:IdName { return { name: name.name, alias: alias.name, location: name.location }; }
  / name:IdName { return { name: name.name, location: name.location }; }

NamespaceImport
  = "*" _ "as" _ alias:IdName { return { name: alias.name, namespace: true, location: alias.location }; }

TypeDecl
  = visibility:Visibility? _ "type" _ node:IdName _ tparams:TypeParams? _ "=" _ body:TypeBody _ ";"? {
      return createNode("TypeDecl", { name: node.name, body, typeParams: tparams || [], visibility: visibility ?? "private", extern: false, location: node.location }, location);
    }

AdtTypeDecl
  = visibility:Visibility? _ "type" _ node:IdName _ tparams:TypeParams? _ "=" _ variants:AdtVariantList _ ";"? {
      return createNode("EnumDecl", { name: node.name, variants: variants || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location }, location);
    }

StructDecl
  = visibility:Visibility? _ "struct" _ node:IdName _ tparams:TypeParams? _ "{" _ fields:TypeFieldList? _ "}" _ ";"? {
      return createNode("StructDecl", { name: node.name, body: fields || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location }, location);
    }

EnumDecl
  = visibility:Visibility? _ "enum" _ node:IdName _ tparams:TypeParams? _ "{" _ variants:EnumVariantList? _ "}" _ ";"? {
      return createNode("EnumDecl", { name: node.name, variants: variants || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location }, location);
    }

ExternTypeDecl
  = visibility:Visibility? _ "extern" _ "type" _ node:IdName _ tparams:TypeParams? _ source:FromClause? _ ";"? {
      return createNode("TypeDecl", { name: node.name, body: [], typeParams: tparams || [], visibility: visibility ?? "public", extern: true, externModule: source ?? null, location: node.location }, location);
    }

TypeBody
  = "{" _ fields:TypeFieldList? _ "}" { return fields || []; }

TypeFieldList
  = head:TypeField tail:(_ "," _ TypeField)* { return [head].concat(tail.map(t => t[3])); }

TypeField
  = node:IdName _ ":" _ typeName:TypeName { return { name: node.name, typeName, location: node.location }; }

TypeName
  = "_" { return { kind: "TypeHole", location: location() }; }
  / base:IdName _ args:TypeArgs? {
      if (!args) return base.name;
      const rendered = args.map(arg => typeof arg === "string" ? arg : "_");
      return `${base.name}<${rendered.join(",")}>`;
    }

FnDecl
  = visibility:Visibility? _ async:("async" __)? "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ body:Block {
      return createNode("FnDecl", { name: node.name, async: !!async, params: params || [], returnType: ret || null, body, typeParams: tparams || [], visibility: visibility ?? "private", extern: false, location: node.location }, location);
    }

ExternFnDecl
  = visibility:Visibility? _ "extern" _ "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ source:FromClause? _ ";"? {
      return createNode("FnDecl", { name: node.name, params: params || [], returnType: ret || "any", body: createNode("Block", { body: [] }, location), typeParams: tparams || [], visibility: visibility ?? "public", extern: true, externModule: source ?? null, location: node.location }, location);
    }

FromClause
  = _ "from" _ source:String { return source.value; }

ReturnType
  = "->" _ type:TypeName { return type; }

TypeArgs
  = "<" _ head:TypeName tail:(_ "," _ TypeName)* _ ">" { return [head].concat(tail.map(t => t[3])); }

TypeParams
  = "<" _ head:TypeParam tail:(_ "," _ TypeParam)* _ ">" { return [head].concat(tail.map(t => t[3])); }

TypeParam
  = name:IdName _ ":" _ bound:TypeBounds { return { name: name.name, bound }; }
  / name:IdName { return { name: name.name }; }

TypeBounds
  = head:TypeName tail:(_ "&" _ TypeName)* { return [head].concat(tail.map(t => t[3])); }

EnumVariantList
  = head:EnumVariant tail:(_ "," _ EnumVariant)* _ ","? { return [head].concat(tail.map(t => t[3])); }

EnumVariant
  = node:IdName _ params:EnumVariantParams? { return { name: node.name, params: params || [], location: node.location }; }

EnumVariantParams
  = "(" _ head:TypeName tail:(_ "," _ TypeName)* _ ")" { return [head].concat(tail.map(t => t[3])); }

AdtVariantList
  = head:AdtVariant tail:(_ "|" _ AdtVariant)* { return [head].concat(tail.map(t => t[3])); }

AdtVariant
  = node:IdName _ params:EnumVariantParams? { return { name: node.name, params: params || [], location: node.location }; }

ParamList
  = head:Param tail:(_ "," _ Param)* { return [head].concat(tail.map(t => t[3])); }

Param
  = leading:ParamRef? node:IdName _ typeAnn:(_ ":" _ trailing:ParamRef? typeName:TypeName {
      return { typeName, ref: !!trailing, refMut: !!(trailing && trailing.mut) };
    })? {
      const refFlag = !!leading || !!(typeAnn && typeAnn.ref);
      const refMut = !!(leading && leading.mut) || !!(typeAnn && typeAnn.refMut);
      return { name: node.name, typeName: typeAnn ? typeAnn.typeName : null, ref: refFlag, refMut, location: node.location };
    }

ParamRef
  = "ref" __ mut:("mut" __)? { return { mut: !!mut }; }

Block
  = "{" _ statements:StatementList _ "}" { return createNode("Block", { body: statements }, location); }

LetStmt
  = "let" _ mut:("mut" __)? node:IdName _ typeAnn:(_ ":" _ typeName:TypeName { return typeName; })? _ "=" _ value:Expr _ ";"? {
      return createNode("Let", { name: node.name, typeName: typeAnn || null, value, mutable: !!mut, location: node.location }, location);
    }

ReturnStmt
  = "return" _ value:Expr _ ";"? { return createNode("Return", { value }, location); }

MatchStmt
  = "match" _ value:Expr _ "{" _ arms:MatchArmList? _ "}" {
      return createNode("MatchStmt", { value, arms: arms || [] }, location);
    }

WhileStmt
  = "while" _ "(" _ condition:Expr _ ")" _ body:Block {
      return createNode("While", { condition, body }, location);
    }

AssignStmt
  = target:(Member / Identifier) _ "=" _ value:Expr _ ";"? { return createNode("Assign", { target, value }, location); }

IfStmt
  = "if" _ "(" _ condition:Expr _ ")" _ thenBlock:Block _ elsePart:(_ "else" _ elseBlock:Block)? {
      return createNode("If", { condition, thenBlock, elseBlock: elsePart ? elsePart[3] : null }, location);
    }

ExprStmt
  = expr:Expr _ ";"? { return createNode("ExprStmt", { expr }, location); }

Expr
  = LogicOr

LogicOr
  = head:LogicAnd tail:(_ "||" _ LogicAnd)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

LogicAnd
  = head:Pipe tail:(_ "&&" _ Pipe)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

Pipe
  = head:Equality tail:(_ "|>" _ PipeTarget)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: "|>", left: acc, right: t[3] }, location), head);
    }

PipeTarget
  = callee:IdName _ "(" _ args:ArgList? _ ")" {
      return createNode("Call", { callee: createNode("Identifier", { name: callee.name, location: callee.location }, location), args: args || [], typeArgs: [] }, location);
    }
  / callee:IdName {
      return createNode("Call", { callee: createNode("Identifier", { name: callee.name, location: callee.location }, location), args: [], typeArgs: [] }, location);
    }

Equality
  = head:IsExpr tail:(_ ("==" / "!=") _ IsExpr)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

IsExpr
  = head:Relational _ "is" _ qual:QualifiedVariant {
      return createNode("IsExpr", { value: head, variant: qual.variant, enumName: qual.enumName }, location);
    }
  / Relational

Relational
  = head:Add tail:(_ ("<=" / ">=" / "<" / ">") _ Add)* {
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3] }, location), head);
    }

Add
  = head:Mul tail:(_ ("+" / "-") _ Mul)* {
      const loc = location();
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3], location: loc }, location), head);
    }

Mul
  = head:Primary tail:(_ ("*" / "/") _ Primary)* {
      const loc = location();
      return tail.reduce((acc, t) => createNode("Binary", { op: t[1], left: acc, right: t[3], location: loc }, location), head);
    }

Primary
  = AwaitExpr
  / PrimaryNoAwait

PrimaryNoAwait
  = MatchExpr
  / StructLiteral
  / MoveExpr
  / QualifiedCall
  / Call
  / Member
  / Number
  / String
  / Boolean
  / "(" _ expr:Expr _ ")" { return expr; }

StructLiteral
  = name:IdName _ targs:TypeArgs? &(_ "{") _ "{" _ fields:StructLiteralFieldList? _ "}" {
      return createNode("StructLiteral", { name: name.name, typeArgs: targs || [], fields: fields || [], location: location() }, location);
    }

StructLiteralFieldList
  = head:StructLiteralField tail:(_ "," _ StructLiteralField)* _ ","? { return [head].concat(tail.map(t => t[3])); }

StructLiteralField
  = field:IdName _ ":" _ value:Expr { return { name: field.name, value, location: field.location }; }

Keyword
  = ("fn" / "async" / "await" / "struct" / "enum" / "type" / "extern" / "import" / "pub" / "let" / "mut" / "ref" / "move"
    / "if" / "else" / "while" / "match" / "return" / "for" / "in" / "true" / "false" / "from" / "as" / "is") ![a-zA-Z0-9_]

IdName
  = !Keyword name:$([a-zA-Z_][a-zA-Z0-9_]*) { return { name, location: location() }; }

Identifier
  = node:IdName { return createNode("Identifier", { name: node.name, location: node.location }, location); }

Number
  = "0x" digits:$([0-9a-fA-F] [0-9a-fA-F_]*) {
      const cleaned = digits.replace(/_/g, "");
      return createNode("Number", { value: parseInt(cleaned, 16) }, location);
    }
  / "0b" digits:$([01] [01_]*) {
      const cleaned = digits.replace(/_/g, "");
      return createNode("Number", { value: parseInt(cleaned, 2) }, location);
    }
  / digits:$([0-9] [0-9_]*) {
      const cleaned = digits.replace(/_/g, "");
      return createNode("Number", { value: parseInt(cleaned, 10) }, location);
    }

Boolean
  = "true" { return createNode("Boolean", { value: true }, location); }
  / "false" { return createNode("Boolean", { value: false }, location); }

String
  = "\"" chars:DoubleStringCharacter* "\"" {
      return createNode("String", { value: chars.join("") }, location);
    }

DoubleStringCharacter
  = !("\"" / "\\") char:. { return char; }
  / "\\" seq:EscapeSequence { return seq; }

EscapeSequence
  = "\"" { return "\""; }
  / "\\" { return "\\"; }
  / "n" { return "\n"; }
  / "r" { return "\r"; }
  / "t" { return "\t"; }
  / "0" { return "\0"; }
  / "u" hex:$([0-9a-fA-F]{4}) { return String.fromCharCode(parseInt(hex, 16)); }

_ = (WS / Comment)*
__ = (WS / Comment)+
WS = [ \t\r\n]+
Comment = "//" [^\n]* "\n"?
  / "/*" (!"*/" .)* "*/"

MatchArmList
  = head:MatchArm tail:(_ "," _ MatchArm)* _ ","? { return [head].concat(tail.map(t => t[3])); }

MatchArm
  = pattern:MatchPattern _ "=>" _ body:Block _ ";"? { return { pattern, body, location: location() }; }

MatchPattern
  = "_" { return createNode("WildcardPattern", {}, location); }
  / qual:QualifiedVariant _ binds:MatchBindingList? { return createNode("EnumPattern", { variant: qual.variant, enumName: qual.enumName, bindings: binds || [], location: qual.location }, location); }

QualifiedVariant
  = enumName:IdName _ "." _ variant:IdName { return { enumName: enumName.name, variant: variant.name, location: enumName.location }; }
  / variant:IdName { return { enumName: null, variant: variant.name, location: variant.location }; }

MatchBindingList
  = "(" _ head:MatchBinding tail:(_ "," _ MatchBinding)* _ ")" { return [head].concat(tail.map(t => t[3])); }

MatchBinding
  = name:IdName { return name.name; }
  / "_" { return "_"; }

MatchExpr
  = "match" _ value:Expr _ "{" _ arms:MatchExprArmList? _ "}" {
      return createNode("MatchExpr", { value, arms: arms || [] }, location);
    }

MatchExprArmList
  = head:MatchExprArm tail:(_ "," _ MatchExprArm)* _ ","? { return [head].concat(tail.map(t => t[3])); }

MatchExprArm
  = pattern:MatchPattern _ "=>" _ body:Expr { return { pattern, body, location: location() }; }

Member
  = base:Identifier tail:(_ "." _ IdName)* {
      return tail.reduce((acc, t) => createNode("Member", { object: acc, property: t[3].name }, location), base);
    }
Call
  = callee:IdName _ targs:TypeArgs? _ "(" _ args:ArgList? _ ")" {
      return createNode("Call", { callee: createNode("Identifier", { name: callee.name, location: callee.location }, location), args: args || [], typeArgs: targs || [] }, location);
    }

QualifiedCall
  = enumName:IdName _ "." _ variant:IdName _ targs:TypeArgs? _ "(" _ args:ArgList? _ ")" {
      return createNode("Call", {
        callee: createNode("Identifier", { name: variant.name, location: variant.location }, location),
        args: args || [],
        typeArgs: targs || [],
        enumName: enumName.name
      }, location);
    }


ArgList
  = head:Expr tail:(_ "," _ Expr)* { return [head].concat(tail.map(t => t[3])); }
Visibility
  = "pub" { return "public"; }
MoveExpr
  = "move" __ target:(Member / Identifier) {
      return createNode("Move", { target }, location);
    }

AwaitExpr
  = "await" __ value:PrimaryNoAwait {
      return createNode("Await", { value }, location);
    }
