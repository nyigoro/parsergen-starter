Start
  = _ statements:StatementList _ { return { type: "Program", body: statements, location: location() }; }

StatementList
  = head:RecoverableStatement tail:(_ RecoverableStatement)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

RecoverableStatement
  = stmt:Statement { return stmt; }
  / error:InvalidStatement { return error; }

InvalidStatement
  = tokens:(!(";" / "}") .)+ (";" / &"}" / !.) {
      return {
        type: "ErrorNode",
        message: "Invalid syntax",
        location: location()
      };
    }

Statement
  = Import
  / StructDecl
  / EnumDecl
  / TypeDecl
  / ExternTypeDecl
  / FnDecl
  / ExternFnDecl
  / LetStmt
  / AssignStmt
  / IfStmt
  / WhileStmt
  / ReturnStmt
  / MatchStmt
  / ExprStmt
  / Block

Import
  = "import" _ spec:ImportSpec _ "from" _ source:String _ ";"? {
      return { type: "Import", spec, source, location: location() };
    }

ImportSpec
  = "{" _ list:ImportList _ "}" { return list; }
  / Identifier

ImportList
  = head:Identifier tail:(_ "," _ Identifier)* { return [head].concat(tail.map(t => t[3])); }

TypeDecl
  = visibility:Visibility? _ "type" _ node:IdName _ tparams:TypeParams? _ "=" _ body:TypeBody _ ";"? {
      return { type: "TypeDecl", name: node.name, body, typeParams: tparams || [], visibility: visibility ?? "private", extern: false, location: node.location };
    }

StructDecl
  = visibility:Visibility? _ "struct" _ node:IdName _ tparams:TypeParams? _ "{" _ fields:TypeFieldList? _ "}" _ ";"? {
      return { type: "StructDecl", name: node.name, body: fields || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location };
    }

EnumDecl
  = visibility:Visibility? _ "enum" _ node:IdName _ tparams:TypeParams? _ "{" _ variants:EnumVariantList? _ "}" _ ";"? {
      return { type: "EnumDecl", name: node.name, variants: variants || [], typeParams: tparams || [], visibility: visibility ?? "private", location: node.location };
    }

ExternTypeDecl
  = visibility:Visibility? _ "extern" _ "type" _ node:IdName _ tparams:TypeParams? _ source:FromClause? _ ";"? {
      return { type: "TypeDecl", name: node.name, body: [], typeParams: tparams || [], visibility: visibility ?? "public", extern: true, externModule: source ?? null, location: node.location };
    }

TypeBody
  = "{" _ fields:TypeFieldList? _ "}" { return fields || []; }

TypeFieldList
  = head:TypeField tail:(_ "," _ TypeField)* { return [head].concat(tail.map(t => t[3])); }

TypeField
  = node:IdName _ ":" _ typeName:TypeName { return { name: node.name, typeName, location: node.location }; }

TypeName
  = base:IdName _ args:TypeArgs? {
      return args ? `${base.name}<${args.join(",")}>` : base.name;
    }

FnDecl
  = visibility:Visibility? _ "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ body:Block {
      return { type: "FnDecl", name: node.name, params: params || [], returnType: ret || null, body, typeParams: tparams || [], visibility: visibility ?? "private", extern: false, location: node.location };
    }

ExternFnDecl
  = visibility:Visibility? _ "extern" _ "fn" _ node:IdName _ tparams:TypeParams? _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ source:FromClause? _ ";"? {
      return { type: "FnDecl", name: node.name, params: params || [], returnType: ret || "any", body: { type: "Block", body: [] }, typeParams: tparams || [], visibility: visibility ?? "public", extern: true, externModule: source ?? null, location: node.location };
    }

FromClause
  = _ "from" _ source:String { return source.value; }

ReturnType
  = "->" _ type:TypeName { return type; }

TypeArgs
  = "<" _ head:TypeName tail:(_ "," _ TypeName)* _ ">" { return [head].concat(tail.map(t => t[3])); }

TypeParams
  = "<" _ head:TypeParam tail:(_ "," _ TypeParam)* _ ">" { return [head].concat(tail.map(t => t[3])); }

TypeParam
  = name:IdName _ ":" _ bound:TypeBounds { return { name: name.name, bound }; }
  / name:IdName { return { name: name.name }; }

TypeBounds
  = head:TypeName tail:(_ "&" _ TypeName)* { return [head].concat(tail.map(t => t[3])); }

EnumVariantList
  = head:EnumVariant tail:(_ "," _ EnumVariant)* _ ","? { return [head].concat(tail.map(t => t[3])); }

EnumVariant
  = node:IdName _ params:EnumVariantParams? { return { name: node.name, params: params || [], location: node.location }; }

EnumVariantParams
  = "(" _ head:TypeName tail:(_ "," _ TypeName)* _ ")" { return [head].concat(tail.map(t => t[3])); }

ParamList
  = head:Param tail:(_ "," _ Param)* { return [head].concat(tail.map(t => t[3])); }

Param
  = node:IdName _ ":" _ typeName:TypeName { return { name: node.name, typeName, location: node.location }; }

Block
  = "{" _ statements:StatementList _ "}" { return { type: "Block", body: statements, location: location() }; }

LetStmt
  = "let" _ mut:("mut" __)? node:IdName _ typeAnn:(_ ":" _ typeName:TypeName { return typeName; })? _ "=" _ value:Expr _ ";"? {
      return { type: "Let", name: node.name, typeName: typeAnn || null, value, mutable: !!mut, location: node.location };
    }

ReturnStmt
  = "return" _ value:Expr _ ";"? { return { type: "Return", value, location: location() }; }

MatchStmt
  = "match" _ value:Expr _ "{" _ arms:MatchArmList? _ "}" {
      return { type: "MatchStmt", value, arms: arms || [], location: location() };
    }

WhileStmt
  = "while" _ "(" _ condition:Expr _ ")" _ body:Block {
      return { type: "While", condition, body, location: location() };
    }

AssignStmt
  = target:Identifier _ "=" _ value:Expr _ ";"? { return { type: "Assign", target, value, location: location() }; }

IfStmt
  = "if" _ "(" _ condition:Expr _ ")" _ thenBlock:Block _ elsePart:(_ "else" _ elseBlock:Block)? {
      return { type: "If", condition, thenBlock, elseBlock: elsePart ? elsePart[3] : null, location: location() };
    }

ExprStmt
  = expr:Expr _ ";"? { return { type: "ExprStmt", expr, location: location() }; }

Expr
  = LogicOr

LogicOr
  = head:LogicAnd tail:(_ "||" _ LogicAnd)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

LogicAnd
  = head:Equality tail:(_ "&&" _ Equality)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

Equality
  = head:Relational tail:(_ ("==" / "!=") _ Relational)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

Relational
  = head:Add tail:(_ ("<=" / ">=" / "<" / ">") _ Add)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

Add
  = head:Mul tail:(_ ("+" / "-") _ Mul)* {
      const loc = location();
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: loc }), head);
    }

Mul
  = head:Primary tail:(_ ("*" / "/") _ Primary)* {
      const loc = location();
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: loc }), head);
    }

Primary
  = MatchExpr
  / Call
  / Member
  / Number
  / String
  / Boolean
  / Identifier
  / "(" _ expr:Expr _ ")" { return expr; }

IdName
  = name:$([a-zA-Z_][a-zA-Z0-9_]*) { return { name, location: location() }; }

Identifier
  = node:IdName { return { type: "Identifier", name: node.name, location: node.location }; }

Number
  = "0x" digits:$([0-9a-fA-F] [0-9a-fA-F_]*) {
      const cleaned = digits.replace(/_/g, "");
      return { type: "Number", value: parseInt(cleaned, 16), location: location() };
    }
  / "0b" digits:$([01] [01_]*) {
      const cleaned = digits.replace(/_/g, "");
      return { type: "Number", value: parseInt(cleaned, 2), location: location() };
    }
  / digits:$([0-9] [0-9_]*) {
      const cleaned = digits.replace(/_/g, "");
      return { type: "Number", value: parseInt(cleaned, 10), location: location() };
    }

Boolean
  = "true" { return { type: "Boolean", value: true, location: location() }; }
  / "false" { return { type: "Boolean", value: false, location: location() }; }

String
  = "\"" chars:Char* "\"" { return { type: "String", value: chars.join(""), location: location() }; }

Char
  = "\\\\" c:. { return c; }
  / !'"' .

_ = (WS / Comment)*
__ = (WS / Comment)+
WS = [ \t\r\n]+
Comment = "//" [^\n]* "\n"?
  / "/*" (!"*/" .)* "*/"

MatchArmList
  = head:MatchArm tail:(_ "," _ MatchArm)* _ ","? { return [head].concat(tail.map(t => t[3])); }

MatchArm
  = pattern:MatchPattern _ "=>" _ body:Block { return { pattern, body, location: location() }; }

MatchPattern
  = "_" { return { type: "WildcardPattern", location: location() }; }
  / node:IdName _ binds:MatchBindingList? { return { type: "EnumPattern", variant: node.name, bindings: binds || [], location: node.location }; }

MatchBindingList
  = "(" _ head:MatchBinding tail:(_ "," _ MatchBinding)* _ ")" { return [head].concat(tail.map(t => t[3])); }

MatchBinding
  = name:IdName { return name.name; }
  / "_" { return "_"; }

MatchExpr
  = "match" _ value:Expr _ "{" _ arms:MatchExprArmList? _ "}" {
      return { type: "MatchExpr", value, arms: arms || [], location: location() };
    }

MatchExprArmList
  = head:MatchExprArm tail:(_ "," _ MatchExprArm)* _ ","? { return [head].concat(tail.map(t => t[3])); }

MatchExprArm
  = pattern:MatchPattern _ "=>" _ body:Expr { return { pattern, body, location: location() }; }

Member
  = base:Identifier tail:(_ "." _ IdName)+ {
      return tail.reduce((acc, t) => ({ type: "Member", object: acc, property: t[3].name, location: location() }), base);
    }
Call
  = callee:IdName _ targs:TypeArgs? _ "(" _ args:ArgList? _ ")" {
      return { type: "Call", callee: { type: "Identifier", name: callee.name, location: callee.location }, args: args || [], typeArgs: targs || [], location: location() };
    }

ArgList
  = head:Expr tail:(_ "," _ Expr)* { return [head].concat(tail.map(t => t[3])); }
Visibility
  = "pub" { return "public"; }
