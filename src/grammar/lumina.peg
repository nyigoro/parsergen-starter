Start
  = _ statements:StatementList _ { return { type: "Program", body: statements, location: location() }; }

StatementList
  = head:Statement tail:(__ Statement)* { return [head].concat(tail.map(t => t[1])); }
  / "" { return []; }

Statement
  = Import
  / TypeDecl
  / FnDecl
  / LetStmt
  / AssignStmt
  / IfStmt
  / WhileStmt
  / ReturnStmt
  / ExprStmt
  / Block

Import
  = "import" _ spec:ImportSpec _ "from" _ source:String _ ";"? {
      return { type: "Import", spec, source, location: location() };
    }

ImportSpec
  = "{" _ list:ImportList _ "}" { return list; }
  / Identifier

ImportList
  = head:Identifier tail:(_ "," _ Identifier)* { return [head].concat(tail.map(t => t[3])); }

TypeDecl
  = "type" _ node:IdName _ "=" _ body:TypeBody _ ";"? {
      return { type: "TypeDecl", name: node.name, body, location: node.location };
    }

TypeBody
  = "{" _ fields:TypeFieldList? _ "}" { return fields || []; }

TypeFieldList
  = head:TypeField tail:(_ "," _ TypeField)* { return [head].concat(tail.map(t => t[3])); }

TypeField
  = node:IdName _ ":" _ typeName:TypeName { return { name: node.name, typeName, location: node.location }; }

TypeName
  = node:IdName { return node.name; }

FnDecl
  = "fn" _ node:IdName _ "(" _ params:ParamList? _ ")" _ ret:ReturnType? _ body:Block {
      return { type: "FnDecl", name: node.name, params: params || [], returnType: ret || null, body, location: node.location };
    }

ReturnType
  = "->" _ type:TypeName { return type; }

ParamList
  = head:Param tail:(_ "," _ Param)* { return [head].concat(tail.map(t => t[3])); }

Param
  = node:IdName _ ":" _ typeName:TypeName { return { name: node.name, typeName, location: node.location }; }

Block
  = "{" _ statements:StatementList _ "}" { return { type: "Block", body: statements, location: location() }; }

LetStmt
  = "let" _ node:IdName _ ":" _ typeName:TypeName _ "=" _ value:Expr _ ";"? {
      return { type: "Let", name: node.name, typeName, value, location: node.location };
    }

ReturnStmt
  = "return" _ value:Expr _ ";"? { return { type: "Return", value, location: location() }; }

WhileStmt
  = "while" _ "(" _ condition:Expr _ ")" _ body:Block {
      return { type: "While", condition, body, location: location() };
    }

AssignStmt
  = target:Identifier _ "=" _ value:Expr _ ";"? { return { type: "Assign", target, value, location: location() }; }

IfStmt
  = "if" _ "(" _ condition:Expr _ ")" _ thenBlock:Block _ elsePart:(_ "else" _ elseBlock:Block)? {
      return { type: "If", condition, thenBlock, elseBlock: elsePart ? elsePart[3] : null, location: location() };
    }

ExprStmt
  = expr:Expr _ ";"? { return { type: "ExprStmt", expr, location: location() }; }

Expr
  = LogicOr

LogicOr
  = head:LogicAnd tail:(_ "||" _ LogicAnd)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

LogicAnd
  = head:Equality tail:(_ "&&" _ Equality)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

Equality
  = head:Relational tail:(_ ("==" / "!=") _ Relational)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

Relational
  = head:Add tail:(_ ("<=" / ">=" / "<" / ">") _ Add)* {
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: location() }), head);
    }

Add
  = head:Mul tail:(_ ("+" / "-") _ Mul)* {
      const loc = location();
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: loc }), head);
    }

Mul
  = head:Primary tail:(_ ("*" / "/") _ Primary)* {
      const loc = location();
      return tail.reduce((acc, t) => ({ type: "Binary", op: t[1], left: acc, right: t[3], location: loc }), head);
    }

Primary
  = Call
  / Number
  / String
  / Boolean
  / Identifier
  / "(" _ expr:Expr _ ")" { return expr; }

IdName
  = name:$([a-zA-Z_][a-zA-Z0-9_]*) { return { name, location: location() }; }

Identifier
  = node:IdName { return { type: "Identifier", name: node.name, location: node.location }; }

Number
  = digits:$([0-9]+) { return { type: "Number", value: parseInt(digits, 10), location: location() }; }

Boolean
  = "true" { return { type: "Boolean", value: true, location: location() }; }
  / "false" { return { type: "Boolean", value: false, location: location() }; }

String
  = "\"" chars:Char* "\"" { return { type: "String", value: chars.join(""), location: location() }; }

Char
  = "\\\\" c:. { return c; }
  / !'"' .

_ = (WS / Comment)*
__ = (WS / Comment)+
WS = [ \t\r\n]+
Comment = "//" [^\n]* "\n"?
Call
  = callee:Identifier _ "(" _ args:ArgList? _ ")" { return { type: "Call", callee, args: args || [], location: location() }; }

ArgList
  = head:Expr tail:(_ "," _ Expr)* { return [head].concat(tail.map(t => t[3])); }
