import { JList, Token, ParseError, JsonValue, Entry } from "./types.lm"
import { Result } from "../../../std/prelude.lm"
import { lex } from "./lexer.lm"

struct ParseResult {
  value: JsonValue,
  rest: JList<Token>
}

struct MembersResult {
  members: JList<Entry>,
  rest: JList<Token>
}

struct ElementsResult {
  elements: JList<JsonValue>,
  rest: JList<Token>
}

// Main parse entry point
pub fn parse(input: string) -> Result<JsonValue, ParseError> {
  match lex(input) {
    Result.Ok(tokens) => {
      match parse_value(tokens) {
        Result.Ok(res) => {
          match res.rest {
            JList.Cons(tok, _) => {
              if (token_eq(tok, Token.Eof)) {
                return Result.Ok(res.value)
              }
              return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0))
            },
            JList.Nil => { return Result.Ok(res.value) }
          }
        },
        Result.Err(e) => { return Result.Err(e) }
      }
    },
    Result.Err(e) => { return Result.Err(e) }
  }
}

// Parse any JSON value
fn parse_value(tokens: JList<Token>) -> Result<ParseResult, ParseError> {
  match tokens {
    JList.Nil => { return Result.Err(ParseError.UnexpectedEof) },
    JList.Cons(tok, rest) => {
      match tok {
        Token.NullLit => { return Result.Ok(ParseResult { value: JsonValue.Null, rest: rest }) },
        Token.TrueLit => { return Result.Ok(ParseResult { value: JsonValue.Bool(true), rest: rest }) },
        Token.FalseLit => { return Result.Ok(ParseResult { value: JsonValue.Bool(false), rest: rest }) },
        Token.NumberLit(n) => { return Result.Ok(ParseResult { value: JsonValue.Number(n), rest: rest }) },
        Token.StringLit(s) => { return Result.Ok(ParseResult { value: JsonValue.String(s), rest: rest }) },
        Token.LeftBrace => { return parse_object(rest) },
        Token.LeftBracket => { return parse_array(rest) },
        _ => { return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0)) }
      }
    }
  }
}

// Parse object: { "key": value, ... }
fn parse_object(tokens: JList<Token>) -> Result<ParseResult, ParseError> {
  match tokens {
    JList.Nil => { return Result.Err(ParseError.UnexpectedEof) },
    JList.Cons(tok, _) => {
      if (token_eq(tok, Token.RightBrace)) {
        return Result.Ok(ParseResult { value: JsonValue.Object(JList.Nil), rest: tokens })
      }
      match parse_members(tokens, JList.Nil) {
        Result.Ok(members_res) => {
          match expect_token(members_res.rest, Token.RightBrace) {
            Result.Ok(rest) => {
              return Result.Ok(ParseResult {
                value: JsonValue.Object(list_reverse_entries(members_res.members)),
                rest: rest
              })
            },
            Result.Err(e) => { return Result.Err(e) }
          }
        },
        Result.Err(e) => { return Result.Err(e) }
      }
    }
  }
}

// Parse object members
fn parse_members(tokens: JList<Token>, acc: JList<Entry>) -> Result<MembersResult, ParseError> {
  match tokens {
    JList.Cons(tok, rest1) => {
      match tok {
        Token.StringLit(key) => {
          match expect_token(rest1, Token.Colon) {
            Result.Ok(rest2) => {
              match parse_value(rest2) {
                Result.Ok(val_res) => {
                  let entry = Entry { key: key, value: val_res.value }
                  match val_res.rest {
                    JList.Cons(next, rest3) => {
                      if (token_eq(next, Token.Comma)) {
                        return parse_members(rest3, JList.Cons(entry, acc))
                      }
                      return Result.Ok(MembersResult { members: JList.Cons(entry, acc), rest: val_res.rest })
                    },
                    JList.Nil => {
                      return Result.Ok(MembersResult { members: JList.Cons(entry, acc), rest: val_res.rest })
                    }
                  }
                },
                Result.Err(e) => { return Result.Err(e) }
              }
            },
            Result.Err(e) => { return Result.Err(e) }
          }
        },
        _ => { return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0)) }
      }
    },
    JList.Nil => { return Result.Err(ParseError.UnexpectedEof) }
  }
}

// Parse array: [ value, ... ]
fn parse_array(tokens: JList<Token>) -> Result<ParseResult, ParseError> {
  match tokens {
    JList.Nil => { return Result.Err(ParseError.UnexpectedEof) },
    JList.Cons(tok, _) => {
      if (token_eq(tok, Token.RightBracket)) {
        return Result.Ok(ParseResult { value: JsonValue.Array(JList.Nil), rest: tokens })
      }
      match parse_elements(tokens, JList.Nil) {
        Result.Ok(elems_res) => {
          match expect_token(elems_res.rest, Token.RightBracket) {
            Result.Ok(rest) => {
              return Result.Ok(ParseResult {
                value: JsonValue.Array(list_reverse_values(elems_res.elements)),
                rest: rest
              })
            },
            Result.Err(e) => { return Result.Err(e) }
          }
        },
        Result.Err(e) => { return Result.Err(e) }
      }
    }
  }
}

// Parse array elements
fn parse_elements(tokens: JList<Token>, acc: JList<JsonValue>) -> Result<ElementsResult, ParseError> {
  match parse_value(tokens) {
    Result.Ok(val_res) => {
      match val_res.rest {
        JList.Cons(tok, rest) => {
          if (token_eq(tok, Token.Comma)) {
            return parse_elements(rest, JList.Cons(val_res.value, acc))
          }
          return Result.Ok(ElementsResult { elements: JList.Cons(val_res.value, acc), rest: val_res.rest })
        },
        JList.Nil => { return Result.Ok(ElementsResult { elements: JList.Cons(val_res.value, acc), rest: val_res.rest }) }
      }
    },
    Result.Err(e) => { return Result.Err(e) }
  }
}

// Expect a specific token
fn expect_token(tokens: JList<Token>, expected: Token) -> Result<JList<Token>, ParseError> {
  match tokens {
    JList.Nil => { return Result.Err(ParseError.UnexpectedEof) },
    JList.Cons(tok, rest) => {
      if (token_eq(tok, expected)) {
        return Result.Ok(rest)
      }
      return Result.Err(ParseError.UnexpectedToken(token_name(tok), 0))
    }
  }
}

// Token equality check
fn token_eq(a: Token, b: Token) -> bool {
  match a {
    Token.LeftBrace => {
      match b {
        Token.LeftBrace => { return true },
        _ => { return false }
      }
    },
    Token.RightBrace => {
      match b {
        Token.RightBrace => { return true },
        _ => { return false }
      }
    },
    Token.LeftBracket => {
      match b {
        Token.LeftBracket => { return true },
        _ => { return false }
      }
    },
    Token.RightBracket => {
      match b {
        Token.RightBracket => { return true },
        _ => { return false }
      }
    },
    Token.Colon => {
      match b {
        Token.Colon => { return true },
        _ => { return false }
      }
    },
    Token.Comma => {
      match b {
        Token.Comma => { return true },
        _ => { return false }
      }
    },
    Token.Eof => {
      match b {
        Token.Eof => { return true },
        _ => { return false }
      }
    },
    _ => { return false }
  }
}

// Get token name for error messages
fn token_name(tok: Token) -> string {
  match tok {
    Token.LeftBrace => { return "{" },
    Token.RightBrace => { return "}" },
    Token.LeftBracket => { return "[" },
    Token.RightBracket => { return "]" },
    Token.Colon => { return ":" },
    Token.Comma => { return "," },
    Token.StringLit(_) => { return "string" },
    Token.NumberLit(_) => { return "number" },
    Token.TrueLit => { return "true" },
    Token.FalseLit => { return "false" },
    Token.NullLit => { return "null" },
    Token.Eof => { return "EOF" }
  }
}

// List reverse helper
fn list_nil_entries() -> JList<Entry> {
  return JList.Nil
}

fn list_reverse_entries(list: JList<Entry>) -> JList<Entry> {
  return list_reverse_entries_into(list, list_nil_entries())
}

fn list_reverse_entries_into(list: JList<Entry>, acc: JList<Entry>) -> JList<Entry> {
  match list {
    JList.Nil => { return acc },
    JList.Cons(head, tail) => { return list_reverse_entries_into(tail, JList.Cons(head, acc)) }
  }
}

fn list_nil_values() -> JList<JsonValue> {
  return JList.Nil
}

fn list_reverse_values(list: JList<JsonValue>) -> JList<JsonValue> {
  return list_reverse_values_into(list, list_nil_values())
}

fn list_reverse_values_into(list: JList<JsonValue>, acc: JList<JsonValue>) -> JList<JsonValue> {
  match list {
    JList.Nil => { return acc },
    JList.Cons(head, tail) => { return list_reverse_values_into(tail, JList.Cons(head, acc)) }
  }
}
