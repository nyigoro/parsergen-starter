{"version":3,"sources":["../../node_modules/peggy/lib/grammar-location.js","../../node_modules/peggy/lib/grammar-error.js","../../node_modules/peggy/lib/compiler/visitor.js","../../node_modules/peggy/lib/compiler/asts.js","../../node_modules/peggy/lib/compiler/passes/add-imported-rules.js","../../node_modules/peggy/lib/compiler/passes/fix-library-numbers.js","../../node_modules/peggy/lib/compiler/opcodes.js","../../node_modules/peggy/lib/compiler/intern.js","../../node_modules/peggy/lib/compiler/passes/inference-match-result.js","../../node_modules/peggy/lib/compiler/passes/generate-bytecode.js","../../node_modules/source-map-generator/lib/base64.js","../../node_modules/source-map-generator/lib/base64-vlq.js","../../node_modules/source-map-generator/lib/util.js","../../node_modules/source-map-generator/lib/array-set.js","../../node_modules/source-map-generator/lib/mapping-list.js","../../node_modules/source-map-generator/lib/source-map-generator.js","../../node_modules/source-map-generator/lib/source-node.js","../../node_modules/source-map-generator/source-map.js","../../node_modules/peggy/lib/compiler/stack.js","../../node_modules/peggy/lib/version.js","../../node_modules/peggy/lib/compiler/utils.js","../../node_modules/peggy/lib/parser.js","../../node_modules/peggy/lib/compiler/passes/generate-js.js","../../node_modules/peggy/lib/compiler/passes/remove-proxy-rules.js","../../node_modules/peggy/lib/compiler/passes/merge-character-classes.js","../../node_modules/peggy/lib/compiler/passes/remove-unused-rules.js","../../node_modules/peggy/lib/compiler/passes/report-duplicate-imports.js","../../node_modules/peggy/lib/compiler/passes/report-duplicate-labels.js","../../node_modules/peggy/lib/compiler/passes/report-duplicate-rules.js","../../node_modules/peggy/lib/compiler/passes/report-infinite-recursion.js","../../node_modules/peggy/lib/compiler/passes/report-infinite-repetition.js","../../node_modules/peggy/lib/compiler/passes/report-undefined-rules.js","../../node_modules/peggy/lib/compiler/passes/report-incorrect-plucking.js","../../node_modules/peggy/lib/compiler/passes/report-unreachable.js","../../node_modules/peggy/lib/compiler/session.js","../../node_modules/peggy/lib/compiler/index.js","../../node_modules/peggy/lib/peg.js","../../src/bin/cli.ts","../../src/utils/highlight.ts","../../src/utils/format.ts","../../src/grammar/index.ts","../../src/parser/index.ts"],"sourcesContent":["\"use strict\";\n\n/**\n * When used as a grammarSource, allows grammars embedded in larger files to\n * specify their offset.  The start location is the first character in the\n * grammar.  The first line is often moved to the right by some number of\n * columns, but subsequent lines all start at the first column.\n */\nclass GrammarLocation {\n  /**\n   * Create an instance.\n   *\n   * @param {any} source The original grammarSource.  Should be a string or\n   *   have a toString() method.\n   * @param {import(\"./peg\").Location} start The starting offset for the\n   *   grammar in the larger file.\n   */\n  constructor(source, start) {\n    this.source = source;\n    this.start = start;\n  }\n\n  /**\n   * Coerce to a string.\n   *\n   * @returns {string} The source, stringified.\n   */\n  toString() {\n    return String(this.source);\n  }\n\n  /**\n   * Return a new Location offset from the given location by the start of the\n   * grammar.\n   *\n   * @param {import(\"./peg\").Location} loc The location as if the start of the\n   *   grammar was the start of the file.\n   * @returns {import(\"./peg\").Location} The offset location.\n   */\n  offset(loc) {\n    return {\n      line: loc.line + this.start.line - 1,\n      column: (loc.line === 1)\n        ? loc.column + this.start.column - 1\n        : loc.column,\n      offset: loc.offset + this.start.offset,\n    };\n  }\n\n  /**\n   * If the range has a grammarSource that is a GrammarLocation, offset the\n   * start of that range by the GrammarLocation.\n   *\n   * @param {import(\"./peg\").LocationRange} range The range to extract from.\n   * @returns {import(\"./peg\").Location} The offset start if possible, or the\n   *   original start.\n   */\n  static offsetStart(range) {\n    if (range.source && (typeof range.source.offset === \"function\")) {\n      return range.source.offset(range.start);\n    }\n    return range.start;\n  }\n\n  /**\n   * If the range has a grammarSource that is a GrammarLocation, offset the\n   * end of that range by the GrammarLocation.\n   *\n   * @param {import(\"./peg\").LocationRange} range The range to extract from.\n   * @returns {import(\"./peg\").Location} The offset end if possible, or the\n   *   original end.\n   */\n  static offsetEnd(range) {\n    if (range.source && (typeof range.source.offset === \"function\")) {\n      return range.source.offset(range.end);\n    }\n    return range.end;\n  }\n}\n\nmodule.exports = GrammarLocation;\n","// @ts-check\n\"use strict\";\n\nconst GrammarLocation = require(\"./grammar-location\");\n\n// Thrown when the grammar contains an error.\n/** @type {import(\"./peg\").GrammarError} */\nclass GrammarError extends SyntaxError {\n  /**\n   *\n   * @param {string} message\n   * @param {PEG.LocationRange} [location]\n   * @param {PEG.DiagnosticNote[]} [diagnostics]\n   */\n  constructor(message, location, diagnostics) {\n    super(message);\n    this.name = \"GrammarError\";\n    this.location = location;\n    if (diagnostics === undefined) {\n      diagnostics = [];\n    }\n    this.diagnostics = diagnostics;\n    // All problems if this error is thrown by the plugin and not at stage\n    // checking phase\n    this.stage = null;\n    this.problems = [\n      /** @type {PEG.Problem} */\n      ([\"error\", message, location, diagnostics]),\n    ];\n  }\n\n  toString() {\n    let str = super.toString();\n    if (this.location) {\n      str += \"\\n at \";\n      if ((this.location.source !== undefined)\n          && (this.location.source !== null)) {\n        str += `${this.location.source}:`;\n      }\n      str += `${this.location.start.line}:${this.location.start.column}`;\n    }\n    for (const diag of this.diagnostics) {\n      str += \"\\n from \";\n      if ((diag.location.source !== undefined)\n          && (diag.location.source !== null)) {\n        str += `${diag.location.source}:`;\n      }\n      str += `${diag.location.start.line}:${diag.location.start.column}: ${diag.message}`;\n    }\n\n    return str;\n  }\n\n  /**\n   * Format the error with associated sources.  The `location.source` should have\n   * a `toString()` representation in order the result to look nice. If source\n   * is `null` or `undefined`, it is skipped from the output\n   *\n   * Sample output:\n   * ```\n   * Error: Label \"head\" is already defined\n   *  --> examples/arithmetics.pegjs:15:17\n   *    |\n   * 15 |   = head:Factor head:(_ (\"*\" / \"/\") _ Factor)* {\n   *    |                 ^^^^\n   * note: Original label location\n   *  --> examples/arithmetics.pegjs:15:5\n   *    |\n   * 15 |   = head:Factor head:(_ (\"*\" / \"/\") _ Factor)* {\n   *    |     ^^^^\n   * ```\n   *\n   * @param {import(\"./peg\").SourceText[]} sources mapping from location source to source text\n   *\n   * @returns {string} the formatted error\n   */\n  format(sources) {\n    const srcLines = sources.map(({ source, text }) => ({\n      source,\n      text: (text !== null && text !== undefined)\n        ? String(text).split(/\\r\\n|\\n|\\r/g)\n        : [],\n    }));\n\n    /**\n     * Returns a highlighted piece of source to which the `location` points\n     *\n     * @param {import(\"./peg\").LocationRange} location\n     * @param {number} indent How much width in symbols line number strip should have\n     * @param {string} message Additional message that will be shown after location\n     * @returns {string}\n     */\n    function entry(location, indent, message = \"\") {\n      let str = \"\";\n      const src = srcLines.find(({ source }) => source === location.source);\n      const s = location.start;\n      const offset_s = GrammarLocation.offsetStart(location);\n      if (src) {\n        const e = location.end;\n        const line = src.text[s.line - 1];\n        const last = s.line === e.line ? e.column : line.length + 1;\n        const hatLen = (last - s.column) || 1;\n        if (message) {\n          str += `\\nnote: ${message}`;\n        }\n        str += `\n --> ${location.source}:${offset_s.line}:${offset_s.column}\n${\"\".padEnd(indent)} |\n${offset_s.line.toString().padStart(indent)} | ${line}\n${\"\".padEnd(indent)} | ${\"\".padEnd(s.column - 1)}${\"\".padEnd(hatLen, \"^\")}`;\n      } else {\n        str += `\\n at ${location.source}:${offset_s.line}:${offset_s.column}`;\n        if (message) {\n          str += `: ${message}`;\n        }\n      }\n\n      return str;\n    }\n\n    /**\n     * Returns a formatted representation of the one problem in the error.\n     *\n     * @param {import(\"./peg\").Severity} severity Importance of the message\n     * @param {string} message Test message of the problem\n     * @param {import(\"./peg\").LocationRange} [location] Location of the problem in the source\n     * @param {import(\"./peg\").DiagnosticNote[]} [diagnostics] Additional notes about the problem\n     * @returns {string}\n     */\n    function formatProblem(severity, message, location, diagnostics = []) {\n      // Calculate maximum width of all lines\n      // eslint-disable-next-line no-useless-assignment\n      let maxLine = -Infinity;\n      if (location) {\n        maxLine = diagnostics.reduce(\n          (t, { location }) => Math.max(\n            t, GrammarLocation.offsetStart(location).line\n          ),\n          location.start.line\n        );\n      } else {\n        maxLine = Math.max.apply(\n          null,\n          diagnostics.map(d => d.location.start.line)\n        );\n      }\n      maxLine = maxLine.toString().length;\n\n      let str = `${severity}: ${message}`;\n      if (location) {\n        str += entry(location, maxLine);\n      }\n      for (const diag of diagnostics) {\n        str += entry(diag.location, maxLine, diag.message);\n      }\n\n      return str;\n    }\n\n    // \"info\" problems are only appropriate if in verbose mode.\n    // Handle them separately.\n    return this.problems\n      .filter(p => p[0] !== \"info\")\n      .map(p => formatProblem(...p)).join(\"\\n\\n\");\n  }\n}\n\nmodule.exports = GrammarError;\n","\"use strict\";\n\n// Simple AST node visitor builder.\nconst visitor = {\n  build(functions) {\n    function visit(node, ...args) {\n      return functions[node.type](node, ...args);\n    }\n\n    function visitNop() {\n      // Do nothing.\n    }\n\n    function visitExpression(node, ...args) {\n      return visit(node.expression, ...args);\n    }\n\n    function visitChildren(property) {\n      return function(node, ...args) {\n        // We do not use .map() here, because if you need the result\n        // of applying visitor to children you probable also need to\n        // process it in some way, therefore you anyway have to override\n        // this method. If you do not needed that, we do not waste time\n        // and memory for creating the output array\n        node[property].forEach(child => visit(child, ...args));\n      };\n    }\n\n    const DEFAULT_FUNCTIONS = {\n      grammar(node, ...args) {\n        for (const imp of node.imports) {\n          visit(imp, ...args);\n        }\n\n        if (node.topLevelInitializer) {\n          if (Array.isArray(node.topLevelInitializer)) {\n            for (const tli of node.topLevelInitializer) {\n              visit(tli, ...args);\n            }\n          } else {\n            visit(node.topLevelInitializer, ...args);\n          }\n        }\n\n        if (node.initializer) {\n          if (Array.isArray(node.initializer)) {\n            for (const init of node.initializer) {\n              visit(init, ...args);\n            }\n          } else {\n            visit(node.initializer, ...args);\n          }\n        }\n\n        node.rules.forEach(rule => visit(rule, ...args));\n      },\n\n      grammar_import: visitNop,\n      top_level_initializer: visitNop,\n      initializer: visitNop,\n      rule: visitExpression,\n      named: visitExpression,\n      choice: visitChildren(\"alternatives\"),\n      action: visitExpression,\n      sequence: visitChildren(\"elements\"),\n      labeled: visitExpression,\n      text: visitExpression,\n      simple_and: visitExpression,\n      simple_not: visitExpression,\n      optional: visitExpression,\n      zero_or_more: visitExpression,\n      one_or_more: visitExpression,\n      repeated(node, ...args) {\n        if (node.delimiter) {\n          visit(node.delimiter, ...args);\n        }\n\n        return visit(node.expression, ...args);\n      },\n      group: visitExpression,\n      semantic_and: visitNop,\n      semantic_not: visitNop,\n      rule_ref: visitNop,\n      library_ref: visitNop,\n      literal: visitNop,\n      class: visitNop,\n      any: visitNop,\n    };\n\n    Object.keys(DEFAULT_FUNCTIONS).forEach(type => {\n      if (!Object.prototype.hasOwnProperty.call(functions, type)) {\n        functions[type] = DEFAULT_FUNCTIONS[type];\n      }\n    });\n\n    return visit;\n  },\n};\n\nmodule.exports = visitor;\n","\"use strict\";\n\nconst visitor = require(\"./visitor\");\n\n/**\n * Combine two things, each of which might be an array, into a single value,\n * in the order [...a, ...b].\n *\n * @template T\n * @param {T | T[]} a\n * @param {T | T[]} b\n * @returns {T | T[]}\n */\nfunction combinePossibleArrays(a, b) {\n  // First might be an array, second will not.  Either might be null.\n  if (!(a && b)) {\n    return a || b;\n  }\n  const aa = Array.isArray(a) ? a : [a];\n  aa.push(b);\n  return aa;\n}\n\n// AST utilities.\nconst asts = {\n  /**\n   * Find the rule with the given name, if it exists.\n   *\n   * @param {PEG.ast.Grammar} ast\n   * @param {string} name\n   * @returns {PEG.ast.Rule | undefined}\n   */\n  findRule(ast, name) {\n    for (let i = 0; i < ast.rules.length; i++) {\n      if (ast.rules[i].name === name) {\n        return ast.rules[i];\n      }\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Find the index of the rule with the given name, if it exists.\n   * Otherwise returns -1.\n   *\n   * @param {PEG.ast.Grammar} ast\n   * @param {string} name\n   * @returns {number}\n   */\n  indexOfRule(ast, name) {\n    for (let i = 0; i < ast.rules.length; i++) {\n      if (ast.rules[i].name === name) {\n        return i;\n      }\n    }\n\n    // istanbul ignore next Presence of rules checked using another approach that not involve this function\n    // Any time when it is called the rules always exist\n    return -1;\n  },\n\n  alwaysConsumesOnSuccess(ast, node) {\n    function consumesTrue()  { return true;  }\n    function consumesFalse() { return false; }\n\n    const consumes = visitor.build({\n      choice(node) {\n        return node.alternatives.every(consumes);\n      },\n\n      sequence(node) {\n        return node.elements.some(consumes);\n      },\n\n      simple_and: consumesFalse,\n      simple_not: consumesFalse,\n      optional: consumesFalse,\n      zero_or_more: consumesFalse,\n      repeated(node) {\n        // If minimum is `null` it is equals to maximum (parsed from `|exact|` syntax)\n        const min = node.min ? node.min : node.max;\n\n        // If the low boundary is variable then it can be zero.\n        // Expression, repeated zero times, does not consume any input\n        // but always matched - so it does not always consumes on success\n        if (min.type !== \"constant\" || min.value === 0) {\n          return false;\n        }\n        if (consumes(node.expression)) {\n          return true;\n        }\n        // |node.delimiter| used only when |node.expression| match at least two times\n        // The first `if` filtered out all non-constant minimums, so at this point\n        // |min.value| is always a constant\n        if (min.value > 1 && node.delimiter && consumes(node.delimiter)) {\n          return true;\n        }\n\n        return false;\n      },\n      semantic_and: consumesFalse,\n      semantic_not: consumesFalse,\n\n      rule_ref(node) {\n        const rule = asts.findRule(ast, node.name);\n\n        // Because we run all checks in one stage, some rules could be missing.\n        // Checking for missing rules could be executed in parallel to this check\n        return rule ? consumes(rule) : undefined;\n      },\n\n      // No way to know for external rules.\n      library_ref: consumesFalse,\n\n      literal(node) {\n        return node.value !== \"\";\n      },\n\n      class: consumesTrue,\n      any: consumesTrue,\n    });\n\n    return consumes(node);\n  },\n\n  combine(asts) {\n    return asts.reduce((combined, ast) => {\n      combined.topLevelInitializer = combinePossibleArrays(\n        combined.topLevelInitializer,\n        ast.topLevelInitializer\n      );\n      combined.initializer = combinePossibleArrays(\n        combined.initializer,\n        ast.initializer\n      );\n      combined.rules = combined.rules.concat(ast.rules);\n      return combined;\n    });\n  },\n};\n\nmodule.exports = asts;\n","// @ts-check\n\"use strict\";\n\n/**\n * Generate trampoline stubs for each rule imported into this namespace.\n *\n * @example\n * import bar from \"./lib.js\" // Default rule imported into this namespace\n * import {baz} from \"./lib.js\" // One rule imported into this namespace by name\n *\n * @type {PEG.Pass}\n */\nfunction addImportedRules(ast) {\n  let libraryNumber = 0;\n  for (const imp of ast.imports) {\n    for (const what of imp.what) {\n      let original = undefined;\n      switch (what.type) {\n        case \"import_binding_all\":\n          // Don't create stub.\n          continue;\n        case \"import_binding_default\":\n          // Use the default (usually first) rule.\n          break;\n        case \"import_binding\":\n          original = what.binding;\n          break;\n        case \"import_binding_rename\":\n          original = what.rename;\n          break;\n        default:\n          throw new TypeError(\"Unknown binding type\");\n      }\n      ast.rules.push({\n        type: \"rule\",\n        name: what.binding,\n        nameLocation: what.location,\n        expression: {\n          type: \"library_ref\",\n          name: original,\n          library: imp.from.module,\n          libraryNumber,\n          location: what.location,\n        },\n        location: imp.from.location,\n      });\n    }\n    libraryNumber++;\n  }\n}\n\nmodule.exports = addImportedRules;\n","// @ts-check\n\"use strict\";\n\nconst visitor = require(\"../visitor\");\n\n/**\n * @param {PEG.ast.Grammar} ast\n * @param {string} name\n * @returns {number}\n */\nfunction findLibraryNumber(ast, name) {\n  let libraryNumber = 0;\n  for (const imp of ast.imports) {\n    for (const what of imp.what) {\n      if ((what.type === \"import_binding_all\") && (what.binding === name)) {\n        return libraryNumber;\n      }\n    }\n    libraryNumber++;\n  }\n\n  return -1;\n}\n\n/** @type {PEG.Pass} */\nfunction fixLibraryNumbers(ast, _options, session) {\n  const check = visitor.build({\n    library_ref(/** @type {PEG.ast.LibraryReference} */ node) {\n      if (node.libraryNumber === -1) {\n        node.libraryNumber = findLibraryNumber(ast, node.library);\n        if (node.libraryNumber === -1) {\n          session.error(\n            `Unknown module \"${node.library}\"`,\n            node.location\n          );\n        }\n      }\n    },\n  });\n  check(ast);\n}\n\nmodule.exports = fixLibraryNumbers;\n","\"use strict\";\n\n// Bytecode instruction opcodes.\nconst opcodes = {\n  // Stack Manipulation\n\n  /** @deprecated Unused */\n  PUSH:              0,    // PUSH c\n  PUSH_EMPTY_STRING: 35,   // PUSH_EMPTY_STRING\n  PUSH_UNDEFINED:    1,    // PUSH_UNDEFINED\n  PUSH_NULL:         2,    // PUSH_NULL\n  PUSH_FAILED:       3,    // PUSH_FAILED\n  PUSH_EMPTY_ARRAY:  4,    // PUSH_EMPTY_ARRAY\n  PUSH_CURR_POS:     5,    // PUSH_CURR_POS\n  POP:               6,    // POP\n  POP_CURR_POS:      7,    // POP_CURR_POS\n  POP_N:             8,    // POP_N n\n  NIP:               9,    // NIP\n  APPEND:            10,   // APPEND\n  WRAP:              11,   // WRAP n\n  TEXT:              12,   // TEXT\n  PLUCK:             36,   // PLUCK n, k, p1, ..., pK\n\n  // Conditions and Loops\n\n  IF:                13,   // IF t, f\n  IF_ERROR:          14,   // IF_ERROR t, f\n  IF_NOT_ERROR:      15,   // IF_NOT_ERROR t, f\n  IF_LT:             30,   // IF_LT min, t, f\n  IF_GE:             31,   // IF_GE max, t, f\n  IF_LT_DYNAMIC:     32,   // IF_LT_DYNAMIC min, t, f\n  IF_GE_DYNAMIC:     33,   // IF_GE_DYNAMIC max, t, f\n  WHILE_NOT_ERROR:   16,   // WHILE_NOT_ERROR b\n\n  // Matching\n\n  MATCH_ANY:        17,    // MATCH_ANY a, f, ...\n  MATCH_STRING:     18,    // MATCH_STRING s, a, f, ...\n  MATCH_STRING_IC:  19,    // MATCH_STRING_IC s, a, f, ...\n  MATCH_CHAR_CLASS: 20,    // MATCH_CHAR_CLASS c, a, f, ...\n  MATCH_UNICODE_CLASS: 42, // MATCH_UNICODE_CLASS c, a, f, ...\n  /** @deprecated Replaced with `MATCH_CHAR_CLASS` */\n  MATCH_REGEXP:     20,    // MATCH_REGEXP r, a, f, ...\n  ACCEPT_N:         21,    // ACCEPT_N n\n  ACCEPT_STRING:    22,    // ACCEPT_STRING s\n  FAIL:             23,    // FAIL e\n\n  // Calls\n\n  LOAD_SAVED_POS:    24,   // LOAD_SAVED_POS p\n  UPDATE_SAVED_POS:  25,   // UPDATE_SAVED_POS\n  CALL:              26,   // CALL f, n, pc, p1, p2, ..., pN\n\n  // Rules\n\n  RULE:              27,   // RULE r\n  LIBRARY_RULE:      41,   // LIBRARY_RULE moduleIndex, whatIndex\n\n  // Failure Reporting\n\n  SILENT_FAILS_ON:   28,   // SILENT_FAILS_ON\n  SILENT_FAILS_OFF:  29,   // SILENT_FAILS_OFF\n\n  // Because the tests have hard-coded opcode numbers, don't renumber\n  // existing opcodes.  New opcodes that have been put in the correct\n  // sections above are repeated here in order to ensure we don't\n  // reuse them.\n  //\n  // IF_LT: 30\n  // IF_GE: 31\n  // IF_LT_DYNAMIC: 32\n  // IF_GE_DYNAMIC: 33\n  // 34 reserved for @mingun\n  // PUSH_EMPTY_STRING: 35\n  // PLUCK: 36\n\n  SOURCE_MAP_PUSH:         37,   // SOURCE_MAP_PUSH loc-index\n  SOURCE_MAP_POP:          38,   // SOURCE_MAP_POP\n  SOURCE_MAP_LABEL_PUSH:   39,   // SOURCE_MAP_LABEL_PUSH sp, literal-index, loc-index\n  SOURCE_MAP_LABEL_POP:    40,   // SOURCE_MAP_LABEL_POP sp\n  // LIBRARY_RULE:         41,\n  // MATCH_UNICODE_CLASS:  42,\n};\n\nmodule.exports = opcodes;\n","// @ts-check\n\"use strict\";\n\n/**\n * Intern strings or objects, so there is only one copy of each, by value.\n * Objects may need to be converted to another representation before storing.\n * Each inputs corresponds to a number, starting with 0.\n *\n * @template [T=string],[V=T]\n */\nclass Intern {\n  /**\n   * @typedef {object} InternOptions\n   * @property {(input: V) => string} [stringify=String] Represent the\n   *   converted input as a string, for value comparison.\n   * @property {(input: T) => V} [convert=(x) => x] Convert the input to its\n   *   stored form.  Required if type V is not the same as type T.  Return\n   *   falsy value to have this input not be added; add() will return -1 in\n   *   this case.\n   */\n\n  /**\n   * @param {InternOptions} [options]\n   */\n  constructor(options) {\n    /** @type {Required<InternOptions>} */\n    this.options = {\n      stringify: String,\n      convert: x => /** @type {V} */ (/** @type {unknown} */ (x)),\n      ...options,\n    };\n    /** @type {V[]} */\n    this.items = [];\n    /** @type {Record<string, number>} */\n    this.offsets = Object.create(null);\n  }\n\n  /**\n   * Intern an item, getting it's asssociated number.  Returns -1 for falsy\n   * inputs. O(1) with constants tied to the convert and stringify options.\n   *\n   * @param {T} input\n   * @return {number}\n   */\n  add(input) {\n    const c = this.options.convert(input);\n    if (!c) {\n      return -1;\n    }\n    const s = this.options.stringify(c);\n    let num = this.offsets[s];\n    if (num === undefined) {\n      num = this.items.push(c) - 1;\n      this.offsets[s] = num;\n    }\n    return num;\n  }\n\n  /**\n   * @param {number} i\n   * @returns {V}\n   */\n  get(i) {\n    return this.items[i];\n  }\n\n  /**\n   * @template U\n   * @param {(value: V, index: number, array: V[]) => U} fn\n   * @returns {U[]}\n   */\n  map(fn) {\n    return this.items.map(fn);\n  }\n}\n\nmodule.exports = Intern;\n","\"use strict\";\n\nconst visitor      = require(\"../visitor\");\nconst asts         = require(\"../asts\");\nconst GrammarError = require(\"../../grammar-error\");\n\nconst ALWAYS_MATCH = 1;\nconst SOMETIMES_MATCH = 0;\nconst NEVER_MATCH = -1;\n\n// Inference match result of the each node. Can be:\n// -1: negative result, matching of that node always fails\n//  0: neutral result, may be fail, may be match\n//  1: positive result, always match\nfunction inferenceMatchResult(ast) {\n  function sometimesMatch(node) { return (node.match = SOMETIMES_MATCH); }\n  function alwaysMatch(node) {\n    // eslint-disable-next-line no-use-before-define -- Mutual recursion\n    inference(node.expression);\n\n    return (node.match = ALWAYS_MATCH);\n  }\n\n  function inferenceExpression(node) {\n    // eslint-disable-next-line no-use-before-define -- Mutual recursion\n    return (node.match = inference(node.expression));\n  }\n  function inferenceElements(elements, forChoice) {\n    const length = elements.length;\n    let always = 0;\n    let never = 0;\n\n    for (let i = 0; i < length; ++i) {\n      // eslint-disable-next-line no-use-before-define -- Mutual recursion\n      const result = inference(elements[i]);\n\n      if (result === ALWAYS_MATCH) { ++always; }\n      if (result === NEVER_MATCH)  { ++never;  }\n    }\n\n    if (always === length) {\n      return ALWAYS_MATCH;\n    }\n    if (forChoice) {\n      return never === length ? NEVER_MATCH : SOMETIMES_MATCH;\n    }\n\n    return never > 0 ? NEVER_MATCH : SOMETIMES_MATCH;\n  }\n\n  const inference = visitor.build({\n    rule(node) {\n      // eslint-disable-next-line init-declarations\n      let oldResult;\n      let count = 0;\n\n      // If property not yet calculated, do that\n      if (typeof node.match === \"undefined\") {\n        node.match = SOMETIMES_MATCH;\n        do {\n          oldResult = node.match;\n          node.match = inference(node.expression);\n          // 6 == 3! -- permutations count for all transitions from one match\n          // state to another.\n          // After 6 iterations the cycle with guarantee begins\n          // For example, an input of `start = [] start` will generate the\n          // sequence: 0 -> -1 -> -1 (then stop)\n          //\n          // A more complex grammar theoretically would generate the\n          // sequence: 0 -> 1 -> 0 -> -1 -> 0 -> 1 -> ... (then cycle)\n          // but there are no examples of such grammars yet (possible, they\n          // do not exist at all)\n\n          // istanbul ignore next  This is canary test, shouldn't trigger in real life\n          if (++count > 6) {\n            throw new GrammarError(\n              \"Infinity cycle detected when trying to evaluate node match result\",\n              node.location\n            );\n          }\n        } while (oldResult !== node.match);\n      }\n\n      return node.match;\n    },\n    named:        inferenceExpression,\n    choice(node) {\n      return (node.match = inferenceElements(node.alternatives, true));\n    },\n    action:       inferenceExpression,\n    sequence(node) {\n      return (node.match = inferenceElements(node.elements, false));\n    },\n    labeled:      inferenceExpression,\n    text:         inferenceExpression,\n    simple_and:   inferenceExpression,\n    simple_not(node) {\n      return (node.match = -inference(node.expression));\n    },\n    optional:     alwaysMatch,\n    zero_or_more: alwaysMatch,\n    one_or_more:  inferenceExpression,\n    repeated(node) {\n      const match = inference(node.expression);\n      const dMatch = node.delimiter ? inference(node.delimiter) : NEVER_MATCH;\n      // If minimum is `null` it is equals to maximum (parsed from `|exact|` syntax)\n      const min = node.min ? node.min : node.max;\n\n      // If any boundary are variable - it can be negative, and it that case\n      // node does not match, but it may be match with some other values\n      if (min.type !== \"constant\" || node.max.type !== \"constant\") {\n        return (node.match = SOMETIMES_MATCH);\n      }\n      // Now both boundaries is constants\n      // If the upper boundary is zero or minimum exceeds maximum,\n      // matching is impossible\n      if (node.max.value === 0\n       || (node.max.value !== null && min.value > node.max.value)\n      ) {\n        return (node.match = NEVER_MATCH);\n      }\n\n      if (match === NEVER_MATCH) {\n        // If an expression always fails, a range will also always fail\n        // (with the one exception - never matched expression repeated\n        //  zero times always match and returns an empty array).\n        return (node.match = min.value === 0 ? ALWAYS_MATCH : NEVER_MATCH);\n      }\n      if (match === ALWAYS_MATCH) {\n        if (node.delimiter && min.value >= 2) {\n          // If an expression always match the final result determined only\n          // by the delimiter, but delimiter used only when count of elements\n          // two and more\n          return (node.match = dMatch);\n        }\n\n        return (node.match = ALWAYS_MATCH);\n      }\n\n      // Here `match === SOMETIMES_MATCH`\n      if (node.delimiter && min.value >= 2) {\n        // If an expression always match the final result determined only\n        // by the delimiter, but delimiter used only when count of elements\n        // two and more\n        return (\n          // If a delimiter never match then the range also never match (because\n          // there at least one delimiter)\n          node.match = dMatch === NEVER_MATCH ? NEVER_MATCH : SOMETIMES_MATCH\n        );\n      }\n\n      return (node.match = min.value === 0 ? ALWAYS_MATCH : SOMETIMES_MATCH);\n    },\n    group:        inferenceExpression,\n    semantic_and: sometimesMatch,\n    semantic_not: sometimesMatch,\n    rule_ref(node) {\n      const rule = asts.findRule(ast, node.name);\n      if (!rule) {\n        return SOMETIMES_MATCH;\n      }\n      return (node.match = inference(rule));\n    },\n    library_ref() {\n      // Can't look into pre-compiled rules.\n      return 0;\n    },\n    literal(node) {\n      // Empty literal always match on any input\n      const match = node.value.length === 0 ? ALWAYS_MATCH : SOMETIMES_MATCH;\n\n      return (node.match = match);\n    },\n    class(node) {\n      // Empty character class never match on any input\n      const match = node.parts.length === 0 ? NEVER_MATCH : SOMETIMES_MATCH;\n\n      return (node.match = match);\n    },\n    // |any| not match on empty input\n    any:          sometimesMatch,\n  });\n\n  inference(ast);\n}\n\ninferenceMatchResult.ALWAYS_MATCH    = ALWAYS_MATCH;\ninferenceMatchResult.SOMETIMES_MATCH = SOMETIMES_MATCH;\ninferenceMatchResult.NEVER_MATCH     = NEVER_MATCH;\n\nmodule.exports = inferenceMatchResult;\n","// @ts-check\n\"use strict\";\n\nconst asts = require(\"../asts\");\nconst op = require(\"../opcodes\");\nconst visitor = require(\"../visitor\");\nconst Intern = require(\"../intern\");\nconst { ALWAYS_MATCH, SOMETIMES_MATCH, NEVER_MATCH } = require(\"./inference-match-result\");\n\n/**\n * @typedef {import(\"../../peg\")} PEG\n */\n\n// Generates bytecode.\n//\n// Instructions\n// ============\n//\n// Stack Manipulation\n// ------------------\n//\n//  [35] PUSH_EMPTY_STRING\n//\n//        stack.push(\"\");\n//\n//  [1] PUSH_UNDEFINED\n//\n//        stack.push(undefined);\n//\n//  [2] PUSH_NULL\n//\n//        stack.push(null);\n//\n//  [3] PUSH_FAILED\n//\n//        stack.push(FAILED);\n//\n//  [4] PUSH_EMPTY_ARRAY\n//\n//        stack.push([]);\n//\n//  [5] PUSH_CURR_POS\n//\n//        stack.push(currPos);\n//\n//  [6] POP\n//\n//        stack.pop();\n//\n//  [7] POP_CURR_POS\n//\n//        currPos = stack.pop();\n//\n//  [8] POP_N n\n//\n//        stack.pop(n);\n//\n//  [9] NIP\n//\n//        value = stack.pop();\n//        stack.pop();\n//        stack.push(value);\n//\n// [10] APPEND\n//\n//        value = stack.pop();\n//        array = stack.pop();\n//        array.push(value);\n//        stack.push(array);\n//\n// [11] WRAP n\n//\n//        stack.push(stack.pop(n));\n//\n// [12] TEXT\n//\n//        stack.push(input.substring(stack.pop(), currPos));\n//\n// [36] PLUCK n, k, p1, ..., pK\n//\n//        value = [stack[p1], ..., stack[pK]]; // when k != 1\n//        -or-\n//        value = stack[p1];                   // when k == 1\n//\n//        stack.pop(n);\n//        stack.push(value);\n//\n// Conditions and Loops\n// --------------------\n//\n// [13] IF t, f\n//\n//        if (stack.top()) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [14] IF_ERROR t, f\n//\n//        if (stack.top() === FAILED) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [15] IF_NOT_ERROR t, f\n//\n//        if (stack.top() !== FAILED) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [30] IF_LT min, t, f\n//\n//        if (stack.top().length < min) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [31] IF_GE max, t, f\n//\n//        if (stack.top().length >= max) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [32] IF_LT_DYNAMIC min, t, f\n//\n//        if (stack.top().length < stack[min]) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [33] IF_GE_DYNAMIC max, t, f\n//\n//        if (stack.top().length >= stack[max]) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [16] WHILE_NOT_ERROR b\n//\n//        while(stack.top() !== FAILED) {\n//          interpret(ip + 2, ip + 2 + b);\n//        }\n//\n// Matching\n// --------\n//\n// [17] MATCH_ANY a, f, ...\n//\n//        if (input.length > currPos) {\n//          interpret(ip + 3, ip + 3 + a);\n//        } else {\n//          interpret(ip + 3 + a, ip + 3 + a + f);\n//        }\n//\n// [18] MATCH_STRING s, a, f, ...\n//\n//        if (input.substr(currPos, literals[s].length) === literals[s]) {\n//          interpret(ip + 4, ip + 4 + a);\n//        } else {\n//          interpret(ip + 4 + a, ip + 4 + a + f);\n//        }\n//\n// [19] MATCH_STRING_IC s, a, f, ...\n//\n//        if (input.substr(currPos, literals[s].length).toLowerCase() === literals[s]) {\n//          interpret(ip + 4, ip + 4 + a);\n//        } else {\n//          interpret(ip + 4 + a, ip + 4 + a + f);\n//        }\n//\n// [20] MATCH_CHAR_CLASS c, a, f, ...\n//\n//        if (classes[c].test(input.charAt(currPos))) {\n//          interpret(ip + 4, ip + 4 + a);\n//        } else {\n//          interpret(ip + 4 + a, ip + 4 + a + f);\n//        }\n//\n// [42] MATCH_UNICODE_CLASS c, a, f, ...\n//\n//        if (classes[c].test(input.unicodeCharAt(currPos))) {\n//          interpret(ip + 4, ip + 4 + a);\n//        } else {\n//          interpret(ip + 4 + a, ip + 4 + a + f);\n//        }\n//\n// [21] ACCEPT_N n\n//\n//        stack.push(input.substring(currPos, n));\n//        currPos += n;\n//\n// [22] ACCEPT_STRING s\n//\n//        stack.push(literals[s]);\n//        currPos += literals[s].length;\n//\n// [23] FAIL e\n//\n//        stack.push(FAILED);\n//        fail(expectations[e]);\n//\n// Calls\n// -----\n//\n// [24] LOAD_SAVED_POS p\n//\n//        savedPos = stack[p];\n//\n// [25] UPDATE_SAVED_POS\n//\n//        savedPos = currPos;\n//\n// [26] CALL f, n, pc, p1, p2, ..., pN\n//\n//        value = functions[f](stack[p1], ..., stack[pN]);\n//        stack.pop(n);\n//        stack.push(value);\n//\n// Rules\n// -----\n//\n// [27] RULE r\n//\n//        stack.push(parseRule(r));\n//\n// [41] LIBRARY_RULE moduleIndex whatIndex\n//\n//        stack.push(callLibrary(module, what));\n//\n// Failure Reporting\n// -----------------\n//\n// [28] SILENT_FAILS_ON\n//\n//        silentFails++;\n//\n// [29] SILENT_FAILS_OFF\n//\n//        silentFails--;\n//\n// Source Mapping\n// --------------\n//\n// [37] SOURCE_MAP_PUSH n\n//\n//        Everything generated from here until the corresponding SOURCE_MAP_POP\n//        will be wrapped in a SourceNode tagged with locations[n].\n//\n// [38] SOURCE_MAP_POP\n//\n//        See above.\n//\n// [39] SOURCE_MAP_LABEL_PUSH sp, label, loc\n//\n//        Mark that the stack location sp will be used to hold the value\n//        of the label named literals[label], with location info locations[loc]\n//\n// [40] SOURCE_MAP_LABEL_POP sp\n//\n//        End the region started by [39]\n//\n// This pass can use the results of other previous passes, each of which can\n// change the AST (and, as consequence, the bytecode).\n//\n// In particular, if the pass |inferenceMatchResult| has been run before this pass,\n// then each AST node will contain a |match| property, which represents a possible\n// match result of the node:\n// - `<0` - node is never matched, for example, `!('a'*)` (negation of the always\n//          matched node). Generator can put |FAILED| to the stack immediately\n// - `=0` - sometimes node matched, sometimes not. This is the same behavior\n//          when |match| is missed\n// - `>0` - node is always matched, for example, `'a'*` (because result is an\n//          empty array, or an array with some elements). The generator does not\n//          need to add a check for |FAILED|, because it is impossible\n//\n// To handle the situation, when the |inferenceMatchResult| has not run (that\n// happens, for example, in tests), the |match| value extracted using the\n// `|0` trick, which performing cast of any value to an integer with value `0`\n// that is equivalent of an unknown match result and signals the generator that\n// runtime check for the |FAILED| is required. Trick is explained on the\n// Wikipedia page (https://en.wikipedia.org/wiki/Asm.js#Code_generation)\n/**\n *\n * @param {PEG.ast.Grammar} ast\n * @param {PEG.ParserOptions} options\n */\nfunction generateBytecode(ast, options) {\n  const literals = new Intern();\n  /** @type Intern<PEG.ast.CharacterClass, PEG.ast.GrammarCharacterClass> */\n  const classes = new Intern({\n    stringify: JSON.stringify,\n    /** @type {(input: PEG.ast.CharacterClass) => PEG.ast.GrammarCharacterClass} */\n    convert: node => ({\n      value: node.parts,\n      inverted: node.inverted,\n      ignoreCase: node.ignoreCase,\n      unicode: node.unicode,\n    }),\n  });\n  /** @type Intern<PEG.ast.GrammarExpectation> */\n  const expectations = new Intern({\n    stringify: JSON.stringify,\n  });\n  /**\n   * @type {Intern<string | undefined, string>}\n   */\n  const importedNames = new Intern();\n  /** @type PEG.ast.FunctionConst[] */\n  const functions = [];\n  /** @type PEG.LocationRange[] */\n  const locations = [];\n\n  /**\n   * @param {boolean} predicate\n   * @param {string[]} params\n   * @param {{code:string; codeLocation: PEG.LocationRange}} node\n   * @returns {number}\n   */\n  function addFunctionConst(predicate, params, node) {\n    const func = {\n      predicate,\n      params,\n      body: node.code,\n      location: node.codeLocation,\n    };\n    const pattern = JSON.stringify(func);\n    const index = functions.findIndex(f => JSON.stringify(f) === pattern);\n\n    return index === -1 ? functions.push(func) - 1 : index;\n  }\n\n  /**\n   * @param {PEG.LocationRange} location\n   * @returns {number}\n   */\n  function addLocation(location) {\n    // Don't bother de-duplicating. There can be a lot of locations,\n    // they will almost never collide, and unlike the \"consts\" above,\n    // it won't affect code generation even if they do.\n    return locations.push(location) - 1;\n  }\n\n  /** @typedef {Record<string, number>} Env */\n  /** @typedef {{ sp: number; env:Env; action:PEG.ast.Action|null; pluck?: number[] }} Context */\n\n  /**\n   * @param {Env} env\n   * @returns {Env}\n   */\n  function cloneEnv(env) {\n    /** @type {Env} */\n    const clone = {};\n\n    Object.keys(env).forEach(name => {\n      clone[name] = env[name];\n    });\n\n    return clone;\n  }\n\n  /**\n   * @param {number[]} first\n   * @param {number[][]} args\n   * @returns {number[]}\n   */\n  function buildSequence(first, ...args) {\n    return first.concat(...args);\n  }\n\n  /**\n   * @param {number} match\n   * @param {number[]} condCode\n   * @param {number[]} thenCode\n   * @param {number[]} elseCode\n   * @returns {number[]}\n   */\n  function buildCondition(match, condCode, thenCode, elseCode) {\n    if (match === ALWAYS_MATCH) { return thenCode; }\n    if (match === NEVER_MATCH)  { return elseCode; }\n\n    return condCode.concat(\n      [thenCode.length, elseCode.length],\n      thenCode,\n      elseCode\n    );\n  }\n\n  /**\n   * @param {number[]} condCode\n   * @param {number[]} bodyCode\n   * @returns {number[]}\n   */\n  function buildLoop(condCode, bodyCode) {\n    return condCode.concat([bodyCode.length], bodyCode);\n  }\n\n  /**\n   * @param {number} functionIndex\n   * @param {number} delta\n   * @param {Env} env\n   * @param {number} sp\n   * @returns {number[]}\n   */\n  function buildCall(functionIndex, delta, env, sp) {\n    const params = Object.keys(env).map(name => sp - env[name]);\n\n    return [op.CALL, functionIndex, delta, params.length].concat(params);\n  }\n\n  /**\n   * @template T\n   * @param {PEG.ast.Expr<T>} expression\n   * @param {boolean} negative\n   * @param {Context} context\n   * @returns {number[]}\n   */\n  function buildSimplePredicate(expression, negative, context) {\n    const match = expression.match || 0;\n\n    return buildSequence(\n      [op.PUSH_CURR_POS],\n      [op.SILENT_FAILS_ON],\n      // eslint-disable-next-line no-use-before-define -- Mutual recursion\n      generate(expression, {\n        sp: context.sp + 1,\n        env: cloneEnv(context.env),\n        action: null,\n      }),\n      [op.SILENT_FAILS_OFF],\n      buildCondition(\n        negative ? -match : match,\n        [negative ? op.IF_ERROR : op.IF_NOT_ERROR],\n        buildSequence(\n          [op.POP],\n          [negative ? op.POP : op.POP_CURR_POS],\n          [op.PUSH_UNDEFINED]\n        ),\n        buildSequence(\n          [op.POP],\n          [negative ? op.POP_CURR_POS : op.POP],\n          [op.PUSH_FAILED]\n        )\n      )\n    );\n  }\n  /**\n   *\n   * @param {PEG.ast.SemanticPredicate} node\n   * @param {boolean} negative\n   * @param {Context} context\n   * @returns {number[]}\n   */\n  function buildSemanticPredicate(node, negative, context) {\n    const functionIndex = addFunctionConst(\n      true, Object.keys(context.env), node\n    );\n\n    return buildSequence(\n      [op.UPDATE_SAVED_POS],\n      buildCall(functionIndex, 0, context.env, context.sp),\n      buildCondition(\n        node.match || 0,\n        [op.IF],\n        buildSequence(\n          [op.POP],\n          negative ? [op.PUSH_FAILED] : [op.PUSH_UNDEFINED]\n        ),\n        buildSequence(\n          [op.POP],\n          negative ? [op.PUSH_UNDEFINED] : [op.PUSH_FAILED]\n        )\n      )\n    );\n  }\n\n  /**\n   * @param {number[]} expressionCode\n   * @returns {number[]}\n   */\n  function buildAppendLoop(expressionCode) {\n    return buildLoop(\n      [op.WHILE_NOT_ERROR],\n      buildSequence([op.APPEND], expressionCode)\n    );\n  }\n\n  /**\n   * @param {never} boundary\n   * @returns {Error}\n   */\n  function unknownBoundary(boundary) {\n    const b = /** @type {{ type: string }} */(boundary);\n    return new Error(`Unknown boundary type \"${b.type}\" for the \"repeated\" node`);\n  }\n\n  /**\n   *\n   * @param {import(\"../../peg\").ast.RepeatedBoundary} boundary\n   * @param {{ [label: string]: number}} env Mapping of label names to stack positions\n   * @param {number} sp Number of the first free slot in the stack\n   * @param {number} offset\n   *\n   * @returns {{ pre: number[], post: number[], sp: number}}\n   *          Bytecode that should be added before and after parsing and new\n   *          first free slot in the stack\n   */\n  function buildRangeCall(boundary, env, sp, offset) {\n    switch (boundary.type) {\n      case \"constant\":\n        return { pre: [], post: [], sp };\n      case \"variable\":\n        boundary.sp = offset + sp - env[boundary.value];\n        return { pre: [], post: [], sp };\n      case \"function\": {\n        boundary.sp = offset;\n\n        const functionIndex = addFunctionConst(\n          true,\n          Object.keys(env),\n          { code: boundary.value, codeLocation: boundary.codeLocation }\n        );\n\n        return {\n          pre: buildCall(functionIndex, 0, env, sp),\n          post: [op.NIP],\n          // +1 for the function result\n          sp: sp + 1,\n        };\n      }\n\n      // istanbul ignore next Because we never generate invalid boundary type we cannot reach this branch\n      default:\n        throw unknownBoundary(boundary);\n    }\n  }\n\n  /**\n   * @param {number[]} expressionCode Bytecode for parsing repetitions\n   * @param {import(\"../../peg\").ast.RepeatedBoundary} max Maximum boundary of repetitions.\n   *        If `null`, the maximum boundary is unlimited\n   *\n   * @returns {number[]} Bytecode that performs check of the maximum boundary\n   */\n  function buildCheckMax(expressionCode, max) {\n    if (max.value !== null) {\n      const checkCode = max.type === \"constant\"\n        ? [op.IF_GE, max.value]\n        : [op.IF_GE_DYNAMIC, max.sp || 0];\n\n      // Push `peg$FAILED` - this break loop on next iteration, so |result|\n      // will contains not more then |max| elements.\n      return buildCondition(\n        SOMETIMES_MATCH,\n        checkCode,             // if (r.length >= max)   stack:[ [elem...] ]\n        [op.PUSH_FAILED],      //   elem = peg$FAILED;   stack:[ [elem...], peg$FAILED ]\n        expressionCode         // else\n      );                       //   elem = expr();       stack:[ [elem...], elem ]\n    }\n\n    return expressionCode;\n  }\n\n  /* eslint capitalized-comments: \"off\" */\n  /**\n   * @param {number[]} expressionCode Bytecode for parsing repeated elements\n   * @param {import(\"../../peg\").ast.RepeatedBoundary} min Minimum boundary of repetitions.\n   *        If `null`, the minimum boundary is zero\n   *\n   * @returns {number[]} Bytecode that performs check of the minimum boundary\n   */\n  function buildCheckMin(expressionCode, min) {\n    const checkCode = min.type === \"constant\"\n      ? [op.IF_LT, min.value]\n      : [op.IF_LT_DYNAMIC, min.sp || 0];\n\n    return buildSequence(\n      expressionCode,             // result = [elem...];      stack:[ pos, [elem...] ]\n      buildCondition(\n        SOMETIMES_MATCH,\n        checkCode,                // if (result.length < min) {\n        /* eslint-disable @stylistic/indent -- Clarity */\n        [op.POP, op.POP_CURR_POS, //   currPos = savedPos;    stack:[  ]\n         op.PUSH_FAILED],         //   result = peg$FAILED;   stack:[ peg$FAILED ]\n        /* eslint-enable @stylistic/indent */\n        [op.NIP]                  // }                        stack:[ [elem...] ]\n      )\n    );\n  }\n  /**\n   *\n   * @param {PEG.ast.Expression|null} delimiterNode\n   * @param {number} expressionMatch\n   * @param {number[]} expressionCode\n   * @param {Context} context\n   * @param {number} offset\n   * @returns {number[]}\n   */\n  function buildRangeBody(\n    delimiterNode,\n    expressionMatch,\n    expressionCode,\n    context,\n    offset\n  ) {\n    if (delimiterNode) {\n      return buildSequence(           //                          stack:[  ]\n        [op.PUSH_CURR_POS],           // pos = peg$currPos;       stack:[ pos ]\n        // eslint-disable-next-line no-use-before-define -- Mutual recursion\n        generate(delimiterNode, {     // item = delim();          stack:[ pos, delim ]\n          // +1 for the saved offset\n          sp: context.sp + offset + 1,\n          env: cloneEnv(context.env),\n          action: null,\n        }),\n        buildCondition(\n          delimiterNode.match || 0,\n          [op.IF_NOT_ERROR],          // if (item !== peg$FAILED) {\n          buildSequence(\n            [op.POP],                 //                          stack:[ pos ]\n            expressionCode,           //   item = expr();         stack:[ pos, item ]\n            buildCondition(\n              -expressionMatch,\n              [op.IF_ERROR],          //   if (item === peg$FAILED) {\n              // If element FAILED, rollback currPos to saved value.\n              /* eslint-disable @stylistic/indent -- Clarity */\n              [op.POP,                //                          stack:[ pos ]\n               op.POP_CURR_POS,       //     peg$currPos = pos;   stack:[  ]\n               op.PUSH_FAILED],       //     item = peg$FAILED;   stack:[ peg$FAILED ]\n              /* eslint-enable @stylistic/indent */\n              // Else, just drop saved currPos.\n              [op.NIP]                //   }                      stack:[ item ]\n            )\n          ),                          // }\n          // If delimiter FAILED, currPos not changed, so just drop it.\n          [op.NIP]                    //                          stack:[ peg$FAILED ]\n        )                             //                          stack:[ <?> ]\n      );\n    }\n\n    return expressionCode;\n  }\n\n  /**\n   * @param {PEG.compiler.visitor.NodeTypes} generators\n   * @returns {PEG.compiler.visitor.AnyFunction}\n   */\n  function wrapGenerators(generators) {\n    if (options && options.output === \"source-and-map\") {\n      Object.keys(generators).forEach(name => {\n        // @ts-ignore\n        const generator = generators[name];\n        // @ts-ignore\n        generators[name] = function(node, ...args) {\n          const generated = generator(node, ...args);\n          // Some generators (\"grammar\" and \"rule\") don't return anything,\n          // so don't bother wrapping their return values.\n          if (generated === undefined || !node.location) {\n            return generated;\n          }\n          return buildSequence(\n            [\n              op.SOURCE_MAP_PUSH,\n              addLocation(node.location),\n            ],\n            generated,\n            [\n              op.SOURCE_MAP_POP,\n            ]\n          );\n        };\n      });\n    }\n    return visitor.build(generators);\n  }\n\n  const generate = wrapGenerators({\n    grammar(node) {\n      node.rules.forEach(generate);\n\n      node.literals = literals.items;\n      node.classes = classes.items;\n      node.expectations = expectations.items;\n      node.importedNames = importedNames.items;\n      node.functions = functions;\n      node.locations = locations;\n    },\n\n    rule(node) {\n      node.bytecode = generate(node.expression, {\n        sp: -1,        // Stack pointer\n        env: {},       // Mapping of label names to stack positions\n        pluck: [],     // Fields that have been picked\n        action: null,  // Action nodes pass themselves to children here\n      });\n    },\n\n    named(node, context) {\n      const match = node.match || 0;\n      // Expectation not required if node always match\n      const nameIndex = (match === ALWAYS_MATCH)\n        ? -1\n        : expectations.add({ type: \"rule\", value: node.name });\n\n      // The code generated below is slightly suboptimal because |FAIL| pushes\n      // to the stack, so we need to stick a |POP| in front of it. We lack a\n      // dedicated instruction that would just report the failure and not touch\n      // the stack.\n      return buildSequence(\n        [op.SILENT_FAILS_ON],\n        generate(node.expression, context),\n        [op.SILENT_FAILS_OFF],\n        buildCondition(-match, [op.IF_ERROR], [op.FAIL, nameIndex], [])\n      );\n    },\n\n    choice(node, context) {\n      /**\n       *\n       * @param {PEG.ast.Expression[]} alternatives\n       * @param {Context} context\n       * @returns {number[]}\n       */\n      function buildAlternativesCode(alternatives, context) {\n        const match = alternatives[0].match || 0;\n        const first = generate(alternatives[0], {\n          sp: context.sp,\n          env: cloneEnv(context.env),\n          action: null,\n        });\n        // If an alternative always match, no need to generate code for the next\n        // alternatives. Because their will never tried to match, any side-effects\n        // from next alternatives is impossible so we can skip their generation\n        if (match === ALWAYS_MATCH) {\n          return first;\n        }\n\n        // Even if an alternative never match it can have side-effects from\n        // a semantic predicates or an actions, so we can not skip generation\n        // of the first alternative.\n        // We can do that when analysis for possible side-effects will be introduced\n        return buildSequence(\n          first,\n          alternatives.length > 1\n            ? buildCondition(\n                SOMETIMES_MATCH,\n                [op.IF_ERROR],\n                buildSequence(\n                  [op.POP],\n                  buildAlternativesCode(alternatives.slice(1), context)\n                ),\n                []\n              )\n            : []\n        );\n      }\n\n      return buildAlternativesCode(node.alternatives, context);\n    },\n\n    action(node, context) {\n      const env = cloneEnv(context.env);\n      const emitCall = node.expression.type !== \"sequence\"\n                    || node.expression.elements.length === 0;\n      const expressionCode = generate(node.expression, {\n        sp: context.sp + (emitCall ? 1 : 0),\n        env,\n        action: node,\n      });\n      const match = node.expression.match || 0;\n      // Function only required if expression can match\n      const functionIndex = emitCall && match !== NEVER_MATCH\n        ? addFunctionConst(false, Object.keys(env), node)\n        : -1;\n\n      return emitCall\n        ? buildSequence(\n            [op.PUSH_CURR_POS],\n            expressionCode,\n            buildCondition(\n              match,\n              [op.IF_NOT_ERROR],\n              buildSequence(\n                [op.LOAD_SAVED_POS, 1],\n                buildCall(functionIndex, 1, env, context.sp + 2)\n              ),\n              []\n            ),\n            [op.NIP]\n          )\n        : expressionCode;\n    },\n\n    sequence(node, context) {\n      /**\n       *\n       * @param {PEG.ast.Expression[]} elements\n       * @param {Context} context\n       * @returns {number[]}\n       */\n      function buildElementsCode(elements, context) {\n        if (elements.length > 0) {\n          const processedCount = node.elements.length - elements.length + 1;\n\n          return buildSequence(\n            generate(elements[0], {\n              sp: context.sp,\n              env: context.env,\n              pluck: context.pluck,\n              action: null,\n            }),\n            buildCondition(\n              elements[0].match || 0,\n              [op.IF_NOT_ERROR],\n              buildElementsCode(elements.slice(1), {\n                sp: context.sp + 1,\n                env: context.env,\n                pluck: context.pluck,\n                action: context.action,\n              }),\n              buildSequence(\n                processedCount > 1 ? [op.POP_N, processedCount] : [op.POP],\n                [op.POP_CURR_POS],\n                [op.PUSH_FAILED]\n              )\n            )\n          );\n        } else {\n          if (context.pluck && context.pluck.length > 0) {\n            return buildSequence(\n              [op.PLUCK, node.elements.length + 1, context.pluck.length],\n              context.pluck.map(eSP => context.sp - eSP)\n            );\n          }\n\n          if (context.action) {\n            const functionIndex = addFunctionConst(\n              false,\n              Object.keys(context.env),\n              context.action\n            );\n\n            return buildSequence(\n              [op.LOAD_SAVED_POS, node.elements.length],\n              buildCall(\n                functionIndex,\n                node.elements.length + 1,\n                context.env,\n                context.sp\n              )\n            );\n          } else {\n            return buildSequence([op.WRAP, node.elements.length], [op.NIP]);\n          }\n        }\n      }\n\n      return buildSequence(\n        [op.PUSH_CURR_POS],\n        buildElementsCode(node.elements, {\n          sp: context.sp + 1,\n          env: context.env,\n          pluck: [],\n          action: context.action,\n        })\n      );\n    },\n\n    labeled(node, context) {\n      let env = context.env;\n      const label = node.label;\n      const sp = context.sp + 1;\n\n      if (label) {\n        env = cloneEnv(context.env);\n        context.env[label] = sp;\n      }\n\n      if (node.pick) {\n        context.pluck.push(sp);\n      }\n\n      const expression = generate(node.expression, {\n        sp: context.sp,\n        env,\n        action: null,\n      });\n\n      if (label && node.labelLocation && options && options.output === \"source-and-map\") {\n        return buildSequence(\n          [\n            op.SOURCE_MAP_LABEL_PUSH,\n            sp,\n            literals.add(label),\n            addLocation(node.labelLocation),\n          ],\n          expression,\n          [op.SOURCE_MAP_LABEL_POP, sp]\n        );\n      }\n      return expression;\n    },\n\n    text(node, context) {\n      return buildSequence(\n        [op.PUSH_CURR_POS],\n        generate(node.expression, {\n          sp: context.sp + 1,\n          env: cloneEnv(context.env),\n          action: null,\n        }),\n        buildCondition(\n          node.match || 0,\n          [op.IF_NOT_ERROR],\n          buildSequence([op.POP], [op.TEXT]),\n          [op.NIP]\n        )\n      );\n    },\n\n    simple_and(node, context) {\n      return buildSimplePredicate(node.expression, false, context);\n    },\n\n    simple_not(node, context) {\n      return buildSimplePredicate(node.expression, true, context);\n    },\n\n    optional(node, context) {\n      return buildSequence(\n        generate(node.expression, {\n          sp: context.sp,\n          env: cloneEnv(context.env),\n          action: null,\n        }),\n        buildCondition(\n          // Check expression match, not the node match\n          // If expression always match, no need to replace FAILED to NULL,\n          // because FAILED will never appeared\n          -(node.expression.match || 0),\n          [op.IF_ERROR],\n          buildSequence([op.POP], [op.PUSH_NULL]),\n          []\n        )\n      );\n    },\n\n    zero_or_more(node, context) {\n      const expressionCode = generate(node.expression, {\n        sp: context.sp + 1,\n        env: cloneEnv(context.env),\n        action: null,\n      });\n\n      return buildSequence(\n        [op.PUSH_EMPTY_ARRAY],\n        expressionCode,\n        buildAppendLoop(expressionCode),\n        [op.POP]\n      );\n    },\n\n    one_or_more(node, context) {\n      const expressionCode = generate(node.expression, {\n        sp: context.sp + 1,\n        env: cloneEnv(context.env),\n        action: null,\n      });\n\n      return buildSequence(\n        [op.PUSH_EMPTY_ARRAY],\n        expressionCode,\n        buildCondition(\n          // Condition depends on the expression match, not the node match\n          node.expression.match || 0,\n          [op.IF_NOT_ERROR],\n          buildSequence(buildAppendLoop(expressionCode), [op.POP]),\n          buildSequence([op.POP], [op.POP], [op.PUSH_FAILED])\n        )\n      );\n    },\n\n    repeated(node, context) {\n      // Handle case when minimum was literally equals to maximum\n      const min = node.min ? node.min : node.max;\n      const hasMin = min.type !== \"constant\" || min.value > 0;\n      const hasBoundedMax = node.max.type !== \"constant\" && node.max.value !== null;\n\n      // +1 for the result slot with an array\n      // +1 if we have non-constant (i.e. potentially non-zero) or non-zero minimum\n      //    for the position before match for backtracking\n      const offset = hasMin ? 2 : 1;\n\n      // Do not generate function for \"minimum\" if grammar used `exact` syntax\n      const minCode = node.min\n        ? buildRangeCall(\n            node.min,\n            context.env,\n            context.sp,\n            // +1 for the result slot with an array\n            // +1 for the saved position\n            // +1 if we have a \"function\" maximum it occupies an additional slot in the stack\n            2 + (node.max.type === \"function\" ? 1 : 0)\n          )\n        : { pre: [], post: [], sp: context.sp };\n      const maxCode = buildRangeCall(node.max, context.env, minCode.sp, offset);\n\n      const firstExpressionCode = generate(node.expression, {\n        sp: maxCode.sp + offset,\n        env: cloneEnv(context.env),\n        action: null,\n      });\n      const expressionCode = node.delimiter !== null\n        ? generate(node.expression, {\n          // +1 for the saved position before parsing the `delimiter elem` pair\n            sp: maxCode.sp + offset + 1,\n            env: cloneEnv(context.env),\n            action: null,\n          })\n        : firstExpressionCode;\n      const bodyCode = buildRangeBody(\n        node.delimiter,\n        node.expression.match || 0,\n        expressionCode,\n        context,\n        offset\n      );\n      // Check the high boundary, if it is defined.\n      const checkMaxCode = buildCheckMax(bodyCode, node.max);\n      // For dynamic high boundary we need check the first iteration, because the result can be\n      // empty. Constant boundaries does not require that check, because they are always >=1\n      const firstElemCode = hasBoundedMax\n        ? buildCheckMax(firstExpressionCode, node.max)\n        : firstExpressionCode;\n      const mainLoopCode = buildSequence(\n        // If the low boundary present, then backtracking is possible, so save the current pos\n        hasMin ? [op.PUSH_CURR_POS] : [], // var savedPos = curPos;   stack:[ pos ]\n        [op.PUSH_EMPTY_ARRAY],            // var result = [];         stack:[ pos, [] ]\n        firstElemCode,                    // var elem = expr();       stack:[ pos, [], elem ]\n        buildAppendLoop(checkMaxCode),    // while(...)r.push(elem);  stack:[ pos, [...], elem|peg$FAILED ]\n        [op.POP]                          //                          stack:[ pos, [...] ] (pop elem===`peg$FAILED`)\n      );\n\n      return buildSequence(\n        minCode.pre,\n        maxCode.pre,\n        // Check the low boundary, if it is defined and not |0|.\n        hasMin\n          ? buildCheckMin(mainLoopCode, min)\n          : mainLoopCode,\n        maxCode.post,\n        minCode.post\n      );\n    },\n\n    group(node, context) {\n      return generate(node.expression, {\n        sp: context.sp,\n        env: cloneEnv(context.env),\n        action: null,\n      });\n    },\n\n    semantic_and(node, context) {\n      return buildSemanticPredicate(node, false, context);\n    },\n\n    semantic_not(node, context) {\n      return buildSemanticPredicate(node, true, context);\n    },\n\n    rule_ref(node) {\n      return [op.RULE, asts.indexOfRule(ast, node.name)];\n    },\n\n    library_ref(node) {\n      return [\n        op.LIBRARY_RULE,\n        node.libraryNumber,\n        importedNames.add(node.name),\n      ];\n    },\n\n    literal(node) {\n      if (node.value.length > 0) {\n        const match = node.match || 0;\n        // String only required if condition is generated or string is\n        // case-sensitive and node always match\n        const needConst = match === SOMETIMES_MATCH\n                      || (match === ALWAYS_MATCH && !node.ignoreCase);\n        const stringIndex = needConst\n          ? literals.add(\n              node.ignoreCase ? node.value.toLowerCase() : node.value\n            )\n          : -1;\n        // Expectation not required if node always match\n        const expectedIndex = (match !== ALWAYS_MATCH)\n          ? expectations.add({\n              type: \"literal\",\n              value: node.value,\n              ignoreCase: node.ignoreCase,\n            })\n          : -1;\n\n        // For case-sensitive strings the value must match the beginning of the\n        // remaining input exactly. As a result, we can use |ACCEPT_STRING| and\n        // save one |substr| call that would be needed if we used |ACCEPT_N|.\n        return buildCondition(\n          match,\n          node.ignoreCase\n            ? [op.MATCH_STRING_IC, stringIndex]\n            : [op.MATCH_STRING, stringIndex],\n          node.ignoreCase\n            ? [op.ACCEPT_N, node.value.length]\n            : [op.ACCEPT_STRING, stringIndex],\n          [op.FAIL, expectedIndex]\n        );\n      }\n\n      return [op.PUSH_EMPTY_STRING];\n    },\n\n    class(node) {\n      const match = node.match || 0;\n      // Character class constant only required if condition is generated\n      const classIndex = match === SOMETIMES_MATCH ? classes.add(node) : -1;\n      // Expectation not required if node always match\n      const expectedIndex = (match !== ALWAYS_MATCH)\n        ? expectations.add({\n            type: \"class\",\n            value: node.parts,\n            inverted: node.inverted,\n            ignoreCase: node.ignoreCase,\n            unicode: node.unicode,\n          })\n        : -1;\n\n      return buildCondition(\n        match,\n        [\n          node.unicode ? op.MATCH_UNICODE_CLASS : op.MATCH_CHAR_CLASS,\n          classIndex,\n        ],\n        [op.ACCEPT_N, node.unicode ? -1 : 1],\n        [op.FAIL, expectedIndex]\n      );\n    },\n\n    any(node) {\n      const match = node.match || 0;\n      // Expectation not required if node always match\n      const expectedIndex = (match !== ALWAYS_MATCH)\n        ? expectations.add({\n            type: \"any\",\n          })\n        : -1;\n\n      return buildCondition(\n        match,\n        [op.MATCH_ANY],\n        [op.ACCEPT_N, 1],\n        [op.FAIL, expectedIndex]\n      );\n    },\n  });\n\n  generate(ast);\n}\n\nmodule.exports = generateBytecode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst intToCharMap =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst base64 = require(\"./base64\");\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nconst VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nconst VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nconst VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nconst VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  let encoded = \"\";\n  let digit;\n\n  let vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n  throw new Error('\"' + aName + '\" is a required argument.');\n}\nexports.getArg = getArg;\n\nconst supportsNullProto = (function () {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n})();\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (\n    s.charCodeAt(length - 1) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 2) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n    s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n    s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n    s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n    s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n    s.charCodeAt(length - 8) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 9) !== 95 /* '_' */\n  ) {\n    return false;\n  }\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated =\n  compareByGeneratedPositionsInflated;\n\n// We use 'http' as the base here because we want URLs processed relative\n// to the safe base to be treated as \"special\" URLs during parsing using\n// the WHATWG URL parsing. This ensures that backslash normalization\n// applies to the path and such.\nconst PROTOCOL = \"http:\";\nconst PROTOCOL_AND_HOST = `${PROTOCOL}//host`;\n\n/**\n * Make it easy to create small utilities that tweak a URL's path.\n */\nfunction createSafeHandler(cb) {\n  return input => {\n    const type = getURLType(input);\n    const base = buildSafeBase(input);\n    const url = new URL(input, base);\n\n    cb(url);\n\n    const result = url.toString();\n\n    if (type === \"absolute\") {\n      return result;\n    } else if (type === \"scheme-relative\") {\n      return result.slice(PROTOCOL.length);\n    } else if (type === \"path-absolute\") {\n      return result.slice(PROTOCOL_AND_HOST.length);\n    }\n\n    // This assumes that the callback will only change\n    // the path, search and hash values.\n    return computeRelativeURL(base, result);\n  };\n}\n\nfunction withBase(url, base) {\n  return new URL(url, base).toString();\n}\n\nfunction buildUniqueSegment(prefix, str) {\n  let id = 0;\n  do {\n    const ident = prefix + id++;\n    if (str.indexOf(ident) === -1) return ident;\n  } while (true);\n}\n\nfunction buildSafeBase(str) {\n  const maxDotParts = str.split(\"..\").length - 1;\n\n  // If we used a segment that also existed in `str`, then we would be unable\n  // to compute relative paths. For example, if `segment` were just \"a\":\n  //\n  //   const url = \"../../a/\"\n  //   const base = buildSafeBase(url); // http://host/a/a/\n  //   const joined = \"http://host/a/\";\n  //   const result = relative(base, joined);\n  //\n  // Expected: \"../../a/\";\n  // Actual: \"a/\"\n  //\n  const segment = buildUniqueSegment(\"p\", str);\n\n  let base = `${PROTOCOL_AND_HOST}/`;\n  for (let i = 0; i < maxDotParts; i++) {\n    base += `${segment}/`;\n  }\n  return base;\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9\\+\\-\\.]+:/;\nfunction getURLType(url) {\n  if (url[0] === \"/\") {\n    if (url[1] === \"/\") return \"scheme-relative\";\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(url) ? \"absolute\" : \"path-relative\";\n}\n\n/**\n * Given two URLs that are assumed to be on the same\n * protocol/host/user/password build a relative URL from the\n * path, params, and hash values.\n *\n * @param rootURL The root URL that the target will be relative to.\n * @param targetURL The target that the relative URL points to.\n * @return A rootURL-relative, normalized URL value.\n */\nfunction computeRelativeURL(rootURL, targetURL) {\n  if (typeof rootURL === \"string\") rootURL = new URL(rootURL);\n  if (typeof targetURL === \"string\") targetURL = new URL(targetURL);\n\n  const targetParts = targetURL.pathname.split(\"/\");\n  const rootParts = rootURL.pathname.split(\"/\");\n\n  // If we've got a URL path ending with a \"/\", we remove it since we'd\n  // otherwise be relative to the wrong location.\n  if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {\n    rootParts.pop();\n  }\n\n  while (\n    targetParts.length > 0 &&\n    rootParts.length > 0 &&\n    targetParts[0] === rootParts[0]\n  ) {\n    targetParts.shift();\n    rootParts.shift();\n  }\n\n  const relativePath = rootParts\n    .map(() => \"..\")\n    .concat(targetParts)\n    .join(\"/\");\n\n  return relativePath + targetURL.search + targetURL.hash;\n}\n\n/**\n * Given a URL, ensure that it is treated as a directory URL.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst ensureDirectory = createSafeHandler(url => {\n  url.pathname = url.pathname.replace(/\\/?$/, \"/\");\n});\n\n/**\n * Normalize a given URL.\n * * Convert backslashes.\n * * Remove any \"..\" and \".\" segments.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst normalize = createSafeHandler(url => {});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL. Assumed to reference a directory.\n * @param aPath The path or URL to be joined with the root.\n * @return A joined and normalized URL value.\n */\nfunction join(aRoot, aPath) {\n  const pathType = getURLType(aPath);\n  const rootType = getURLType(aRoot);\n\n  aRoot = ensureDirectory(aRoot);\n\n  if (pathType === \"absolute\") {\n    return withBase(aPath, undefined);\n  }\n  if (rootType === \"absolute\") {\n    return withBase(aPath, aRoot);\n  }\n\n  if (pathType === \"scheme-relative\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"scheme-relative\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(\n      PROTOCOL.length\n    );\n  }\n\n  if (pathType === \"path-absolute\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"path-absolute\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(\n      PROTOCOL_AND_HOST.length\n    );\n  }\n\n  const base = buildSafeBase(aPath + aRoot);\n  const newPath = withBase(aPath, withBase(aRoot, base));\n  return computeRelativeURL(base, newPath);\n}\nexports.join = join;\n\n/**\n * Make a path relative to a URL or another path. If returning a\n * relative URL is not possible, the original target will be returned.\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n * @return A rootURL-relative (if possible), normalized URL value.\n */\nfunction relative(rootURL, targetURL) {\n  const result = relativeIfPossible(rootURL, targetURL);\n\n  return typeof result === \"string\" ? result : normalize(targetURL);\n}\nexports.relative = relative;\n\nfunction relativeIfPossible(rootURL, targetURL) {\n  const urlType = getURLType(rootURL);\n  if (urlType !== getURLType(targetURL)) {\n    return null;\n  }\n\n  const base = buildSafeBase(rootURL + targetURL);\n  const root = new URL(rootURL, base);\n  const target = new URL(targetURL, base);\n\n  try {\n    new URL(\"\", target.toString());\n  } catch (_err) {\n    // Bail if the URL doesn't support things being relative to it,\n    // For example, data: and blob: URLs.\n    return null;\n  }\n\n  if (\n    target.protocol !== root.protocol ||\n    target.user !== root.user ||\n    target.password !== root.password ||\n    target.hostname !== root.hostname ||\n    target.port !== root.port\n  ) {\n    return null;\n  }\n\n  return computeRelativeURL(root, target);\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nclass ArraySet {\n  constructor() {\n    this._array = [];\n    this._set = new Map();\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  static fromArray(aArray, aAllowDuplicates) {\n    const set = new ArraySet();\n    for (let i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  }\n\n  /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */\n  size() {\n    return this._set.size;\n  }\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  add(aStr, aAllowDuplicates) {\n    const isDuplicate = this.has(aStr);\n    const idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set.set(aStr, idx);\n    }\n  }\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  has(aStr) {\n    return this._set.has(aStr);\n  }\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  indexOf(aStr) {\n    const idx = this._set.get(aStr);\n    if (idx >= 0) {\n      return idx;\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  }\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n  }\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  toArray() {\n    return this._array.slice();\n  }\n}\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  const lineA = mappingA.generatedLine;\n  const lineB = mappingB.generatedLine;\n  const columnA = mappingA.generatedColumn;\n  const columnB = mappingB.generatedColumn;\n  return (\n    lineB > lineA ||\n    (lineB == lineA && columnB >= columnA) ||\n    util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0\n  );\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a negligible overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nclass MappingList {\n  constructor() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = { generatedLine: -1, generatedColumn: 0 };\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  unsortedForEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  }\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  }\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositionsInflated);\n      this._sorted = true;\n    }\n    return this._array;\n  }\n}\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst util = require(\"./util\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst MappingList = require(\"./mapping-list\").MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nclass SourceMapGenerator {\n  constructor(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  static fromSourceMap(aSourceMapConsumer) {\n    const sourceRoot = aSourceMapConsumer.sourceRoot;\n    const generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot,\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      const newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn,\n        },\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn,\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      let sourceRelative = sourceFile;\n      if (sourceRoot != null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  }\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  addMapping(aArgs) {\n    const generated = util.getArg(aArgs, \"generated\");\n    const original = util.getArg(aArgs, \"original\", null);\n    let source = util.getArg(aArgs, \"source\", null);\n    let name = util.getArg(aArgs, \"name\", null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original && original.line,\n      originalColumn: original && original.column,\n      source,\n      name,\n    });\n  }\n\n  /**\n   * Set the source content for a source file.\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    let source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  }\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    let sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          \"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" +\n            'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    const sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    const newSources =\n      this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;\n    const newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        const original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn,\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source);\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      const source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      const name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (srcFile) {\n      const content = aSourceMapConsumer.sourceContentFor(srcFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          srcFile = util.join(aSourceMapPath, srcFile);\n        }\n        if (sourceRoot != null) {\n          srcFile = util.relative(sourceRoot, srcFile);\n        }\n        this.setSourceContent(srcFile, content);\n      }\n    }, this);\n  }\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  _validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (\n      aOriginal &&\n      typeof aOriginal.line !== \"number\" &&\n      typeof aOriginal.column !== \"number\"\n    ) {\n      throw new Error(\n        \"original.line and original.column are not numbers -- you probably meant to omit \" +\n          \"the original mapping entirely and only map the generated position. If so, pass \" +\n          \"null for the original mapping instead of an object with empty or null values.\"\n      );\n    }\n\n    if (\n      aGenerated &&\n      \"line\" in aGenerated &&\n      \"column\" in aGenerated &&\n      aGenerated.line > 0 &&\n      aGenerated.column >= 0 &&\n      !aOriginal &&\n      !aSource &&\n      !aName\n    ) {\n      // Case 1.\n    } else if (\n      aGenerated &&\n      \"line\" in aGenerated &&\n      \"column\" in aGenerated &&\n      aOriginal &&\n      \"line\" in aOriginal &&\n      \"column\" in aOriginal &&\n      aGenerated.line > 0 &&\n      aGenerated.column >= 0 &&\n      aOriginal.line > 0 &&\n      aOriginal.column >= 0 &&\n      aSource\n    ) {\n      // Cases 2 and 3.\n    } else {\n      throw new Error(\n        \"Invalid mapping: \" +\n          JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName,\n          })\n      );\n    }\n  }\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  _serializeMappings() {\n    let previousGeneratedColumn = 0;\n    let previousGeneratedLine = 1;\n    let previousOriginalColumn = 0;\n    let previousOriginalLine = 0;\n    let previousName = 0;\n    let previousSource = 0;\n    let result = \"\";\n    let next;\n    let mapping;\n    let nameIdx;\n    let sourceIdx;\n\n    const mappings = this._mappings.toArray();\n    for (let i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = \"\";\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += \";\";\n          previousGeneratedLine++;\n        }\n      } else if (i > 0) {\n        if (\n          !util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])\n        ) {\n          continue;\n        }\n        next += \",\";\n      }\n\n      next += base64VLQ.encode(\n        mapping.generatedColumn - previousGeneratedColumn\n      );\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(\n          mapping.originalLine - 1 - previousOriginalLine\n        );\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(\n          mapping.originalColumn - previousOriginalColumn\n        );\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  }\n\n  _generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      const key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  }\n\n  /**\n   * Externalize the source map.\n   */\n  toJSON() {\n    const map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings(),\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(\n        map.sources,\n        map.sourceRoot\n      );\n    }\n\n    return map;\n  }\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nSourceMapGenerator.prototype._version = 3;\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\nconst util = require(\"./util\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(\n    aGeneratedCode,\n    aSourceMapConsumer,\n    aRelativePath\n  ) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function () {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length\n          ? remainingLines[remainingLinesIndex++]\n          : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1,\n      lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(\n            0,\n            mapping.generatedColumn - lastGeneratedColumn\n          );\n          remainingLines[remainingLinesIndex] = nextLine.substr(\n            mapping.generatedColumn - lastGeneratedColumn\n          );\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(\n          mapping.generatedColumn\n        );\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(\n          new SourceNode(\n            mapping.originalLine,\n            mapping.originalColumn,\n            source,\n            code,\n            mapping.name\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\n          aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\n          aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name,\n        });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(\n        aPattern,\n        aReplacement\n      );\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0,\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (\n        original.source !== null &&\n        original.line !== null &&\n        original.column !== null\n      ) {\n        if (\n          lastOriginalSource !== original.source ||\n          lastOriginalLine !== original.line ||\n          lastOriginalColumn !== original.column ||\n          lastOriginalName !== original.name\n        ) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column,\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column,\n            },\n            name: original.name,\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column,\n          },\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column,\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column,\n              },\n              name: original.name,\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map };\n  }\n}\n\nexports.SourceNode = SourceNode;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator =\n  require(\"./lib/source-map-generator\").SourceMapGenerator;\nexports.SourceNode = require(\"./lib/source-node\").SourceNode;\n","// @ts-check\n\"use strict\";\n\nconst { SourceNode } = require(\"source-map-generator\");\nconst GrammarLocation = require(\"../grammar-location.js\");\n\n/**\n * @typedef {(string|SourceNode)[]} SourceArray\n */\n\n/** Utility class that helps generating code for C-like languages. */\nclass Stack {\n  /**\n   * Constructs the helper for tracking variable slots of the stack virtual machine\n   *\n   * @param {string} ruleName The name of rule that will be used in error messages\n   * @param {string} varName The prefix for generated names of variables\n   * @param {string} type The type of the variables. For JavaScript there are `var` or `let`\n   * @param {number[]} bytecode Bytecode for error messages\n   */\n  constructor(ruleName, varName, type, bytecode) {\n    /** Last used variable in the stack. */\n    this.sp             = -1;\n    /** Maximum stack size. */\n    this.maxSp          = -1;\n    this.varName        = varName;\n    this.ruleName       = ruleName;\n    this.type           = type;\n    this.bytecode       = bytecode;\n    /**\n     * Map from stack index, to label targetting that index\n     * @type {Record<number,{label:string,location:import(\"../peg.js\").LocationRange}>}\n     */\n    this.labels         = {};\n    /**\n     *  Stack of in-flight source mappings\n     * @type {[SourceArray, number, PEG.LocationRange][]}\n     */\n    this.sourceMapStack = [];\n  }\n\n  /**\n   * Returns name of the variable at the index `i`.\n   *\n   * @param {number} i Index for which name must be generated\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If `i < 0`, which means a stack underflow (there are more `pop`s than `push`es)\n   */\n  name(i) {\n    if (i < 0) {\n      throw new RangeError(\n        `Rule '${this.ruleName}': The variable stack underflow: attempt to use a variable '${this.varName}<x>' at an index ${i}.\\nBytecode: ${this.bytecode}`\n      );\n    }\n\n    return this.varName + i;\n  }\n\n  /**\n   *\n   * @param {PEG.LocationRange} location\n   * @param {SourceArray} chunks\n   * @param {string} [name]\n   * @returns\n   */\n  static sourceNode(location, chunks, name) {\n    const start = GrammarLocation.offsetStart(location);\n    return new SourceNode(\n      start.line,\n      start.column ? start.column - 1 : null,\n      String(location.source),\n      chunks,\n      name\n    );\n  }\n\n  /**\n   * Assigns `exprCode` to the new variable in the stack, returns generated code.\n   * As the result, the size of a stack increases on 1.\n   *\n   * @param {string} exprCode Any expression code that must be assigned to the new variable in the stack\n   * @return {string|SourceNode} Assignment code\n   */\n  push(exprCode) {\n    if (++this.sp > this.maxSp) { this.maxSp = this.sp; }\n\n    const label = this.labels[this.sp];\n    const code = [this.name(this.sp), \" = \", exprCode, \";\"];\n    if (label) {\n      if (this.sourceMapStack.length) {\n        const sourceNode = Stack.sourceNode(\n          label.location,\n          code.splice(0, 2),\n          label.label\n        );\n        const { parts, location } = this.sourceMapPopInternal();\n        const newLoc = (location.start.offset < label.location.end.offset)\n          ? {\n              start: label.location.end,\n              end: location.end,\n              source: location.source,\n            }\n          : location;\n\n        const outerNode = Stack.sourceNode(\n          newLoc,\n          code.concat(\"\\n\")\n        );\n        this.sourceMapStack.push([parts, parts.length + 1, location]);\n        return new SourceNode(\n          null,\n          null,\n          label.location.source,\n          [sourceNode, outerNode]\n        );\n      } else {\n        return Stack.sourceNode(\n          label.location,\n          code.concat(\"\\n\")\n        );\n      }\n    }\n    return code.join(\"\");\n  }\n\n  /**\n   * @overload\n   * @param {undefined} [n]\n   * @return {string}\n   */\n  /**\n   * @overload\n   * @param {number} n\n   * @return {string[]}\n   */\n  /**\n   * Returns name or `n` names of the variable(s) from the top of the stack.\n   *\n   * @param {number} [n] Quantity of variables, which need to be removed from the stack\n   * @returns {string[]|string} Generated name(s). If n is defined then it returns an\n   *                            array of length `n`\n   *\n   * @throws {RangeError} If the stack underflow (there are more `pop`s than `push`es)\n   */\n  pop(n) {\n    if (n !== undefined) {\n      this.sp -= n;\n\n      return Array.from({ length: n }, (v, i) => this.name(this.sp + 1 + i));\n    }\n\n    return this.name(this.sp--);\n  }\n\n  /**\n   * Returns name of the first free variable. The same as `index(0)`.\n   *\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If the stack is empty (there was no `push`'s yet)\n   */\n  top() { return this.name(this.sp); }\n\n  /**\n   * Returns name of the variable at index `i`.\n   *\n   * @param {number} i Index of the variable from top of the stack\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If `i < 0` or more than the stack size\n   */\n  index(i) {\n    if (i < 0) {\n      throw new RangeError(\n        `Rule '${this.ruleName}': The variable stack overflow: attempt to get a variable at a negative index ${i}.\\nBytecode: ${this.bytecode}`\n      );\n    }\n\n    return this.name(this.sp - i);\n  }\n\n  /**\n   * Returns variable name that contains result (bottom of the stack).\n   *\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If the stack is empty (there was no `push`es yet)\n   */\n  result() {\n    if (this.maxSp < 0) {\n      throw new RangeError(\n        `Rule '${this.ruleName}': The variable stack is empty, can't get the result.\\nBytecode: ${this.bytecode}`\n      );\n    }\n\n    return this.name(0);\n  }\n\n  /**\n   * Returns defines of all used variables.\n   *\n   * @return {string} Generated define variable expression with the type `this.type`.\n   *         If the stack is empty, returns empty string\n   */\n  defines() {\n    if (this.maxSp < 0) {\n      return \"\";\n    }\n\n    return this.type + \" \" + Array.from({ length: this.maxSp + 1 }, (v, i) => this.name(i)).join(\", \") + \";\";\n  }\n\n  /**\n   * Checks that code in the `generateIf` and `generateElse` move the stack pointer in the same way.\n   *\n   * @template T\n   * @param {number} pos Opcode number for error messages\n   * @param {() => T} generateIf First function that works with this stack\n   * @param {(() => T)|null} [generateElse] Second function that works with this stack\n   * @return {T[]}\n   *\n   * @throws {Error} If `generateElse` is defined and the stack pointer moved differently in the\n   *         `generateIf` and `generateElse`\n   */\n  checkedIf(pos, generateIf, generateElse) {\n    const baseSp = this.sp;\n\n    const ifResult = generateIf();\n\n    if (!generateElse) {\n      return [ifResult];\n    }\n    const thenSp = this.sp;\n\n    this.sp = baseSp;\n    const elseResult = generateElse();\n\n    if (thenSp !== this.sp) {\n      throw new Error(\n        \"Rule '\" + this.ruleName + \"', position \" + pos + \": \"\n        + \"Branches of a condition can't move the stack pointer differently \"\n        + \"(before: \" + baseSp + \", after then: \" + thenSp + \", after else: \" + this.sp + \"). \"\n        + \"Bytecode: \" + this.bytecode\n      );\n    }\n    return [ifResult, elseResult];\n  }\n\n  /**\n   * Checks that code in the `generateBody` do not move stack pointer.\n   *\n   * @template T\n   * @param {number} pos Opcode number for error messages\n   * @param {() => T} generateBody Function that works with this stack\n   * @return {T}\n   *\n   * @throws {Error} If `generateBody` move the stack pointer (if it contains unbalanced `push`es and `pop`s)\n   */\n  checkedLoop(pos, generateBody) {\n    const baseSp = this.sp;\n\n    const result = generateBody();\n\n    if (baseSp !== this.sp) {\n      throw new Error(\n        \"Rule '\" + this.ruleName + \"', position \" + pos + \": \"\n        + \"Body of a loop can't move the stack pointer \"\n        + \"(before: \" + baseSp + \", after: \" + this.sp + \"). \"\n        + \"Bytecode: \" + this.bytecode\n      );\n    }\n    return result;\n  }\n\n  /**\n   *\n   * @param {SourceArray} parts\n   * @param {PEG.LocationRange} location\n   */\n  sourceMapPush(parts, location) {\n    if (this.sourceMapStack.length) {\n      const top = this.sourceMapStack[this.sourceMapStack.length - 1];\n      // If the current top of stack starts at the same location as\n      // the about to be pushed item, we should update its start location to\n      // be past the new one. Otherwise any code it generates will\n      // get allocated to the inner node.\n      if (top[2].start.offset === location.start.offset\n          && top[2].end.offset > location.end.offset) {\n        top[2] = {\n          start: location.end,\n          end: top[2].end,\n          source: top[2].source,\n        };\n      }\n    }\n    this.sourceMapStack.push([\n      parts,\n      parts.length,\n      location,\n    ]);\n  }\n\n  /**\n   * @returns {{parts:SourceArray,location:PEG.LocationRange}}\n   */\n  sourceMapPopInternal() {\n    const elt = this.sourceMapStack.pop();\n    if (!elt) {\n      throw new RangeError(\n        `Rule '${this.ruleName}': Attempting to pop an empty source map stack.\\nBytecode: ${this.bytecode}`\n      );\n    }\n    const [\n      parts,\n      index,\n      location,\n    ] = elt;\n    const chunks = parts.splice(index).map(\n      chunk => (chunk instanceof SourceNode\n        ? chunk\n        : chunk + \"\\n\"\n      )\n    );\n    if (chunks.length) {\n      const start = GrammarLocation.offsetStart(location);\n      parts.push(new SourceNode(\n        start.line,\n        start.column - 1,\n        String(location.source),\n        chunks\n      ));\n    }\n    return { parts, location };\n  }\n\n  /**\n   * @param {number} [offset]\n   * @returns {[SourceArray, number, PEG.LocationRange]|undefined}\n   */\n  sourceMapPop(offset) {\n    const { location } = this.sourceMapPopInternal();\n    if (this.sourceMapStack.length\n      && location.end.offset\n      < this.sourceMapStack[this.sourceMapStack.length - 1][2].end.offset) {\n      const { parts, location: outer } = this.sourceMapPopInternal();\n      const newLoc = (outer.start.offset < location.end.offset)\n        ? {\n            start: location.end,\n            end: outer.end,\n            source: outer.source,\n          }\n        : outer;\n\n      this.sourceMapStack.push([\n        parts,\n        parts.length + (offset || 0),\n        newLoc,\n      ]);\n    }\n    return undefined;\n  }\n}\n\nmodule.exports = Stack;\n","// Generated by package-extract v3.1.1\n// Do not modify by hand.\n\n\"use strict\";\n\nexports.version = \"5.0.5\";\n","\"use strict\";\n\nfunction hex(ch) { return ch.codePointAt(0).toString(16).toUpperCase(); }\nexports.hex = hex;\n\nfunction stringEscape(s) {\n  if (typeof s === \"object\") {\n    return `\\\\\\\\${s.value}`;\n  }\n  // ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string\n  // literal except for the closing quote character, backslash, carriage\n  // return, line separator, paragraph separator, and line feed. Any character\n  // may appear in the form of an escape sequence.\n  //\n  // For portability, we also escape all control and non-ASCII characters.\n  return s\n    .replace(/\\\\/g,   \"\\\\\\\\\")   // Backslash\n    .replace(/\"/g,    \"\\\\\\\"\")   // Closing double quote\n    .replace(/\\0/g,   \"\\\\0\")    // Null\n    .replace(/\\x08/g, \"\\\\b\")    // Backspace\n    .replace(/\\t/g,   \"\\\\t\")    // Horizontal tab\n    .replace(/\\n/g,   \"\\\\n\")    // Line feed\n    .replace(/\\v/g,   \"\\\\v\")    // Vertical tab\n    .replace(/\\f/g,   \"\\\\f\")    // Form feed\n    .replace(/\\r/g,   \"\\\\r\")    // Carriage return\n    .replace(/[\\u{10000}-\\u{10FFFF}]/gu, ch => `\\\\u{${hex(ch)}}`)\n    .replace(/[\\x00-\\x0F]/g,             ch => \"\\\\x0\" + hex(ch))\n    .replace(/[\\x10-\\x1F\\x7F-\\xFF]/g,    ch => \"\\\\x\"  + hex(ch))\n    .replace(/[\\u0100-\\u0FFF]/g,         ch => \"\\\\u0\" + hex(ch))\n    .replace(/[\\u1000-\\uFFFF]/g,         ch => \"\\\\u\"  + hex(ch));\n}\nexports.stringEscape = stringEscape;\n\nfunction regexpClassEscape(s) {\n  if (typeof s === \"object\") {\n    return `\\\\${s.value}`;\n  }\n  // Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.\n  //\n  // For portability, we also escape all control and non-ASCII characters.\n  return s\n    .replace(/\\\\/g,   \"\\\\\\\\\")   // Backslash\n    .replace(/\\//g,   \"\\\\/\")    // Closing slash\n    .replace(/]/g,    \"\\\\]\")    // Closing bracket\n    .replace(/\\^/g,   \"\\\\^\")    // Caret\n    .replace(/-/g,    \"\\\\-\")    // Dash\n    .replace(/\\0/g,   \"\\\\0\")    // Null\n    .replace(/\\x08/g, \"\\\\b\")    // Backspace\n    .replace(/\\t/g,   \"\\\\t\")    // Horizontal tab\n    .replace(/\\n/g,   \"\\\\n\")    // Line feed\n    .replace(/\\v/g,   \"\\\\v\")    // Vertical tab\n    .replace(/\\f/g,   \"\\\\f\")    // Form feed\n    .replace(/\\r/g,   \"\\\\r\")    // Carriage return\n    .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n    .replace(/[\\x10-\\x1F\\x7F-\\xFF]/g, ch => \"\\\\x\"  + hex(ch))\n    .replace(/[\\u{10000}-\\u{10FFFF}]/gu, ch => \"\\\\u{\"  + hex(ch) + \"}\")\n    .replace(/[\\u0100-\\u0FFF]/g,      ch => \"\\\\u0\" + hex(ch))\n    .replace(/[\\u1000-\\uFFFF]/g,      ch => \"\\\\u\"  + hex(ch));\n}\nexports.regexpClassEscape = regexpClassEscape;\n\n/**\n * Base64 encode a Uint8Array.  Needed for browser compatibility where\n * the Buffer class is not available.\n *\n * @param {Uint8Array} u8 Bytes to encode\n * @returns {string} Base64 encoded string\n */\nfunction base64(u8) {\n  // Note: btoa has the worst API, and even mentioning Buffer here will\n  // cause rollup to suck it in.\n\n  // See RFC4648, sec. 4.\n  // https://datatracker.ietf.org/doc/html/rfc4648#section-4\n  const A = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  const rem = u8.length % 3;\n  const len = u8.length - rem;\n  let res = \"\";\n\n  for (let i = 0; i < len; i += 3) {\n    res += A[u8[i] >> 2];\n    res += A[((u8[i] & 0x3) << 4) | (u8[i + 1] >> 4)];\n    res += A[((u8[i + 1] & 0xf) << 2) | (u8[i + 2] >> 6)];\n    res += A[u8[i + 2] & 0x3f];\n  }\n  if (rem === 1) {\n    res += A[u8[len] >> 2];\n    res += A[(u8[len] & 0x3) << 4];\n    res += \"==\";\n  } else if (rem === 2) {\n    res += A[u8[len] >> 2];\n    res += A[((u8[len] & 0x3) << 4) | (u8[len + 1] >> 4)];\n    res += A[(u8[len + 1] & 0xf) << 2];\n    res += \"=\";\n  }\n\n  return res;\n}\nexports.base64 = base64;\n\n/**\n * Is the given string exactly one unicode character long?  Might be 1 or 2\n * JS chars in UTF-16.\n *\n * @param {string} s\n * @return {number} Codepoint of single char, or -1.\n */\nfunction codePointLen1(s) {\n  const iter = s[Symbol.iterator]();\n  const first = iter.next();\n  if (first.done) {\n    return -1;\n  }\n  const second = iter.next();\n  if (!second.done) {\n    return -1;\n  }\n  return first.value.codePointAt(0);\n}\nexports.codePointLen1 = codePointLen1;\n","// @generated by Peggy 5.0.5.\n//\n// https://peggyjs.org/\n\n\"use strict\";\n\n\nconst OPS_TO_PREFIXED_TYPES = {\n  \"$\": \"text\",\n  \"&\": \"simple_and\",\n  \"!\": \"simple_not\",\n};\n\nconst OPS_TO_SUFFIXED_TYPES = {\n  \"?\": \"optional\",\n  \"*\": \"zero_or_more\",\n  \"+\": \"one_or_more\",\n};\n\nconst OPS_TO_SEMANTIC_PREDICATE_TYPES = {\n  \"&\": \"semantic_and\",\n  \"!\": \"semantic_not\",\n};\n\nclass peg$SyntaxError extends SyntaxError {\n  constructor(message, expected, found, location) {\n    super(message);\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"SyntaxError\";\n  }\n\n  format(sources) {\n    let str = \"Error: \" + this.message;\n    if (this.location) {\n      let src = null;\n      const st = sources.find(s => s.source === this.location.source);\n      if (st) {\n        src = st.text.split(/\\r\\n|\\n|\\r/g);\n      }\n      const s = this.location.start;\n      const offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n        ? this.location.source.offset(s)\n        : s;\n      const loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n      if (src) {\n        const e = this.location.end;\n        const filler = \"\".padEnd(offset_s.line.toString().length, \" \");\n        const line = src[s.line - 1];\n        const last = s.line === e.line ? e.column : line.length + 1;\n        const hatLen = (last - s.column) || 1;\n        str += \"\\n --> \" + loc + \"\\n\"\n            + filler + \" |\\n\"\n            + offset_s.line + \" | \" + line + \"\\n\"\n            + filler + \" | \" + \"\".padEnd(s.column - 1, \" \")\n            + \"\".padEnd(hatLen, \"^\");\n      } else {\n        str += \"\\n at \" + loc;\n      }\n    }\n    return str;\n  }\n\n  static buildMessage(expected, found) {\n    function hex(ch) {\n      return ch.codePointAt(0).toString(16).toUpperCase();\n    }\n\n    const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, \"unicode\")\n      ? new RegExp(\"[\\\\p{C}\\\\p{Mn}\\\\p{Mc}]\", \"gu\")\n      : null;\n    function unicodeEscape(s) {\n      if (nonPrintable) {\n        return s.replace(nonPrintable,  ch => \"\\\\u{\" + hex(ch) + \"}\");\n      }\n      return s;\n    }\n\n    function literalEscape(s) {\n      return unicodeEscape(s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\"/g,  \"\\\\\\\"\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n    }\n\n    function classEscape(s) {\n      return unicodeEscape(s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\\]/g, \"\\\\]\")\n        .replace(/\\^/g, \"\\\\^\")\n        .replace(/-/g,  \"\\\\-\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, ch => \"\\\\x\"  + hex(ch)));\n    }\n\n    const DESCRIBE_EXPECTATION_FNS = {\n      literal(expectation) {\n        return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n      },\n\n      class(expectation) {\n        const escapedParts = expectation.parts.map(\n          part => (Array.isArray(part)\n            ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n            : classEscape(part))\n        );\n\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\" + (expectation.unicode ? \"u\" : \"\");\n      },\n\n      any() {\n        return \"any character\";\n      },\n\n      end() {\n        return \"end of input\";\n      },\n\n      other(expectation) {\n        return expectation.description;\n      },\n    };\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      const descriptions = expected.map(describeExpectation);\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        let j = 1;\n        for (let i = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  }\n}\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  const peg$FAILED = {};\n  const peg$source = options.grammarSource;\n\n  const peg$startRuleFunctions = {\n    Grammar: peg$parseGrammar,\n    ImportsAndSource: peg$parseImportsAndSource,\n  };\n  let peg$startRuleFunction = peg$parseGrammar;\n\n  const peg$c0 = \"import\";\n  const peg$c1 = \";\";\n  const peg$c2 = \",\";\n  const peg$c3 = \"*\";\n  const peg$c4 = \"as\";\n  const peg$c5 = \"{\";\n  const peg$c6 = \"}\";\n  const peg$c7 = \"from\";\n  const peg$c8 = \"=\";\n  const peg$c9 = \"/\";\n  const peg$c10 = \"@\";\n  const peg$c11 = \":\";\n  const peg$c12 = \"|\";\n  const peg$c13 = \"..\";\n  const peg$c14 = \"(\";\n  const peg$c15 = \")\";\n  const peg$c16 = \".\";\n  const peg$c17 = \"\\n\";\n  const peg$c18 = \"\\r\\n\";\n  const peg$c19 = \"/*\";\n  const peg$c20 = \"*/\";\n  const peg$c21 = \"//\";\n  const peg$c22 = \"\\\\\";\n  const peg$c23 = \"i\";\n  const peg$c24 = \"\\\"\";\n  const peg$c25 = \"'\";\n  const peg$c26 = \"[\";\n  const peg$c27 = \"^\";\n  const peg$c28 = \"]\";\n  const peg$c29 = \"p\";\n  const peg$c30 = \"_\";\n  const peg$c31 = \"u\";\n  const peg$c32 = \"-\";\n  const peg$c33 = \"0\";\n  const peg$c34 = \"b\";\n  const peg$c35 = \"f\";\n  const peg$c36 = \"n\";\n  const peg$c37 = \"r\";\n  const peg$c38 = \"t\";\n  const peg$c39 = \"v\";\n  const peg$c40 = \"x\";\n\n  const peg$r0 = /^[!$&]/;\n  const peg$r1 = /^[*-+?]/;\n  const peg$r2 = /^[!&]/;\n  const peg$r3 = /^[\\0-\\uD7FF\\uE000-\\uFFFF]/;\n  const peg$r4 = /^[\\uD800-\\uDBFF]/;\n  const peg$r5 = /^[\\uDC00-\\uDFFF]/;\n  const peg$r6 = /^[\\uD800-\\uDFFF]/;\n  const peg$r7 = /^[\\t\\v-\\f \\p{Zs}\\xA0\\uFEFF]/u;\n  const peg$r8 = /^[\\n\\r\\u2028\\u2029]/;\n  const peg$r9 = /^[\\r\\u2028-\\u2029]/;\n  const peg$r10 = /^[\\p{ID_Start}_]/u;\n  const peg$r11 = /^[$\\p{ID_Continue}]/u;\n  const peg$r12 = /^[\\n\\r\"\\\\\\u2028-\\u2029]/;\n  const peg$r13 = /^[\\n\\r'\\\\\\u2028-\\u2029]/;\n  const peg$r14 = /^[a-z]/i;\n  const peg$r15 = /^[\\n\\r\\\\-\\]\\u2028-\\u2029]/;\n  const peg$r16 = /^[\"'\\\\]/;\n  const peg$r17 = /^[0-9pux]/;\n  const peg$r18 = /^[0-9]/;\n  const peg$r19 = /^[0-9a-f]/i;\n  const peg$r20 = /^[{}]/;\n\n  const peg$e0 = peg$anyExpectation();\n  const peg$e1 = peg$literalExpectation(\"import\", false);\n  const peg$e2 = peg$literalExpectation(\";\", false);\n  const peg$e3 = peg$literalExpectation(\",\", false);\n  const peg$e4 = peg$literalExpectation(\"*\", false);\n  const peg$e5 = peg$literalExpectation(\"as\", false);\n  const peg$e6 = peg$literalExpectation(\"{\", false);\n  const peg$e7 = peg$literalExpectation(\"}\", false);\n  const peg$e8 = peg$literalExpectation(\"from\", false);\n  const peg$e9 = peg$literalExpectation(\"=\", false);\n  const peg$e10 = peg$literalExpectation(\"/\", false);\n  const peg$e11 = peg$literalExpectation(\"@\", false);\n  const peg$e12 = peg$literalExpectation(\":\", false);\n  const peg$e13 = peg$classExpectation([\"!\", \"$\", \"&\"], false, false, false);\n  const peg$e14 = peg$classExpectation([[\"*\", \"+\"], \"?\"], false, false, false);\n  const peg$e15 = peg$literalExpectation(\"|\", false);\n  const peg$e16 = peg$literalExpectation(\"..\", false);\n  const peg$e17 = peg$literalExpectation(\"(\", false);\n  const peg$e18 = peg$literalExpectation(\")\", false);\n  const peg$e19 = peg$literalExpectation(\".\", false);\n  const peg$e20 = peg$classExpectation([\"!\", \"&\"], false, false, false);\n  const peg$e21 = peg$classExpectation([[\"\\0\", \"\\uD7FF\"], [\"\\uE000\", \"\\uFFFF\"]], false, false, false);\n  const peg$e22 = peg$classExpectation([[\"\\uD800\", \"\\uDBFF\"]], false, false, false);\n  const peg$e23 = peg$classExpectation([[\"\\uDC00\", \"\\uDFFF\"]], false, false, false);\n  const peg$e24 = peg$classExpectation([[\"\\uD800\", \"\\uDFFF\"]], false, false, false);\n  const peg$e25 = peg$otherExpectation(\"whitespace\");\n  const peg$e26 = peg$classExpectation([\"\\t\", [\"\\v\", \"\\f\"], \" \", \"\\\\p{Zs}\", \"\\xA0\", \"\\uFEFF\"], false, false, true);\n  const peg$e27 = peg$classExpectation([\"\\n\", \"\\r\", \"\\u2028\", \"\\u2029\"], false, false, false);\n  const peg$e28 = peg$otherExpectation(\"end of line\");\n  const peg$e29 = peg$literalExpectation(\"\\n\", false);\n  const peg$e30 = peg$literalExpectation(\"\\r\\n\", false);\n  const peg$e31 = peg$classExpectation([\"\\r\", [\"\\u2028\", \"\\u2029\"]], false, false, false);\n  const peg$e32 = peg$otherExpectation(\"comment\");\n  const peg$e33 = peg$literalExpectation(\"/*\", false);\n  const peg$e34 = peg$literalExpectation(\"*/\", false);\n  const peg$e35 = peg$literalExpectation(\"//\", false);\n  const peg$e36 = peg$otherExpectation(\"identifier\");\n  const peg$e37 = peg$classExpectation([\"\\\\p{ID_Start}\", \"_\"], false, false, true);\n  const peg$e38 = peg$literalExpectation(\"\\\\\", false);\n  const peg$e39 = peg$classExpectation([\"$\", \"\\\\p{ID_Continue}\"], false, false, true);\n  const peg$e40 = peg$otherExpectation(\"literal\");\n  const peg$e41 = peg$literalExpectation(\"i\", false);\n  const peg$e42 = peg$otherExpectation(\"string\");\n  const peg$e43 = peg$literalExpectation(\"\\\"\", false);\n  const peg$e44 = peg$literalExpectation(\"'\", false);\n  const peg$e45 = peg$classExpectation([\"\\n\", \"\\r\", \"\\\"\", \"\\\\\", [\"\\u2028\", \"\\u2029\"]], false, false, false);\n  const peg$e46 = peg$classExpectation([\"\\n\", \"\\r\", \"'\", \"\\\\\", [\"\\u2028\", \"\\u2029\"]], false, false, false);\n  const peg$e47 = peg$otherExpectation(\"character class\");\n  const peg$e48 = peg$literalExpectation(\"[\", false);\n  const peg$e49 = peg$literalExpectation(\"^\", false);\n  const peg$e50 = peg$literalExpectation(\"]\", false);\n  const peg$e51 = peg$literalExpectation(\"p\", true);\n  const peg$e52 = peg$literalExpectation(\"_\", false);\n  const peg$e53 = peg$classExpectation([[\"a\", \"z\"]], false, true, false);\n  const peg$e54 = peg$literalExpectation(\"u\", false);\n  const peg$e55 = peg$literalExpectation(\"-\", false);\n  const peg$e56 = peg$classExpectation([\"\\n\", \"\\r\", [\"\\\\\", \"]\"], [\"\\u2028\", \"\\u2029\"]], false, false, false);\n  const peg$e57 = peg$literalExpectation(\"0\", false);\n  const peg$e58 = peg$classExpectation([\"\\\"\", \"'\", \"\\\\\"], false, false, false);\n  const peg$e59 = peg$literalExpectation(\"b\", false);\n  const peg$e60 = peg$literalExpectation(\"f\", false);\n  const peg$e61 = peg$literalExpectation(\"n\", false);\n  const peg$e62 = peg$literalExpectation(\"r\", false);\n  const peg$e63 = peg$literalExpectation(\"t\", false);\n  const peg$e64 = peg$literalExpectation(\"v\", false);\n  const peg$e65 = peg$classExpectation([[\"0\", \"9\"], \"p\", \"u\", \"x\"], false, false, false);\n  const peg$e66 = peg$literalExpectation(\"x\", false);\n  const peg$e67 = peg$classExpectation([[\"0\", \"9\"]], false, false, false);\n  const peg$e68 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"]], false, true, false);\n  const peg$e69 = peg$otherExpectation(\"code block\");\n  const peg$e70 = peg$classExpectation([\"{\", \"}\"], false, false, false);\n\n  function peg$f0(imports, topLevelInitializer, initializer, rules) {\n    return {\n      type: \"grammar\",\n      imports,\n      topLevelInitializer,\n      initializer,\n      rules,\n      location: location(),\n    };\n  }\n  function peg$f1(imports, body) {\n    return [imports, body];\n  }\n  function peg$f2(code) {\n    return {\n      type: \"top_level_initializer\",\n      code,\n      codeLocation: location(),\n    };\n  }\n  function peg$f3(code) {\n    return {\n      type: \"top_level_initializer\",\n      code,\n      codeLocation: location(),\n    };\n  }\n  function peg$f4(what, from) {\n    return {\n      type: \"grammar_import\", what, from, location: location(),\n    };\n  }\n  function peg$f5(from) {\n    return {\n      type: \"grammar_import\", what: [], from, location: location(),\n    };\n  }\n  function peg$f6(first, others) {\n    if (!others) {\n      return [first];\n    }\n    // 'others' is always an array.\n    others.unshift(first);\n    return others;\n  }\n  function peg$f7(binding) {\n    return {\n      type: \"import_binding_default\",\n      binding: binding[0],\n      location: binding[1],\n    };\n  }\n  function peg$f8(binding) {\n    return [{\n      type: \"import_binding_all\",\n      binding: binding[0],\n      location: binding[1],\n    }];\n  }\n  function peg$f9() {    return [];  }\n  function peg$f10(rename, binding) {\n    return {\n      type: \"import_binding_rename\",\n      rename: rename[0],\n      renameLocation: rename[1],\n      binding: binding[0],\n      location: binding[1],\n    };\n  }\n  function peg$f11(binding) {\n    return {\n      type: \"import_binding\",\n      binding: binding[0],\n      location: binding[1],\n    };\n  }\n  function peg$f12(module) {\n    return { type: \"import_module_specifier\", module, location: location() };\n  }\n  function peg$f13(id) {    return [id, location()];  }\n  function peg$f14(id) {    return [id, location()];  }\n  function peg$f15(id) {\n    if (reservedWords.has(id[0])) {\n      error(`Binding identifier can't be a reserved word \"${id[0]}\"`, id[1]);\n    }\n    return id[0];\n  }\n  function peg$f16(code) {\n    return {\n      type: \"top_level_initializer\",\n      code: code[0],\n      codeLocation: code[1],\n      location: location(),\n    };\n  }\n  function peg$f17(code) {\n    return {\n      type: \"initializer\",\n      code: code[0],\n      codeLocation: code[1],\n      location: location(),\n    };\n  }\n  function peg$f18(name, displayName, expression) {\n    return {\n      type: \"rule\",\n      name: name[0],\n      nameLocation: name[1],\n      expression: displayName !== null\n        ? {\n            type: \"named\",\n            name: displayName,\n            expression,\n            location: location(),\n          }\n        : expression,\n      location: location(),\n    };\n  }\n  function peg$f19(head, tail) {\n    return tail.length > 0\n      ? {\n          type: \"choice\",\n          alternatives: [head].concat(tail),\n          location: location(),\n        }\n      : head;\n  }\n  function peg$f20(expression, code) {\n    return code !== null\n      ? {\n          type: \"action\",\n          expression,\n          code: code[0],\n          codeLocation: code[1],\n          location: location(),\n        }\n      : expression;\n  }\n  function peg$f21(head, tail) {\n    return ((tail.length > 0) || (head.type === \"labeled\" && head.pick))\n      ? {\n          type: \"sequence\",\n          elements: [head].concat(tail),\n          location: location(),\n        }\n      : head;\n  }\n  function peg$f22(pluck, label, expression) {\n    if (expression.type.startsWith(\"semantic_\")) {\n      error(\"\\\"@\\\" cannot be used on a semantic predicate\", pluck);\n    }\n    return {\n      type: \"labeled\",\n      label: label !== null ? label[0] : null,\n      // Use location of \"@\" if label is unavailable\n      labelLocation: label !== null ? label[1] : pluck,\n      pick: true,\n      expression,\n      location: location(),\n    };\n  }\n  function peg$f23(label, expression) {\n    return {\n      type: \"labeled\",\n      label: label[0],\n      labelLocation: label[1],\n      expression,\n      location: location(),\n    };\n  }\n  function peg$f24() {    return location();  }\n  function peg$f25(label) {\n    if (reservedWords.has(label[0])) {\n      error(`Label can't be a reserved word \"${label[0]}\"`, label[1]);\n    }\n\n    return label;\n  }\n  function peg$f26(operator, expression) {\n    return {\n      type: OPS_TO_PREFIXED_TYPES[operator],\n      expression,\n      location: location(),\n    };\n  }\n  function peg$f27(expression, operator) {\n    return {\n      type: OPS_TO_SUFFIXED_TYPES[operator],\n      expression,\n      location: location(),\n    };\n  }\n  function peg$f28(expression, boundaries, delimiter) {\n    const min = boundaries[0];\n    const max = boundaries[1];\n    if (max.type === \"constant\" && max.value === 0) {\n      error(\"The maximum count of repetitions of the rule must be > 0\", max.location);\n    }\n\n    return {\n      type: \"repeated\",\n      min,\n      max,\n      expression,\n      delimiter,\n      location: location(),\n    };\n  }\n  function peg$f29(min, max) {\n    return [\n      min !== null ? min : { type: \"constant\", value: 0 },\n      max !== null ? max : { type: \"constant\", value: null },\n    ];\n  }\n  function peg$f30(exact) {    return [null, exact];  }\n  function peg$f31(value) {    return { type: \"constant\", value, location: location() };  }\n  function peg$f32(value) {    return { type: \"variable\", value: value[0], location: location() };  }\n  function peg$f33(value) {\n    return {\n      type: \"function\",\n      value: value[0],\n      codeLocation: value[1],\n      location: location(),\n    };\n  }\n  function peg$f34(expression) {\n    // The purpose of the \"group\" AST node is just to isolate label scope. We\n    // don't need to put it around nodes that can't contain any labels or\n    // nodes that already isolate label scope themselves. This leaves us with\n    // \"labeled\" and \"sequence\".\n    return expression.type === \"labeled\" || expression.type === \"sequence\"\n      ? { type: \"group\", expression, location: location() }\n      : expression;\n  }\n  function peg$f35(library, name) {\n    return {\n      type: \"library_ref\",\n      name: name[0],\n      library: library[0],\n      libraryNumber: -1,\n      location: location(),\n    };\n  }\n  function peg$f36(name) {\n    return { type: \"rule_ref\", name: name[0], location: location() };\n  }\n  function peg$f37(operator, code) {\n    return {\n      type: OPS_TO_SEMANTIC_PREDICATE_TYPES[operator],\n      code: code[0],\n      codeLocation: code[1],\n      location: location(),\n    };\n  }\n  function peg$f38(head, tail) {\n    return [head + tail.join(\"\"), location()];\n  }\n  function peg$f39(value, ignoreCase) {\n    return {\n      type: \"literal\",\n      value,\n      ignoreCase: ignoreCase !== null,\n      location: location(),\n    };\n  }\n  function peg$f40(chars) {    return chars.join(\"\");  }\n  function peg$f41(chars) {    return chars.join(\"\");  }\n  function peg$f42(inverted, parts, flags) {\n    // [^]u is like . but for a codepoint: not-nothing.\n    if (inverted && (parts.length === 0)) {\n      if (flags.unicode) {\n        parts = [[\"\\ud800\", \"\\udfff\"]];\n      } else {\n        return {\n          type: \"any\",\n          location: location(),\n        };\n      }\n    }\n    return {\n      type: \"class\",\n      parts: parts.filter(part => part !== \"\"),\n      inverted: Boolean(inverted),\n      ignoreCase: Boolean(flags.ignoreCase),\n      location: location(),\n      unicode: Boolean(flags.unicode) || parts.flat().some(\n        c => ((typeof c === \"object\") && c.unicode) || (c.codePointAt(0) > 0xffff)\n      ),\n    };\n  }\n  function peg$f43(value) {\n    try {\n      new RegExp(`[\\\\${value}]`, \"u\");\n    } catch (er) {\n      error(\"Invalid Unicode property escape\");\n    }\n    return {\n      type: \"classEscape\",\n      value,\n      unicode: true,\n      location: location(),\n    };\n  }\n  function peg$f44(flags) {\n    const ret = Object.fromEntries(flags);\n    if (Object.keys(ret).length !== flags.length) {\n      error(\"Invalid flags\");\n    }\n    return ret;\n  }\n  function peg$f45() {    return [\"ignoreCase\", true];  }\n  function peg$f46() {    return [\"unicode\", true];  }\n  function peg$f47(begin, end) {\n    if (begin.codePointAt(0) > end.codePointAt(0)) {\n      error(\n        \"Invalid character range: \" + text() + \".\"\n      );\n    }\n\n    return [begin, end];\n  }\n  function peg$f48() {    return \"\";  }\n  function peg$f49() {    return \"\\0\";  }\n  function peg$f50() {    return \"\\b\";  }\n  function peg$f51() {    return \"\\f\";  }\n  function peg$f52() {    return \"\\n\";  }\n  function peg$f53() {    return \"\\r\";  }\n  function peg$f54() {    return \"\\t\";  }\n  function peg$f55() {    return \"\\v\";  }\n  function peg$f56(digits) {\n    return String.fromCharCode(parseInt(digits, 16));\n  }\n  function peg$f57(digits) {\n    return String.fromCharCode(parseInt(digits, 16));\n  }\n  function peg$f58(digits) {\n    return String.fromCodePoint(parseInt(digits, 16));\n  }\n  function peg$f59() {    return { type: \"any\", location: location() };  }\n  function peg$f60(code) {    return [code, location()];  }\n  function peg$f61(digits) {    return parseInt(digits, 10);  }\n  let peg$currPos = options.peg$currPos | 0;\n  let peg$savedPos = peg$currPos;\n  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  let peg$maxFailPos = peg$currPos;\n  let peg$maxFailExpected = options.peg$maxFailExpected || [];\n  let peg$silentFails = options.peg$silentFails | 0;\n\n  let peg$result;\n\n  if (options.startRule) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos,\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$getUnicode(pos = peg$currPos) {\n    const cp = input.codePointAt(pos);\n    if (cp === undefined) {\n      return \"\";\n    }\n    return String.fromCodePoint(cp);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text, ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase, unicode) {\n    return { type: \"class\", parts, inverted, ignoreCase, unicode };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description };\n  }\n\n  function peg$computePosDetails(pos) {\n    let details = peg$posDetailsCache[pos];\n    let p;\n\n    if (details) {\n      return details;\n    } else {\n      if (pos >= peg$posDetailsCache.length) {\n        p = peg$posDetailsCache.length - 1;\n      } else {\n        p = pos;\n        while (!peg$posDetailsCache[--p]) {}\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column,\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    const startPosDetails = peg$computePosDetails(startPos);\n    const endPosDetails = peg$computePosDetails(endPos);\n\n    const res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column,\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column,\n      },\n    };\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\n      res.start = peg$source.offset(res.start);\n      res.end = peg$source.offset(res.end);\n    }\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseGrammar() {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parseImportDeclarations();\n    s2 = peg$currPos;\n    s3 = peg$parse__();\n    s4 = peg$parseTopLevelInitializer();\n    if (s4 !== peg$FAILED) {\n      s2 = s4;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$currPos;\n    s4 = peg$parse__();\n    s5 = peg$parseInitializer();\n    if (s5 !== peg$FAILED) {\n      s3 = s5;\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    s4 = peg$parse__();\n    s5 = [];\n    s6 = peg$currPos;\n    s7 = peg$parseRule();\n    if (s7 !== peg$FAILED) {\n      s8 = peg$parse__();\n      s6 = s7;\n    } else {\n      peg$currPos = s6;\n      s6 = peg$FAILED;\n    }\n    if (s6 !== peg$FAILED) {\n      while (s6 !== peg$FAILED) {\n        s5.push(s6);\n        s6 = peg$currPos;\n        s7 = peg$parseRule();\n        if (s7 !== peg$FAILED) {\n          s8 = peg$parse__();\n          s6 = s7;\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n      }\n    } else {\n      s5 = peg$FAILED;\n    }\n    if (s5 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f0(s1, s2, s3, s5);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseImportsAndSource() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseImportsAsText();\n    s2 = peg$parseGrammarBody();\n    peg$savedPos = s0;\n    s0 = peg$f1(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parseGrammarBody() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    if (input.length > peg$currPos) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n    }\n    s1 = input.substring(s1, peg$currPos);\n    peg$savedPos = s0;\n    s1 = peg$f2(s1);\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseImportsAsText() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseImportDeclarations();\n    s1 = input.substring(s1, peg$currPos);\n    peg$savedPos = s0;\n    s1 = peg$f3(s1);\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseImportDeclarations() {\n    let s0, s1;\n\n    s0 = [];\n    s1 = peg$parseImportDeclaration();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseImportDeclaration();\n    }\n\n    return s0;\n  }\n\n  function peg$parseImportDeclaration() {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (input.substr(peg$currPos, 6) === peg$c0) {\n      s2 = peg$c0;\n      peg$currPos += 6;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      s4 = peg$parseImportClause();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse__();\n        s6 = peg$parseFromClause();\n        if (s6 !== peg$FAILED) {\n          s7 = peg$currPos;\n          s8 = peg$parse__();\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s9 = peg$c1;\n            peg$currPos++;\n          } else {\n            s9 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s9 !== peg$FAILED) {\n            s8 = [s8, s9];\n            s7 = s8;\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          if (s7 === peg$FAILED) {\n            s7 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f4(s4, s6);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (input.substr(peg$currPos, 6) === peg$c0) {\n        s2 = peg$c0;\n        peg$currPos += 6;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        s4 = peg$parseModuleSpecifier();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          s6 = peg$parse__();\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s7 = peg$c1;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f5(s4);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseImportClause() {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$parseNameSpaceImport();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNamedImports();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseImportedDefaultBinding();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = peg$parse__();\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c2;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse__();\n            s6 = peg$parseNameSpaceImport();\n            if (s6 === peg$FAILED) {\n              s6 = peg$parseNamedImports();\n            }\n            if (s6 !== peg$FAILED) {\n              s2 = s6;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f6(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseImportedDefaultBinding() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseImportedBinding();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f7(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseNameSpaceImport() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s1 = peg$c3;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (input.substr(peg$currPos, 2) === peg$c4) {\n        s3 = peg$c4;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e5); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parseImportedBinding();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s5);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNamedImports() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c6;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f9();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        s3 = peg$parseImportsList();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          s5 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s6 = peg$c2;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parse__();\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s6 = peg$c6;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e7); }\n          }\n          if (s6 !== peg$FAILED) {\n            s0 = s3;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseFromClause() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c7) {\n      s1 = peg$c7;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseModuleSpecifier();\n      if (s3 !== peg$FAILED) {\n        s0 = s3;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseImportsList() {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseImportSpecifier();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s5 = peg$c2;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s4 = [s4, s5, s6];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parseImportSpecifier();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseImportSpecifier() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseModuleExportName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (input.substr(peg$currPos, 2) === peg$c4) {\n        s3 = peg$c4;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e5); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parseImportedBinding();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f10(s1, s5);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseImportedBinding();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f11(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseModuleSpecifier() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseStringLiteral();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f12(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseImportedBinding() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseBindingIdentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f13(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseModuleExportName() {\n    let s0, s1;\n\n    s0 = peg$parseIdentifierName();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseStringLiteral();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseBindingIdentifier() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f15(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseTopLevelInitializer() {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseCodeBlock();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s3 = peg$c6;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e7); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseEOS();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f16(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInitializer() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCodeBlock();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseEOS();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseRule() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$currPos;\n      s4 = peg$parseStringLiteral();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse__();\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s4 = peg$c8;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse__();\n        s6 = peg$parseChoiceExpression();\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parseEOS();\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f18(s1, s3, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChoiceExpression() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseActionExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s5 = peg$c9;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e10); }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseActionExpression();\n        if (s7 !== peg$FAILED) {\n          s3 = s7;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s5 = peg$c9;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e10); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseActionExpression();\n          if (s7 !== peg$FAILED) {\n            s3 = s7;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f19(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseActionExpression() {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSequenceExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse__();\n      s4 = peg$parseCodeBlock();\n      if (s4 !== peg$FAILED) {\n        s2 = s4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f20(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSequenceExpression() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLabeledExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseLabeledExpression();\n      if (s5 !== peg$FAILED) {\n        s3 = s5;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseLabeledExpression();\n        if (s5 !== peg$FAILED) {\n          s3 = s5;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f21(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLabeledExpression() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePluck();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLabelColon();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsePrefixedExpression();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f22(s1, s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseLabelColon();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsePrefixedExpression();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f23(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsePrefixedExpression();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePluck() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 64) {\n      s1 = peg$c10;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f24();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLabelColon() {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s3 = peg$c11;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e12); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        peg$savedPos = s0;\n        s0 = peg$f25(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrefixedExpression() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrefixedOperator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseSuffixedExpression();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f26(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSuffixedExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrefixedOperator() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r0.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSuffixedExpression() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrimaryExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseSuffixedOperator();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f27(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseRepeatedExpression();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsePrimaryExpression();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSuffixedOperator() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r1.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseRepeatedExpression() {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrimaryExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (input.charCodeAt(peg$currPos) === 124) {\n        s3 = peg$c12;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e15); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parseBoundaries();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parse__();\n            s10 = peg$parseChoiceExpression();\n            if (s10 !== peg$FAILED) {\n              s11 = peg$parse__();\n              s7 = s10;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          if (s7 === peg$FAILED) {\n            s7 = null;\n          }\n          if (input.charCodeAt(peg$currPos) === 124) {\n            s8 = peg$c12;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e15); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f28(s1, s5, s7);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseBoundaries() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseBoundary();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parse__();\n    if (input.substr(peg$currPos, 2) === peg$c13) {\n      s3 = peg$c13;\n      peg$currPos += 2;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n    }\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parse__();\n      s5 = peg$parseBoundary();\n      if (s5 === peg$FAILED) {\n        s5 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f29(s1, s5);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseBoundary();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f30(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseBoundary() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseInteger();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f31(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseIdentifierName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f32(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseCodeBlock();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f33(s1);\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrimaryExpression() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$parseLiteralMatcher();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseCharacterClassMatcher();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseAnyMatcher();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseRuleReferenceExpression();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseSemanticPredicateExpression();\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s1 = peg$c14;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e17); }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parse__();\n                s3 = peg$parseChoiceExpression();\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse__();\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c15;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e18); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f34(s3);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseRuleReferenceExpression() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s2 = peg$c16;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e19); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseIdentifierName();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f35(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseIdentifierName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$currPos;\n        s6 = peg$parseStringLiteral();\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parse__();\n          s6 = [s6, s7];\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          s5 = null;\n        }\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s6 = peg$c8;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e9); }\n        }\n        if (s6 !== peg$FAILED) {\n          s4 = [s4, s5, s6];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = undefined;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f36(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSemanticPredicateExpression() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSemanticPredicateOperator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseCodeBlock();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f37(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSemanticPredicateOperator() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r2.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSourceCharacter() {\n    let s0;\n\n    s0 = peg$parseSourceCharacterLow();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSourceCharacterHigh();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSourceCharacterLow() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r3.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSourceCharacterHigh() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = input.charAt(peg$currPos);\n    if (peg$r4.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = input.charAt(peg$currPos);\n      if (peg$r5.test(s3)) {\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e23); }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = input.charAt(peg$currPos);\n      if (peg$r6.test(s0)) {\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e24); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseWhiteSpace() {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$getUnicode();\n    if (peg$r7.test(s0)) {\n      peg$currPos += s0.length;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e26); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e25); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminator() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r8.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e27); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminatorSequence() {\n    let s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 10) {\n      s0 = peg$c17;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e29); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c18) {\n        s0 = peg$c18;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e30); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = input.charAt(peg$currPos);\n        if (peg$r9.test(s0)) {\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e31); }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e28); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseComment() {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseMultiLineComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSingleLineComment();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e32); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiLineComment() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c19) {\n      s1 = peg$c19;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c20) {\n        s5 = peg$c20;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e34); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c20) {\n          s5 = peg$c20;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e34); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.substr(peg$currPos, 2) === peg$c20) {\n        s3 = peg$c20;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e34); }\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiLineCommentNoLineTerminator() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c19) {\n      s1 = peg$c19;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c20) {\n        s5 = peg$c20;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e34); }\n      }\n      if (s5 === peg$FAILED) {\n        s5 = peg$parseLineTerminator();\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c20) {\n          s5 = peg$c20;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e34); }\n        }\n        if (s5 === peg$FAILED) {\n          s5 = peg$parseLineTerminator();\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.substr(peg$currPos, 2) === peg$c20) {\n        s3 = peg$c20;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e34); }\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleLineComment() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c21) {\n      s1 = peg$c21;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e35); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseLineTerminator();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseLineTerminator();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierName() {\n    let s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierStart();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseIdentifierPart();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseIdentifierPart();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f38(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e36); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierStart() {\n    let s0, s1, s2;\n\n    s0 = peg$getUnicode();\n    if (peg$r10.test(s0)) {\n      peg$currPos += s0.length;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e37); }\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e38); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseUnicodeEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          s0 = s2;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierPart() {\n    let s0;\n\n    s0 = peg$getUnicode();\n    if (peg$r11.test(s0)) {\n      peg$currPos += s0.length;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e39); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLiteralMatcher() {\n    let s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseStringLiteral();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 105) {\n        s2 = peg$c23;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e41); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f39(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e40); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringLiteral() {\n    let s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c24;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e43); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseDoubleStringCharacter();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseDoubleStringCharacter();\n      }\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s3 = peg$c24;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e43); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f40(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c25;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e44); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSingleStringCharacter();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSingleStringCharacter();\n        }\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s3 = peg$c25;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e44); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f41(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e42); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseDoubleStringCharacter() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = input.charAt(peg$currPos);\n    if (peg$r12.test(s3)) {\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e45); }\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e38); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          s0 = s2;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleStringCharacter() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = input.charAt(peg$currPos);\n    if (peg$r13.test(s3)) {\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e46); }\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e38); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          s0 = s2;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterClassMatcher() {\n    let s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c26;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e48); }\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s2 = peg$c27;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e49); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parseAtomEscape();\n      if (s4 === peg$FAILED) {\n        s4 = peg$parseClassCharacterRange();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseClassCharacter();\n        }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parseAtomEscape();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseClassCharacterRange();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parseClassCharacter();\n          }\n        }\n      }\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s4 = peg$c28;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e50); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseClassFlags();\n        peg$savedPos = s0;\n        s0 = peg$f42(s2, s3, s5);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e47); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAtomEscape() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c22;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e38); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseCharacterClassEscape();\n      if (s2 !== peg$FAILED) {\n        s0 = s2;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterClassEscape() {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = input.charAt(peg$currPos);\n    if (s3.toLowerCase() === peg$c29) {\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e51); }\n    }\n    if (s3 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s4 = peg$c5;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseUnicodePropertyValueExpression();\n        if (s5 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s6 = peg$c6;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e7); }\n          }\n          if (s6 !== peg$FAILED) {\n            s3 = [s3, s4, s5, s6];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f43(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseUnicodePropertyValueExpression() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseUnicodePropertyName();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s2 = peg$c8;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseUnicodePropertyValue();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseLoneUnicodePropertyNameOrValue();\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodePropertyName() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseUnicodePropertyNameCharacter();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseUnicodePropertyNameCharacter();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodePropertyValue() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseUnicodePropertyValueCharacter();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseUnicodePropertyValueCharacter();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLoneUnicodePropertyNameOrValue() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseUnicodePropertyValueCharacter();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseUnicodePropertyValueCharacter();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodePropertyValueCharacter() {\n    let s0;\n\n    s0 = peg$parseUnicodePropertyNameCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseDecimalDigit();\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodePropertyNameCharacter() {\n    let s0;\n\n    s0 = peg$parseAsciiLetter();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 95) {\n        s0 = peg$c30;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e52); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAsciiLetter() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r14.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e53); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassFlags() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseClassFlag();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseClassFlag();\n    }\n    peg$savedPos = s0;\n    s1 = peg$f44(s1);\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseClassFlag() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 105) {\n      s1 = peg$c23;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e41); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f45();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 117) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e54); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f46();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacterRange() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseClassCharacter();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s2 = peg$c32;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e55); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseClassCharacter();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f47(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacter() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = input.charAt(peg$currPos);\n    if (peg$r15.test(s3)) {\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e56); }\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e38); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          s0 = s2;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineContinuation() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c22;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e38); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLineTerminatorSequence();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f48();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeSequence() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$parseCharacterEscapeSequence();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c33;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e57); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parseDecimalDigit();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = undefined;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f49();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseHexEscapeSequence();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseUnicodeEscapeSequence();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterEscapeSequence() {\n    let s0;\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNonEscapeCharacter();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleEscapeCharacter() {\n    let s0, s1;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r16.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e58); }\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 98) {\n        s1 = peg$c34;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e59); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f50();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 102) {\n          s1 = peg$c35;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e60); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f51();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 110) {\n            s1 = peg$c36;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e61); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f52();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 114) {\n              s1 = peg$c37;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e62); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f53();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 116) {\n                s1 = peg$c38;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e63); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$f54();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 118) {\n                  s1 = peg$c39;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e64); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$f55();\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNonEscapeCharacter() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = peg$parseEscapeCharacter();\n    if (s3 === peg$FAILED) {\n      s3 = peg$parseLineTerminator();\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeCharacter() {\n    let s0;\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = input.charAt(peg$currPos);\n      if (peg$r17.test(s0)) {\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e65); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexEscapeSequence() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 120) {\n      s1 = peg$c40;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e66); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f56(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeEscapeSequence() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 117) {\n      s1 = peg$c31;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e54); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseHexDigit();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseHexDigit();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f57(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 117) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e54); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s2 = peg$c5;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e6); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          s5 = peg$parseHexDigit();\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseHexDigit();\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s4 = peg$c6;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e7); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f58(s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseDecimalDigit() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r18.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e67); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexDigit() {\n    let s0;\n\n    s0 = input.charAt(peg$currPos);\n    if (peg$r19.test(s0)) {\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e68); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAnyMatcher() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c16;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f59();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseCodeBlock() {\n    let s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseBareCodeBlock();\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c6;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = s2;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e69); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseBareCodeBlock() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCode();\n    peg$savedPos = s0;\n    s1 = peg$f60(s1);\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseCode() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = [];\n    s3 = peg$currPos;\n    s4 = peg$currPos;\n    peg$silentFails++;\n    s5 = input.charAt(peg$currPos);\n    if (peg$r20.test(s5)) {\n      peg$currPos++;\n    } else {\n      s5 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e70); }\n    }\n    peg$silentFails--;\n    if (s5 === peg$FAILED) {\n      s4 = undefined;\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parseSourceCharacter();\n      if (s5 !== peg$FAILED) {\n        s4 = [s4, s5];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = input.charAt(peg$currPos);\n        if (peg$r20.test(s5)) {\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e70); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s3 = peg$c5;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseCode();\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s5 = peg$c6;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e7); }\n        }\n        if (s5 !== peg$FAILED) {\n          s3 = [s3, s4, s5];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = input.charAt(peg$currPos);\n      if (peg$r20.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e70); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = input.charAt(peg$currPos);\n          if (peg$r20.test(s5)) {\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e70); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = undefined;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseSourceCharacter();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s3 = peg$c5;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e6); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCode();\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c6;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e7); }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    }\n    s0 = input.substring(s0, peg$currPos);\n\n    return s0;\n  }\n\n  function peg$parseInteger() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parseDecimalDigit();\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseDecimalDigit();\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f61(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    let s0, s1;\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseLineTerminatorSequence();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment();\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseLineTerminatorSequence();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    let s0, s1;\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseMultiLineCommentNoLineTerminator();\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseMultiLineCommentNoLineTerminator();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOS() {\n    let s0, s1, s2, s3;\n\n    s0 = [];\n    s1 = peg$currPos;\n    s2 = peg$parse__();\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s3 = peg$c1;\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s3 !== peg$FAILED) {\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$currPos;\n        s2 = peg$parse__();\n        if (input.charCodeAt(peg$currPos) === 59) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      s2 = peg$parseSingleLineComment();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parseLineTerminatorSequence();\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        s2 = peg$parseEOF();\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOF() {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n  const reservedWords = new Set(options.reservedWords);\n\n  peg$result = peg$startRuleFunction();\n\n  const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);\n  function peg$throw() {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n  if (options.peg$library) {\n    return /** @type {any} */ ({\n      peg$result,\n      peg$currPos,\n      peg$FAILED,\n      peg$maxFailExpected,\n      peg$maxFailPos,\n      peg$success,\n      peg$throw: peg$success ? undefined : peg$throw,\n    });\n  }\n  if (peg$success) {\n    return peg$result;\n  } else {\n    peg$throw();\n  }\n}\n\nmodule.exports = {\n  StartRules: [\"Grammar\", \"ImportsAndSource\"],\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse,\n};\n","// @ts-check\n\"use strict\";\n\nconst asts = require(\"../asts\");\nconst op = require(\"../opcodes\");\nconst Stack = require(\"../stack\");\nconst { version } = require(\"../../version\");\nconst { stringEscape, regexpClassEscape } = require(\"../utils\");\nconst { SourceNode } = require(\"source-map-generator\");\nconst GrammarLocation = require(\"../../grammar-location\");\nconst { parse } = require(\"../../parser.js\");\n\n/**\n * @typedef {import(\"../../peg\")} PEG\n */\n\n/**\n * Converts source text from the grammar into the `source-map` object\n *\n * @param {string} code Multiline string with source code\n * @param {PEG.LocationRange} location\n *        Location that represents code block in the grammar\n * @param {string} [name] Name of the code chunk\n *\n * @returns {SourceNode} New node that represents code chunk.\n *          Code will be splitted by lines if necessary\n */\nfunction toSourceNode(code, location, name) {\n  const start = GrammarLocation.offsetStart(location);\n  const line = start.line;\n  // `source-map` columns are 0-based, peggy columns is 1-based\n  const column = start.column - 1;\n  const lines = code.split(\"\\n\");\n\n  if (lines.length === 1) {\n    return new SourceNode(\n      line, column, String(location.source), code, name\n    );\n  }\n\n  return new SourceNode(\n    null, null, String(location.source), lines.map((l, i) => new SourceNode(\n      line + i,\n      i === 0 ? column : 0,\n      String(location.source),\n      i === lines.length - 1 ? l : [l, \"\\n\"],\n      name\n    ))\n  );\n}\n\n/**\n * Wraps code line that consists from three parts into `SourceNode`.\n *\n * @param {string} prefix String that will be prepended before mapped chunk\n * @param {string} chunk Chunk for mapping (possible multiline)\n * @param {PEG.LocationRange} location\n *        Location that represents chunk in the grammar\n * @param {string} suffix String that will be appended after mapped chunk\n * @param {string} [name] Name of the code chunk\n *\n * @returns {SourceNode} New node that represents code chunk.\n *          Code will be splitted by lines if necessary\n */\nfunction wrapInSourceNode(prefix, chunk, location, suffix, name) {\n  // If location is not defined (for example, AST node was replaced\n  // by a plugin and does not provide location information, see\n  // plugin-api.spec.js/\"can replace parser\") returns original chunk\n  if (location) {\n    const end = GrammarLocation.offsetEnd(location);\n    return new SourceNode(null, null, String(location.source), [\n      prefix,\n      toSourceNode(chunk, location, name),\n      // Mark end location with column information otherwise\n      // mapping will be always continue to the end of line\n      new SourceNode(\n        end.line,\n        // `source-map` columns are 0-based, peggy columns is 1-based\n        end.column - 1,\n        String(location.source),\n        suffix\n      ),\n    ]);\n  }\n\n  return new SourceNode(null, null, null, [prefix, chunk, suffix]);\n}\n\n/**\n * @typedef {(string|SourceNode)[]} SourceArray\n *\n * @typedef {PEG.SourceBuildOptions<PEG.SourceOutputs>} SourceBuildOptions\n * @typedef {object} ExtraOptions\n * @property {PEG.Dependencies} [dependencies]\n * @property {string} [exportVar]\n * @typedef {SourceBuildOptions & ExtraOptions} Options\n */\n/**\n * Generates parser JavaScript code.\n *\n * @param {PEG.ast.Grammar} ast\n * @param {Options} options\n */\nfunction generateJS(ast, options) {\n  if (!ast.literals || !ast.locations || !ast.classes\n      || !ast.expectations || !ast.functions || !ast.importedNames) {\n    throw new Error(\n      \"generateJS: generate bytecode was not called.\"\n    );\n  }\n  const {\n    literals, locations, classes, expectations, functions, importedNames,\n  } = ast;\n  if (!options.allowedStartRules) {\n    throw new Error(\n      \"generateJS: options.allowedStartRules was not set.\"\n    );\n  }\n  const { allowedStartRules } = options;\n  /** @type {PEG.Dependencies} */\n  const dependencies = options.dependencies || {};\n\n  /**\n   * Re-indent beginnings of each line so output is indented no matter what\n   * your grammar indentation preference is.\n   *\n   * @param {string} str\n   * @param {string} [indent = \"\"]\n   * @returns\n   */\n  function reIndent(str, indent = \"\") {\n    const leadingSpace = str.match(/^\\n*([ \\t]+)/);\n    const body = leadingSpace\n      ? str.replace(new RegExp(`^${leadingSpace[1]}`, \"gm\"), indent)\n      : str;\n    return body.replace(/[ \\t]+$/, \"\");\n  }\n\n  /**\n   * @overload\n   * @param {string} code\n   * @returns {string}\n   */\n  /**\n   * @overload\n   * @param {SourceArray} code\n   * @returns {SourceArray}\n   */\n  /**\n   * These only indent non-empty lines to avoid trailing whitespace.\n   * @param {SourceArray} code\n   * @returns {SourceArray}\n   */\n  function indent2(code) {\n    /*\n     * - raw lines (outside of SourceNodes) have implict newlines\n     *   that get inserted at the end of processing, so indent\n     *   should always be applied to the next string.\n     *\n     * - chunks inside SourceNodes are assumed to have explict\n     *   new lines, and often have several chunks on one line.\n     *   we therefore shouldn't indent them, unless we've seen\n     *   an explicit new line, or the previous line was raw.\n     *\n     * So eg:\n     * [\n     *   SourceNode([\"a \", \"b\", \"\\nfoo \"]),\n     *   \"x\",\n     *   \"y\",\n     * ]\n     *\n     * Should end up as\n     * [\n     *   SourceNode([\"  a \", \"b\", \"\\n  foo \"]),\n     *   \"x\",\n     *   \"  y\",\n     * ]\n     *\n     * sawEol, and inSourceNode are used to keep track of when\n     * we should apply the indent.\n     */\n    let sawEol = true;\n    let inSourceNode = 0;\n    /**\n     * @overload\n     * @param {string | SourceNode} code\n     * @returns {string | SourceNode}\n     */\n    /**\n     * @overload\n     * @param {SourceNode} code\n     * @returns {SourceNode}\n     */\n    /**\n     * @overload\n     * @param {SourceNode[]} code\n     * @returns {SourceNode[]}\n     */\n    /**\n     * @overload\n     * @param {SourceArray} code\n     * @returns {SourceArray}\n     */\n    /**\n     * @param {SourceArray | string | SourceNode} code\n     * @returns {SourceArray | string | SourceNode}\n     */\n    function helper(code) {\n      if (Array.isArray(code)) {\n        return code.map(s => helper(s));\n      }\n      if (code instanceof SourceNode) {\n        inSourceNode++;\n        code.children = helper(code.children);\n        inSourceNode--;\n        return code;\n      }\n      if (sawEol) {\n        // There was an immediately prior newline, so\n        // indent at the start of every line\n        code = code.replace(/^(.+)$/gm, \"  $1\");\n      } else {\n        // This line will be appended directly to\n        // the end of the previous one, so only indent\n        // after each contained newline (and only if\n        // there's non-whitespace following the newline)\n        code = code.replace(/\\n(\\s*\\S)/g, \"\\n  $1\");\n      }\n      sawEol = !inSourceNode || code.endsWith(\"\\n\");\n      return code;\n    }\n    return helper(code);\n  }\n  /** @param {number} i */\n  function l(i) { return \"peg$c\" + i; } // |literals[i]| of the abstract machine\n  /** @param {number} i */\n  function r(i) { return \"peg$r\" + i; } // |classes[i]| of the abstract machine\n  /** @param {number} i */\n  function e(i) { return \"peg$e\" + i; } // |expectations[i]| of the abstract machine\n  /** @param {number} i */\n  function f(i) { return \"peg$f\" + i; } // |actions[i]| of the abstract machine\n  /** @param {number} i */\n  function gi(i) { return \"peg$import\" + i; } // |grammar_import[i]|\n\n  /**\n   * Generates name of the function that parses specified rule.\n   * @param {string} name\n   */\n  function name(name) { return \"peg$parse\" + name; }\n\n  function generateTables() {\n    /** @param {string} literal */\n    function buildLiteral(literal) {\n      return \"\\\"\" + stringEscape(literal) + \"\\\"\";\n    }\n\n    /** @param {PEG.ast.GrammarCharacterClass} cls */\n    function buildRegexp(cls) {\n      return \"/^[\"\n        + (cls.inverted ? \"^\" : \"\")\n        + cls.value.map(part => (Array.isArray(part)\n          ? regexpClassEscape(part[0])\n            + \"-\"\n            + regexpClassEscape(part[1])\n          : regexpClassEscape(part))).join(\"\")\n        + \"]/\" + (cls.ignoreCase ? \"i\" : \"\") + (cls.unicode ? \"u\" : \"\");\n    }\n\n    /** @param {PEG.ast.GrammarExpectation} e */\n    function buildExpectation(e) {\n      switch (e.type) {\n        case \"rule\": {\n          return \"peg$otherExpectation(\\\"\" + stringEscape(e.value) + \"\\\")\";\n        }\n        case \"literal\": {\n          return \"peg$literalExpectation(\\\"\"\n                  + stringEscape(e.value)\n                  + \"\\\", \"\n                  + e.ignoreCase\n                  + \")\";\n        }\n        case \"class\": {\n          const parts = e.value.map(part => (Array.isArray(part)\n            ? \"[\\\"\" + stringEscape(part[0]) + \"\\\", \\\"\" + stringEscape(part[1]) + \"\\\"]\"\n            : \"\\\"\"  + stringEscape(part) + \"\\\"\")).join(\", \");\n\n          return \"peg$classExpectation([\"\n                  + parts + \"], \"\n                  + e.inverted + \", \"\n                  + e.ignoreCase + \", \"\n                  + e.unicode\n                  + \")\";\n        }\n        case \"any\": return \"peg$anyExpectation()\";\n        // istanbul ignore next Because we never generate expectation type we cannot reach this branch\n        default: throw new Error(\"Unknown expectation type (\" + JSON.stringify(e) + \")\");\n      }\n    }\n\n    /**\n     * @param {PEG.ast.FunctionConst} a\n     * @param {number} i\n     */\n    function buildFunc(a, i) {\n      return wrapInSourceNode(\n        `\\n  function ${f(i)}(${a.params.join(\", \")}) {`,\n        reIndent(a.body, \"    \"),\n        a.location,\n        \"  }\"\n      );\n    }\n\n    return new SourceNode(\n      null, null, options.grammarSource, [\n        literals.map(\n          (c, i) => \"  const \" + l(i) + \" = \" + buildLiteral(c) + \";\"\n        ).concat(\"\", classes.map(\n          (c, i) => \"  const \" + r(i) + \" = \" + buildRegexp(c) + \";\"\n        )).concat(\"\", expectations.map(\n          (c, i) => \"  const \" + e(i) + \" = \" + buildExpectation(c) + \";\"\n        )).concat(\"\").join(\"\\n\"),\n        ...functions.map(buildFunc),\n      ]\n    );\n  }\n\n  /**\n   * @param {string} ruleNameCode\n   * @param {number} ruleIndexCode\n   */\n  function generateRuleHeader(ruleNameCode, ruleIndexCode) {\n    /** @type {string[]} */\n    const parts = [];\n\n    parts.push(\"\");\n\n    if (options.trace) {\n      parts.push(\n        \"peg$tracer.trace({\",\n        \"  type: \\\"rule.enter\\\",\",\n        \"  rule: \" + ruleNameCode + \",\",\n        \"  location: peg$computeLocation(startPos, startPos, true)\",\n        \"});\",\n        \"\"\n      );\n    }\n\n    if (options.cache) {\n      parts.push(\n        \"const key = peg$currPos * \" + ast.rules.length + \" + \" + ruleIndexCode + \";\",\n        \"const cached = peg$resultsCache[key];\",\n        \"\",\n        \"if (cached) {\",\n        \"  peg$currPos = cached.nextPos;\",\n        \"\"\n      );\n\n      if (options.trace) {\n        parts.push(\n          \"if (cached.result !== peg$FAILED) {\",\n          \"  peg$tracer.trace({\",\n          \"    type: \\\"rule.match\\\",\",\n          \"    rule: \" + ruleNameCode + \",\",\n          \"    result: cached.result,\",\n          \"    location: peg$computeLocation(startPos, peg$currPos, true)\",\n          \"  });\",\n          \"} else {\",\n          \"  peg$tracer.trace({\",\n          \"    type: \\\"rule.fail\\\",\",\n          \"    rule: \" + ruleNameCode + \",\",\n          \"    location: peg$computeLocation(startPos, startPos, true)\",\n          \"  });\",\n          \"}\",\n          \"\"\n        );\n      }\n\n      parts.push(\n        \"  return cached.result;\",\n        \"}\",\n        \"\"\n      );\n    }\n\n    return parts;\n  }\n\n  /**\n   * @param {string} ruleNameCode\n   * @param {string} resultCode\n   */\n  function generateRuleFooter(ruleNameCode, resultCode) {\n    /** @type {string[]} */\n    const parts = [];\n\n    if (options.cache) {\n      parts.push(\n        \"\",\n        \"peg$resultsCache[key] = { nextPos: peg$currPos, result: \" + resultCode + \" };\"\n      );\n    }\n\n    if (options.trace) {\n      parts.push(\n        \"\",\n        \"if (\" + resultCode + \" !== peg$FAILED) {\",\n        \"  peg$tracer.trace({\",\n        \"    type: \\\"rule.match\\\",\",\n        \"    rule: \" + ruleNameCode + \",\",\n        \"    result: \" + resultCode + \",\",\n        \"    location: peg$computeLocation(startPos, peg$currPos, true)\",\n        \"  });\",\n        \"} else {\",\n        \"  peg$tracer.trace({\",\n        \"    type: \\\"rule.fail\\\",\",\n        \"    rule: \" + ruleNameCode + \",\",\n        \"    location: peg$computeLocation(startPos, startPos, true)\",\n        \"  });\",\n        \"}\"\n      );\n    }\n\n    parts.push(\n      \"\",\n      \"return \" + resultCode + \";\"\n    );\n\n    return parts;\n  }\n\n  /** @param {PEG.ast.Rule} rule */\n  function generateRuleFunction(rule) {\n    /** @type {SourceArray} */\n    const parts = [];\n    const bytecode = /** @type {number[]} */(rule.bytecode);\n    const stack = new Stack(rule.name, \"s\", \"let\", bytecode);\n\n    /** @param {number[]} bc */\n    function compile(bc) {\n      let ip = 0;\n      const end = bc.length;\n      const parts = [];\n      // eslint-disable-next-line no-useless-assignment\n      let value = undefined;\n\n      /**\n       * @param {string} cond\n       * @param {number} argCount\n       * @param {((bc: number[])=>SourceArray) | null} [thenFn]\n       */\n      function compileCondition(cond, argCount, thenFn) {\n        const baseLength = argCount + 3;\n        const thenLength = bc[ip + baseLength - 2];\n        const elseLength = bc[ip + baseLength - 1];\n\n        const [thenCode, elseCode] = stack.checkedIf(\n          ip,\n          () => {\n            ip += baseLength + thenLength;\n            return (thenFn || compile)(bc.slice(ip - thenLength, ip));\n          },\n          (elseLength > 0)\n            ? () => {\n                ip += elseLength;\n                return compile(bc.slice(ip - elseLength, ip));\n              }\n            : null\n        );\n\n        parts.push(\"if (\" + cond + \") {\");\n        parts.push(...indent2(thenCode));\n        if (elseLength > 0) {\n          parts.push(\"} else {\");\n          parts.push(...indent2(elseCode));\n        }\n        parts.push(\"}\");\n      }\n\n      /**\n       * Get the code to retrieve an input chunk.  -1 means \"one full Unicode\n       * character\", which might be one or two UTF-16 code units (JS chars).\n       * @param {number} inputChunkLength\n       * @returns {string}\n       */\n      function getChunkCode(inputChunkLength) {\n        switch (inputChunkLength) {\n          case -1:\n            return \"peg$getUnicode()\";\n          case 1:\n            return \"input.charAt(peg$currPos)\";\n          default:\n            return `input.substr(peg$currPos, ${inputChunkLength})`;\n        }\n      }\n\n      /**\n       * Get the code that increments peg$currPos correctly.  -1 means \"one\n       * full Unicode character\", which might be one or two UTF-16 code units\n       * (JS chars), in which case the varname is required.\n       *\n       * @param {number} inputChunkLength\n       * @param {string} varName\n       * @returns {string}\n       */\n      function getIncrCode(inputChunkLength, varName) {\n        switch (inputChunkLength) {\n          case -1:\n            return `peg$currPos += ${varName}.length;`;\n          case 1:\n            return \"peg$currPos++;\";\n          default:\n            return \"peg$currPos += (\" + inputChunkLength + \");\";\n        }\n      }\n\n      /**\n        MATCH_* opcodes typically do something like\n\n          if (<test>(input.substr(peg$currPos, length))) {\n            sN = input.substr(peg$currPos, length);\n            ...\n          } else {\n            sN = peg$FAILED;\n            ...\n          }\n\n        compileInputChunkCondition will convert that to\n\n          sN = input.substr(peg$currPos, length);\n          if (<test>(sN)) {\n            ...\n          } else {\n            sN = peg$FAILED;\n            ...\n          }\n\n          and avoid extracting the sub string twice.\n        @param {(chunk:string, optimized:boolean)=>string} condFn\n        @param {number} argCount\n        @param {number} inputChunkLength\n      */\n      function compileInputChunkCondition(\n        condFn, argCount, inputChunkLength\n      ) {\n        const baseLength = argCount + 3;\n        let inputChunk = getChunkCode(inputChunkLength);\n        let thenFn = null;\n        if (bc[ip + baseLength] === op.ACCEPT_N\n              && bc[ip + baseLength + 1] === inputChunkLength) {\n          // Push the assignment to the next available variable.\n          parts.push(stack.push(inputChunk));\n          inputChunk = stack.pop();\n          /** @param {number[]} bc */\n          thenFn = bc => {\n            // The bc[0] is an ACCEPT_N, and bc[1] is the N. We've already done\n            // the assignment (before the if), so we just need to bump the\n            // stack, and increment peg$currPos appropriately.\n            stack.sp++;\n            const code = compile(bc.slice(2));\n            code.unshift(getIncrCode(inputChunkLength, inputChunk));\n            return code;\n          };\n        }\n        compileCondition(condFn(inputChunk, thenFn !== null), argCount, thenFn);\n      }\n\n      /** @param {string} cond */\n      function compileLoop(cond) {\n        const baseLength = 2;\n        const bodyLength = bc[ip + baseLength - 1];\n\n        const bodyCode = stack.checkedLoop(ip, () => {\n          ip += baseLength + bodyLength;\n          return compile(bc.slice(ip - bodyLength, ip));\n        });\n\n        parts.push(\"while (\" + cond + \") {\");\n        parts.push(...indent2(bodyCode));\n        parts.push(\"}\");\n      }\n\n      /** @param {number} baseLength */\n      function compileCall(baseLength) {\n        const paramsLength = bc[ip + baseLength - 1];\n\n        return f(bc[ip + 1]) + \"(\"\n          + bc.slice(ip + baseLength, ip + baseLength + paramsLength).map(\n            p => stack.index(p)\n          ).join(\", \")\n          + \")\";\n      }\n\n      while (ip < end) {\n        switch (bc[ip]) {\n          case op.PUSH_EMPTY_STRING:  // PUSH_EMPTY_STRING\n            parts.push(stack.push(\"''\"));\n            ip++;\n            break;\n\n          case op.PUSH_CURR_POS:      // PUSH_CURR_POS\n            parts.push(stack.push(\"peg$currPos\"));\n            ip++;\n            break;\n\n          case op.PUSH_UNDEFINED:     // PUSH_UNDEFINED\n            parts.push(stack.push(\"undefined\"));\n            ip++;\n            break;\n\n          case op.PUSH_NULL:          // PUSH_NULL\n            parts.push(stack.push(\"null\"));\n            ip++;\n            break;\n\n          case op.PUSH_FAILED:        // PUSH_FAILED\n            parts.push(stack.push(\"peg$FAILED\"));\n            ip++;\n            break;\n\n          case op.PUSH_EMPTY_ARRAY:   // PUSH_EMPTY_ARRAY\n            parts.push(stack.push(\"[]\"));\n            ip++;\n            break;\n\n          case op.POP:                // POP\n            stack.pop();\n            ip++;\n            break;\n\n          case op.POP_CURR_POS:       // POP_CURR_POS\n            parts.push(\"peg$currPos = \" + stack.pop() + \";\");\n            ip++;\n            break;\n\n          case op.POP_N:              // POP_N n\n            stack.pop(bc[ip + 1]);\n            ip += 2;\n            break;\n\n          case op.NIP:                // NIP\n            value = stack.pop();\n            stack.pop();\n            parts.push(stack.push(value));\n            ip++;\n            break;\n\n          case op.APPEND:             // APPEND\n            value = stack.pop();\n            parts.push(stack.top() + \".push(\" + value + \");\");\n            ip++;\n            break;\n\n          case op.WRAP:               // WRAP n\n            parts.push(\n              stack.push(\"[\" + stack.pop(bc[ip + 1]).join(\", \") + \"]\")\n            );\n            ip += 2;\n            break;\n\n          case op.TEXT:               // TEXT\n            parts.push(\n              stack.push(\"input.substring(\" + stack.pop() + \", peg$currPos)\")\n            );\n            ip++;\n            break;\n\n          case op.PLUCK: {            // PLUCK n, k, p1, ..., pK\n            const baseLength = 3;\n            const paramsLength = bc[ip + baseLength - 1];\n            const n = baseLength + paramsLength;\n            value = bc.slice(ip + baseLength, ip + n);\n            value = paramsLength === 1\n              ? stack.index(value[0])\n              : `[ ${\n                value.map(p => stack.index(p)).join(\", \")\n              } ]`;\n            stack.pop(bc[ip + 1]);\n            parts.push(stack.push(value));\n            ip += n;\n            break;\n          }\n\n          case op.IF:                 // IF t, f\n            compileCondition(stack.top(), 0);\n            break;\n\n          case op.IF_ERROR:           // IF_ERROR t, f\n            compileCondition(stack.top() + \" === peg$FAILED\", 0);\n            break;\n\n          case op.IF_NOT_ERROR:       // IF_NOT_ERROR t, f\n            compileCondition(stack.top() + \" !== peg$FAILED\", 0);\n            break;\n\n          case op.IF_LT:              // IF_LT min, t, f\n            compileCondition(stack.top() + \".length < \" + bc[ip + 1], 1);\n            break;\n\n          case op.IF_GE:              // IF_GE max, t, f\n            compileCondition(stack.top() + \".length >= \" + bc[ip + 1], 1);\n            break;\n\n          case op.IF_LT_DYNAMIC:      // IF_LT_DYNAMIC min, t, f\n            compileCondition(stack.top() + \".length < (\" + stack.index(bc[ip + 1]) + \"|0)\", 1);\n            break;\n\n          case op.IF_GE_DYNAMIC:      // IF_GE_DYNAMIC max, t, f\n            compileCondition(stack.top() + \".length >= (\" + stack.index(bc[ip + 1]) + \"|0)\", 1);\n            break;\n\n          case op.WHILE_NOT_ERROR:    // WHILE_NOT_ERROR b\n            compileLoop(stack.top() + \" !== peg$FAILED\");\n            break;\n\n          case op.MATCH_ANY:          // MATCH_ANY a, f, ...\n            compileCondition(\"input.length > peg$currPos\", 0);\n            break;\n\n          case op.MATCH_STRING: {     // MATCH_STRING s, a, f, ...\n            const litNum = bc[ip + 1];\n            const literal = literals[litNum];\n            compileInputChunkCondition(\n              (inputChunk, optimized) => {\n                if (literal.length > 1) {\n                  return `${inputChunk} === ${l(litNum)}`;\n                }\n                inputChunk = !optimized\n                  ? \"input.charCodeAt(peg$currPos)\"\n                  : `${inputChunk}.charCodeAt(0)`;\n                return `${inputChunk} === ${literal.charCodeAt(0)}`;\n              },\n              1,\n              literal.length\n            );\n            break;\n          }\n\n          case op.MATCH_STRING_IC: {  // MATCH_STRING_IC s, a, f, ...\n            const litNum = bc[ip + 1];\n            compileInputChunkCondition(\n              inputChunk => `${inputChunk}.toLowerCase() === ${l(litNum)}`,\n              1,\n              literals[litNum].length\n            );\n            break;\n          }\n\n          case op.MATCH_CHAR_CLASS: { // MATCH_CHAR_CLASS c, a, f, ...\n            const regNum = bc[ip + 1];\n            compileInputChunkCondition(\n              inputChunk => `${r(regNum)}.test(${inputChunk})`, 1, 1\n            );\n            break;\n          }\n\n          case op.MATCH_UNICODE_CLASS: { // MATCH_UNICODE_CLASS c, a, f, ...\n            const regNum = bc[ip + 1];\n            compileInputChunkCondition(\n              inputChunk => `${r(regNum)}.test(${inputChunk})`, 1, -1\n            );\n            break;\n          }\n\n          case op.ACCEPT_N:           // ACCEPT_N n\n            parts.push(stack.push(getChunkCode(bc[ip + 1])));\n            parts.push(getIncrCode(bc[ip + 1], stack.top()));\n            ip += 2;\n            break;\n\n          case op.ACCEPT_STRING:      // ACCEPT_STRING s\n            parts.push(stack.push(l(bc[ip + 1])));\n            parts.push(\n              literals[bc[ip + 1]].length > 1\n                ? \"peg$currPos += \" + literals[bc[ip + 1]].length + \";\"\n                : \"peg$currPos++;\"\n            );\n            ip += 2;\n            break;\n\n          case op.FAIL:               // FAIL e\n            parts.push(stack.push(\"peg$FAILED\"));\n            parts.push(\"if (peg$silentFails === 0) { peg$fail(\" + e(bc[ip + 1]) + \"); }\");\n            ip += 2;\n            break;\n\n          case op.LOAD_SAVED_POS:     // LOAD_SAVED_POS p\n            parts.push(\"peg$savedPos = \" + stack.index(bc[ip + 1]) + \";\");\n            ip += 2;\n            break;\n\n          case op.UPDATE_SAVED_POS:   // UPDATE_SAVED_POS\n            parts.push(\"peg$savedPos = peg$currPos;\");\n            ip++;\n            break;\n\n          case op.CALL:               // CALL f, n, pc, p1, p2, ..., pN\n            value = compileCall(4);\n            stack.pop(bc[ip + 2]);\n            parts.push(stack.push(value));\n            ip += 4 + bc[ip + 3];\n            break;\n\n          case op.RULE:               // RULE r\n            parts.push(stack.push(name(ast.rules[bc[ip + 1]].name) + \"()\"));\n            ip += 2;\n            break;\n\n          case op.LIBRARY_RULE: {       // LIBRARY_RULE module, name\n            const nm = bc[ip + 2];\n            const cnm = (nm === -1) ? \"\" : \", \\\"\" + importedNames[nm] + \"\\\"\";\n            parts.push(stack.push(\"peg$callLibrary(\"\n              + gi(bc[ip + 1])\n              + cnm\n              + \")\"));\n            ip += 3;\n            break;\n          }\n\n          case op.SILENT_FAILS_ON:    // SILENT_FAILS_ON\n            parts.push(\"peg$silentFails++;\");\n            ip++;\n            break;\n\n          case op.SILENT_FAILS_OFF:   // SILENT_FAILS_OFF\n            parts.push(\"peg$silentFails--;\");\n            ip++;\n            break;\n\n          case op.SOURCE_MAP_PUSH:\n            stack.sourceMapPush(\n              parts,\n              locations[bc[ip + 1]]\n            );\n            ip += 2;\n            break;\n\n          case op.SOURCE_MAP_POP: {\n            stack.sourceMapPop();\n            ip++;\n            break;\n          }\n\n          case op.SOURCE_MAP_LABEL_PUSH:\n            stack.labels[bc[ip + 1]] = {\n              label: literals[bc[ip + 2]],\n              location: locations[bc[ip + 3]],\n            };\n            ip += 4;\n            break;\n\n          case op.SOURCE_MAP_LABEL_POP:\n            delete stack.labels[bc[ip + 1]];\n            ip += 2;\n            break;\n\n          // istanbul ignore next Because we never generate invalid bytecode we cannot reach this branch\n          default:\n            throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n        }\n      }\n\n      return parts;\n    }\n\n    const code = compile(bytecode);\n\n    parts.push(wrapInSourceNode(\n      \"function \",\n      name(rule.name),\n      rule.nameLocation,\n      \"() {\\n\",\n      rule.name\n    ));\n\n    if (options.trace) {\n      parts.push(\"  var startPos = peg$currPos;\");\n    }\n\n    parts.push(indent2(stack.defines()));\n\n    parts.push(...indent2(generateRuleHeader(\n      \"\\\"\" + stringEscape(rule.name) + \"\\\"\",\n      asts.indexOfRule(ast, rule.name)\n    )));\n    parts.push(...indent2(code));\n    parts.push(...indent2(generateRuleFooter(\n      \"\\\"\" + stringEscape(rule.name) + \"\\\"\",\n      stack.result()\n    )));\n\n    parts.push(\"}\");\n    parts.push(\"\");\n\n    return parts;\n  }\n\n  /**\n   * @template {string} T\n   * @param {PEG.ast.CodeBlock<T>} node\n   */\n  function ast2SourceNode(node) {\n    // If location is not defined (for example, AST node was replaced\n    // by a plugin and does not provide location information, see\n    // plugin-api.spec.js/\"can replace parser\") returns initializer code\n    if (node.codeLocation) {\n      // Append \"$\" to the name to create an impossible rule name\n      // so that names will not collide with rule names\n      return toSourceNode(node.code, node.codeLocation, \"$\" + node.type);\n    }\n\n    return node.code;\n  }\n\n  function generateToplevel() {\n    const parts = [];\n\n    let topLevel = ast.topLevelInitializer;\n    if (topLevel) {\n      if (Array.isArray(topLevel)) {\n        if (options.format === \"es\") {\n          const imps = [];\n          const codes = [];\n          for (const tli of topLevel) {\n            const [\n              imports,\n              code,\n            ] = /** @type {PEG.ast.TopLevelInitializer[]} */ (\n              parse(tli.code, {\n                startRule: \"ImportsAndSource\",\n                grammarSource: new GrammarLocation(\n                  tli.codeLocation.source,\n                  tli.codeLocation.start\n                ),\n              })\n            );\n            if (imports.code) {\n              imps.push(imports);\n              codes.push(code);\n            } else {\n              // Prefer the original\n              codes.push(tli);\n            }\n          }\n          // Imports go at the end so that when reversed, they end up in front.\n          topLevel = codes.concat(imps);\n        }\n        // Put library code before code using it.\n        const reversed = topLevel.slice(0).reverse();\n        for (const tli of reversed) {\n          parts.push(ast2SourceNode(tli));\n          parts.push(\"\");\n        }\n      } else {\n        parts.push(ast2SourceNode(topLevel));\n        parts.push(\"\");\n      }\n    }\n\n    parts.push(\n      \"class peg$SyntaxError extends SyntaxError {\",\n      \"  constructor(message, expected, found, location) {\",\n      \"    super(message);\",\n      \"    this.expected = expected;\",\n      \"    this.found = found;\",\n      \"    this.location = location;\",\n      \"    this.name = \\\"SyntaxError\\\";\",\n      \"  }\",\n      \"\",\n      \"  format(sources) {\",\n      \"    let str = \\\"Error: \\\" + this.message;\",\n      \"    if (this.location) {\",\n      \"      let src = null;\",\n      \"      const st = sources.find(s => s.source === this.location.source);\",\n      \"      if (st) {\",\n      \"        src = st.text.split(/\\\\r\\\\n|\\\\n|\\\\r/g);\",\n      \"      }\",\n      \"      const s = this.location.start;\",\n      \"      const offset_s = (this.location.source && (typeof this.location.source.offset === \\\"function\\\"))\",\n      \"        ? this.location.source.offset(s)\",\n      \"        : s;\",\n      \"      const loc = this.location.source + \\\":\\\" + offset_s.line + \\\":\\\" + offset_s.column;\",\n      \"      if (src) {\",\n      \"        const e = this.location.end;\",\n      \"        const filler = \\\"\\\".padEnd(offset_s.line.toString().length, \\\" \\\");\",\n      \"        const line = src[s.line - 1];\",\n      \"        const last = s.line === e.line ? e.column : line.length + 1;\",\n      \"        const hatLen = (last - s.column) || 1;\",\n      \"        str += \\\"\\\\n --> \\\" + loc + \\\"\\\\n\\\"\",\n      \"            + filler + \\\" |\\\\n\\\"\",\n      \"            + offset_s.line + \\\" | \\\" + line + \\\"\\\\n\\\"\",\n      \"            + filler + \\\" | \\\" + \\\"\\\".padEnd(s.column - 1, \\\" \\\")\",\n      \"            + \\\"\\\".padEnd(hatLen, \\\"^\\\");\",\n      \"      } else {\",\n      \"        str += \\\"\\\\n at \\\" + loc;\",\n      \"      }\",\n      \"    }\",\n      \"    return str;\",\n      \"  }\",\n      \"\",\n      \"  static buildMessage(expected, found) {\",\n      \"    function hex(ch) {\",\n      \"      return ch.codePointAt(0).toString(16).toUpperCase();\",\n      \"    }\",\n      \"\",\n      \"    const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, \\\"unicode\\\")\",\n      \"      ? new RegExp(\\\"[\\\\\\\\p{C}\\\\\\\\p{Mn}\\\\\\\\p{Mc}]\\\", \\\"gu\\\")\",\n      \"      : null;\",\n      \"    function unicodeEscape(s) {\",\n      \"      if (nonPrintable) {\",\n      \"        return s.replace(nonPrintable,  ch => \\\"\\\\\\\\u{\\\" + hex(ch) + \\\"}\\\");\",\n      \"      }\",\n      \"      return s;\",\n      \"    }\",\n      \"\",\n      \"    function literalEscape(s) {\",\n      \"      return unicodeEscape(s\",\n      \"        .replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\")\",   // Backslash\n      \"        .replace(/\\\"/g,  \\\"\\\\\\\\\\\\\\\"\\\")\",    // Closing double quote\n      \"        .replace(/\\\\0/g, \\\"\\\\\\\\0\\\")\",       // Null\n      \"        .replace(/\\\\t/g, \\\"\\\\\\\\t\\\")\",       // Horizontal tab\n      \"        .replace(/\\\\n/g, \\\"\\\\\\\\n\\\")\",       // Line feed\n      \"        .replace(/\\\\r/g, \\\"\\\\\\\\r\\\")\",       // Carriage return\n      \"        .replace(/[\\\\x00-\\\\x0F]/g,          ch => \\\"\\\\\\\\x0\\\" + hex(ch))\",\n      \"        .replace(/[\\\\x10-\\\\x1F\\\\x7F-\\\\x9F]/g, ch => \\\"\\\\\\\\x\\\"  + hex(ch)));\",\n      \"    }\",\n      \"\",\n      \"    function classEscape(s) {\",\n      \"      return unicodeEscape(s\",\n      \"        .replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\")\",   // Backslash\n      \"        .replace(/\\\\]/g, \\\"\\\\\\\\]\\\")\",       // Closing bracket\n      \"        .replace(/\\\\^/g, \\\"\\\\\\\\^\\\")\",       // Caret\n      \"        .replace(/-/g,  \\\"\\\\\\\\-\\\")\",        // Dash\n      \"        .replace(/\\\\0/g, \\\"\\\\\\\\0\\\")\",       // Null\n      \"        .replace(/\\\\t/g, \\\"\\\\\\\\t\\\")\",       // Horizontal tab\n      \"        .replace(/\\\\n/g, \\\"\\\\\\\\n\\\")\",       // Line feed\n      \"        .replace(/\\\\r/g, \\\"\\\\\\\\r\\\")\",       // Carriage return\n      \"        .replace(/[\\\\x00-\\\\x0F]/g,          ch => \\\"\\\\\\\\x0\\\" + hex(ch))\",\n      \"        .replace(/[\\\\x10-\\\\x1F\\\\x7F-\\\\x9F]/g, ch => \\\"\\\\\\\\x\\\"  + hex(ch)));\",\n      \"    }\",\n      \"\",\n      \"    const DESCRIBE_EXPECTATION_FNS = {\",\n      \"      literal(expectation) {\",\n      \"        return \\\"\\\\\\\"\\\" + literalEscape(expectation.text) + \\\"\\\\\\\"\\\";\",\n      \"      },\",\n      \"\",\n      \"      class(expectation) {\",\n      \"        const escapedParts = expectation.parts.map(\",\n      \"          part => (Array.isArray(part)\",\n      \"            ? classEscape(part[0]) + \\\"-\\\" + classEscape(part[1])\",\n      \"            : classEscape(part))\",\n      \"        );\",\n      \"\",\n      \"        return \\\"[\\\" + (expectation.inverted ? \\\"^\\\" : \\\"\\\") + escapedParts.join(\\\"\\\") + \\\"]\\\" + (expectation.unicode ? \\\"u\\\" : \\\"\\\");\",\n      \"      },\",\n      \"\",\n      \"      any() {\",\n      \"        return \\\"any character\\\";\",\n      \"      },\",\n      \"\",\n      \"      end() {\",\n      \"        return \\\"end of input\\\";\",\n      \"      },\",\n      \"\",\n      \"      other(expectation) {\",\n      \"        return expectation.description;\",\n      \"      },\",\n      \"    };\",\n      \"\",\n      \"    function describeExpectation(expectation) {\",\n      \"      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\",\n      \"    }\",\n      \"\",\n      \"    function describeExpected(expected) {\",\n      \"      const descriptions = expected.map(describeExpectation);\",\n      \"      descriptions.sort();\",\n      \"\",\n      \"      if (descriptions.length > 0) {\",\n      \"        let j = 1;\",\n      \"        for (let i = 1; i < descriptions.length; i++) {\",\n      \"          if (descriptions[i - 1] !== descriptions[i]) {\",\n      \"            descriptions[j] = descriptions[i];\",\n      \"            j++;\",\n      \"          }\",\n      \"        }\",\n      \"        descriptions.length = j;\",\n      \"      }\",\n      \"\",\n      \"      switch (descriptions.length) {\",\n      \"        case 1:\",\n      \"          return descriptions[0];\",\n      \"\",\n      \"        case 2:\",\n      \"          return descriptions[0] + \\\" or \\\" + descriptions[1];\",\n      \"\",\n      \"        default:\",\n      \"          return descriptions.slice(0, -1).join(\\\", \\\")\",\n      \"            + \\\", or \\\"\",\n      \"            + descriptions[descriptions.length - 1];\",\n      \"      }\",\n      \"    }\",\n      \"\",\n      \"    function describeFound(found) {\",\n      \"      return found ? \\\"\\\\\\\"\\\" + literalEscape(found) + \\\"\\\\\\\"\\\" : \\\"end of input\\\";\",\n      \"    }\",\n      \"\",\n      \"    return \\\"Expected \\\" + describeExpected(expected) + \\\" but \\\" + describeFound(found) + \\\" found.\\\";\",\n      \"  }\",\n      \"}\",\n      \"\"\n    );\n\n    if (options.trace) {\n      parts.push(\n        \"class peg$DefaultTracer {\",\n        \"  constructor() {\",\n        \"    this.indentLevel = 0;\",\n        \"  }\",\n        \"\",\n        \"  trace(event) {\",\n        \"    const that = this;\",\n        \"\",\n        \"    function log(event) {\",\n        \"      console?.log?.(\",\n        \"        event.location.start.line + \\\":\\\" + event.location.start.column + \\\"-\\\"\",\n        \"          + event.location.end.line + \\\":\\\" + event.location.end.column + \\\" \\\"\",\n        \"          + event.type.padEnd(10, \\\" \\\")\",\n        \"          + \\\"\\\".padEnd((that.indentLevel * 2) + 1, \\\" \\\") + event.rule\",\n        \"       );\",\n        \"    }\",\n        \"\",\n        \"    switch (event.type) {\",\n        \"      case \\\"rule.enter\\\":\",\n        \"        log(event);\",\n        \"        this.indentLevel++;\",\n        \"        break;\",\n        \"\",\n        \"      case \\\"rule.match\\\":\",\n        \"        this.indentLevel--;\",\n        \"        log(event);\",\n        \"        break;\",\n        \"\",\n        \"      case \\\"rule.fail\\\":\",\n        \"        this.indentLevel--;\",\n        \"        log(event);\",\n        \"        break;\",\n        \"\",\n        \"      default:\",\n        \"        throw new Error(\\\"Invalid event type: \\\" + event.type + \\\".\\\");\",\n        \"    }\",\n        \"  }\",\n        \"}\",\n        \"\"\n      );\n    }\n\n    const startRuleFunctions = \"{\\n\"\n      + allowedStartRules.map(r => `    ${r}: ${name(r)},\\n`).join(\"\")\n      + \"  }\";\n    const startRuleFunction = name(allowedStartRules[0]);\n\n    parts.push(\n      \"function peg$parse(input, options) {\",\n      \"  options = options !== undefined ? options : {};\",\n      \"\",\n      \"  const peg$FAILED = {};\",\n      \"  const peg$source = options.grammarSource;\",\n      \"\",\n      \"  const peg$startRuleFunctions = \" + startRuleFunctions + \";\",\n      \"  let peg$startRuleFunction = \" + startRuleFunction + \";\",\n      \"\",\n      generateTables(),\n      \"\",\n      \"  let peg$currPos = options.peg$currPos | 0;\",\n      \"  let peg$savedPos = peg$currPos;\",\n      \"  const peg$posDetailsCache = [{ line: 1, column: 1 }];\",\n      \"  let peg$maxFailPos = peg$currPos;\",\n      \"  let peg$maxFailExpected = options.peg$maxFailExpected || [];\",\n      \"  let peg$silentFails = options.peg$silentFails | 0;\",   // 0 = report failures, > 0 = silence failures\n      \"\"\n    );\n\n    if (options.cache) {\n      parts.push(\n        \"  let peg$resultsCache = {};\",\n        \"\"\n      );\n    }\n\n    if (options.trace) {\n      parts.push(\n        \"  let peg$tracer = \\\"tracer\\\" in options ? options.tracer : new peg$DefaultTracer();\",\n        \"\"\n      );\n    }\n\n    parts.push(\n      \"  let peg$result;\",\n      \"\",\n      \"  if (options.startRule) {\",\n      \"    if (!(options.startRule in peg$startRuleFunctions)) {\",\n      \"      throw new Error(\\\"Can't start parsing from rule \\\\\\\"\\\" + options.startRule + \\\"\\\\\\\".\\\");\",\n      \"    }\",\n      \"\",\n      \"    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\",\n      \"  }\",\n      \"\",\n      \"  function text() {\",\n      \"    return input.substring(peg$savedPos, peg$currPos);\",\n      \"  }\",\n      \"\",\n      \"  function offset() {\",\n      \"    return peg$savedPos;\",\n      \"  }\",\n      \"\",\n      \"  function range() {\",\n      \"    return {\",\n      \"      source: peg$source,\",\n      \"      start: peg$savedPos,\",\n      \"      end: peg$currPos,\",\n      \"    };\",\n      \"  }\",\n      \"\",\n      \"  function location() {\",\n      \"    return peg$computeLocation(peg$savedPos, peg$currPos);\",\n      \"  }\",\n      \"\",\n      \"  function expected(description, location) {\",\n      \"    location = location !== undefined\",\n      \"      ? location\",\n      \"      : peg$computeLocation(peg$savedPos, peg$currPos);\",\n      \"\",\n      \"    throw peg$buildStructuredError(\",\n      \"      [peg$otherExpectation(description)],\",\n      \"      input.substring(peg$savedPos, peg$currPos),\",\n      \"      location\",\n      \"    );\",\n      \"  }\",\n      \"\",\n      \"  function error(message, location) {\",\n      \"    location = location !== undefined\",\n      \"      ? location\",\n      \"      : peg$computeLocation(peg$savedPos, peg$currPos);\",\n      \"\",\n      \"    throw peg$buildSimpleError(message, location);\",\n      \"  }\",\n      \"\",\n      \"  function peg$getUnicode(pos = peg$currPos) {\",\n      \"    const cp = input.codePointAt(pos);\",\n      \"    if (cp === undefined) {\",\n      \"      return \\\"\\\";\",\n      \"    }\",\n      \"    return String.fromCodePoint(cp);\",\n      \"  }\",\n      \"\",\n      \"  function peg$literalExpectation(text, ignoreCase) {\",\n      \"    return { type: \\\"literal\\\", text, ignoreCase };\",\n      \"  }\",\n      \"\",\n      \"  function peg$classExpectation(parts, inverted, ignoreCase, unicode) {\",\n      \"    return { type: \\\"class\\\", parts, inverted, ignoreCase, unicode };\",\n      \"  }\",\n      \"\",\n      \"  function peg$anyExpectation() {\",\n      \"    return { type: \\\"any\\\" };\",\n      \"  }\",\n      \"\",\n      \"  function peg$endExpectation() {\",\n      \"    return { type: \\\"end\\\" };\",\n      \"  }\",\n      \"\",\n      \"  function peg$otherExpectation(description) {\",\n      \"    return { type: \\\"other\\\", description };\",\n      \"  }\",\n      \"\",\n      \"  function peg$computePosDetails(pos) {\",\n      \"    let details = peg$posDetailsCache[pos];\",\n      \"    let p;\",\n      \"\",\n      \"    if (details) {\",\n      \"      return details;\",\n      \"    } else {\",\n      \"      if (pos >= peg$posDetailsCache.length) {\",\n      \"        p = peg$posDetailsCache.length - 1;\",\n      \"      } else {\",\n      \"        p = pos;\",\n      \"        while (!peg$posDetailsCache[--p]) {}\",\n      \"      }\",\n      \"\",\n      \"      details = peg$posDetailsCache[p];\",\n      \"      details = {\",\n      \"        line: details.line,\",\n      \"        column: details.column,\",\n      \"      };\",\n      \"\",\n      \"      while (p < pos) {\",\n      \"        if (input.charCodeAt(p) === 10) {\",\n      \"          details.line++;\",\n      \"          details.column = 1;\",\n      \"        } else {\",\n      \"          details.column++;\",\n      \"        }\",\n      \"\",\n      \"        p++;\",\n      \"      }\",\n      \"\",\n      \"      peg$posDetailsCache[pos] = details;\",\n      \"\",\n      \"      return details;\",\n      \"    }\",\n      \"  }\",\n      \"\",\n      \"  function peg$computeLocation(startPos, endPos, offset) {\",\n      \"    const startPosDetails = peg$computePosDetails(startPos);\",\n      \"    const endPosDetails = peg$computePosDetails(endPos);\",\n      \"\",\n      \"    const res = {\",\n      \"      source: peg$source,\",\n      \"      start: {\",\n      \"        offset: startPos,\",\n      \"        line: startPosDetails.line,\",\n      \"        column: startPosDetails.column,\",\n      \"      },\",\n      \"      end: {\",\n      \"        offset: endPos,\",\n      \"        line: endPosDetails.line,\",\n      \"        column: endPosDetails.column,\",\n      \"      },\",\n      \"    };\",\n      \"    if (offset && peg$source && (typeof peg$source.offset === \\\"function\\\")) {\",\n      \"      res.start = peg$source.offset(res.start);\",\n      \"      res.end = peg$source.offset(res.end);\",\n      \"    }\",\n      \"    return res;\",\n      \"  }\",\n      \"\",\n      \"  function peg$fail(expected) {\",\n      \"    if (peg$currPos < peg$maxFailPos) { return; }\",\n      \"\",\n      \"    if (peg$currPos > peg$maxFailPos) {\",\n      \"      peg$maxFailPos = peg$currPos;\",\n      \"      peg$maxFailExpected = [];\",\n      \"    }\",\n      \"\",\n      \"    peg$maxFailExpected.push(expected);\",\n      \"  }\",\n      \"\",\n      \"  function peg$buildSimpleError(message, location) {\",\n      \"    return new peg$SyntaxError(message, null, null, location);\",\n      \"  }\",\n      \"\",\n      \"  function peg$buildStructuredError(expected, found, location) {\",\n      \"    return new peg$SyntaxError(\",\n      \"      peg$SyntaxError.buildMessage(expected, found),\",\n      \"      expected,\",\n      \"      found,\",\n      \"      location\",\n      \"    );\",\n      \"  }\",\n      \"\"\n    );\n\n    if (ast.imports.length > 0) {\n      parts.push(\n        \"  function peg$callLibrary(lib, startRule) {\",\n        \"    const opts = Object.assign({}, options, {\",\n        \"      startRule: startRule,\",\n        \"      peg$currPos: peg$currPos,\",\n        \"      peg$silentFails: peg$silentFails,\",\n        \"      peg$library: true,\",\n        \"      peg$maxFailExpected: peg$maxFailExpected\",\n        \"    });\",\n        \"    const res = lib.parse(input, opts);\",\n        \"    peg$currPos = res.peg$currPos;\",\n        \"    peg$maxFailPos = res.peg$maxFailPos;\",\n        \"    peg$maxFailExpected = res.peg$maxFailExpected;\",\n        \"    return (res.peg$result === res.peg$FAILED) ? peg$FAILED : res.peg$result;\",\n        \"  }\",\n        \"\"\n      );\n    }\n\n    ast.rules.forEach(rule => {\n      parts.push(...indent2(generateRuleFunction(rule)));\n    });\n\n    if (ast.initializer) {\n      if (Array.isArray(ast.initializer)) {\n        for (const init of ast.initializer) {\n          parts.push(ast2SourceNode(init));\n          parts.push(\"\");\n        }\n      } else {\n        parts.push(ast2SourceNode(ast.initializer));\n        parts.push(\"\");\n      }\n    }\n\n    parts.push(\n      \"  peg$result = peg$startRuleFunction();\",\n      \"\",\n      \"  const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);\",\n      \"  function peg$throw() {\",\n      \"    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\",\n      \"      peg$fail(peg$endExpectation());\",\n      \"    }\",\n      \"\",\n      \"    throw peg$buildStructuredError(\",\n      \"      peg$maxFailExpected,\",\n      \"      peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,\",\n      \"      peg$maxFailPos < input.length\",\n      \"        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\",\n      \"        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\",\n      \"    );\",\n      \"  }\",\n      \"  if (options.peg$library) {\",\n      // Hide this from TypeScript.  It's internal-only until library mode is stabilized.\n      \"    return /** @type {any} */ ({\",\n      \"      peg$result,\",\n      \"      peg$currPos,\",\n      \"      peg$FAILED,\",\n      \"      peg$maxFailExpected,\",\n      \"      peg$maxFailPos,\",\n      \"      peg$success,\",\n      \"      peg$throw: peg$success ? undefined : peg$throw,\",\n      \"    });\",\n      \"  }\",\n      \"  if (peg$success) {\",\n      \"    return peg$result;\",\n      \"  } else {\",\n      \"    peg$throw();\",\n      \"  }\",\n      \"}\"\n    );\n\n    return new SourceNode(\n      // This expression has a better readability when on two lines\n      // eslint-disable-next-line @stylistic/function-call-argument-newline\n      null, null, options.grammarSource,\n      parts.map(s => (s instanceof SourceNode ? s : s + \"\\n\"))\n    );\n  }\n\n  /** @param {SourceNode} toplevelCode */\n  function generateWrapper(toplevelCode) {\n    /** @return {(string|SourceNode)[]} */\n    function generateGeneratedByComment() {\n      return [\n        `// @generated by Peggy ${version}.`,\n        \"//\",\n        \"// https://peggyjs.org/\",\n      ];\n    }\n\n    function generateParserObject() {\n      const res = [\"{\"];\n      if (options.trace) {\n        res.push(\"  DefaultTracer: peg$DefaultTracer,\");\n      }\n\n      if (options.allowedStartRules) {\n        res.push(\"  StartRules: [\" + options.allowedStartRules.map(r => '\"' + r + '\"').join(\", \") + \"],\");\n      }\n\n      res.push(\n        \"  SyntaxError: peg$SyntaxError,\",\n        \"  parse: peg$parse,\"\n      );\n\n      res.push(\"}\");\n      return res.join(\"\\n\");\n    }\n\n    const generators = {\n      bare() {\n        if ((Object.keys(dependencies).length > 0)\n            || (ast.imports.length > 0)) {\n          throw new Error(\"Dependencies not supported in format 'bare'.\");\n        }\n        return [\n          ...generateGeneratedByComment(),\n          \"(function() {\",\n          \"  \\\"use strict\\\";\",\n          toplevelCode,\n          indent2(\"return \" + generateParserObject() + \";\"),\n          \"})()\",\n        ];\n      },\n\n      commonjs() {\n        const dependencyVars = Object.keys(dependencies);\n\n        const parts = generateGeneratedByComment();\n        parts.push(\n          \"\",\n          \"\\\"use strict\\\";\"\n        );\n\n        if (dependencyVars.length > 0) {\n          dependencyVars.forEach(variable => {\n            parts.push(\n              \"const \" + variable\n              + \" = require(\\\"\"\n              + stringEscape(dependencies[variable])\n              + \"\\\");\"\n            );\n          });\n          parts.push(\"\");\n        }\n\n        const impLen = ast.imports.length;\n        for (let i = 0; i < impLen; i++) {\n          parts.push(\n            \"const \" + gi(i)\n            + \" = require(\\\"\"\n            + stringEscape(ast.imports[i].from.module)\n            + \"\\\");\"\n          );\n        }\n\n        parts.push(\n          \"\",\n          toplevelCode,\n          \"\",\n          \"module.exports = \" + generateParserObject() + \";\"\n        );\n\n        return parts;\n      },\n\n      es() {\n        const dependencyVars = Object.keys(dependencies);\n\n        const parts = generateGeneratedByComment();\n        parts.push(\"\");\n\n        if (dependencyVars.length > 0) {\n          dependencyVars.forEach(variable => {\n            parts.push(\n              \"import \" + variable\n              + \" from \\\"\"\n              + stringEscape(dependencies[variable])\n              + \"\\\";\"\n            );\n          });\n          parts.push(\"\");\n        }\n\n        for (let i = 0; i < ast.imports.length; i++) {\n          parts.push(\n            \"import * as \" + gi(i)\n            + \" from \\\"\"\n            + stringEscape(ast.imports[i].from.module)\n            + \"\\\";\"\n          );\n        }\n\n        parts.push(\n          \"\",\n          toplevelCode,\n          \"\"\n        );\n\n        parts.push(\n          \"const peg$allowedStartRules = [\",\n          \"  \" + (options.allowedStartRules ? options.allowedStartRules.map(r => '\"' + r + '\"').join(\",\\n  \") : \"\"),\n          \"];\",\n          \"\"\n        );\n\n        parts.push(\n          \"export {\"\n        );\n\n        if (options.trace) {\n          parts.push(\"  peg$DefaultTracer as DefaultTracer,\");\n        }\n\n        parts.push(\n          \"  peg$allowedStartRules as StartRules,\",\n          \"  peg$SyntaxError as SyntaxError,\",\n          \"  peg$parse as parse\",\n          \"};\"\n        );\n\n        return parts;\n      },\n\n      amd() {\n        if (ast.imports.length > 0) {\n          throw new Error(\"Imports are not supported in format 'amd'.\");\n        }\n\n        const dependencyVars = Object.keys(dependencies);\n        const dependencyIds = dependencyVars.map(v => dependencies[v]);\n        const deps = \"[\"\n          + dependencyIds.map(\n            id => \"\\\"\" + stringEscape(id) + \"\\\"\"\n          ).join(\", \")\n          + \"]\";\n        const params = dependencyVars.join(\", \");\n\n        return [\n          ...generateGeneratedByComment(),\n          \"define(\" + deps + \", function(\" + params + \") {\",\n          \"  \\\"use strict\\\";\",\n          toplevelCode,\n          \"\",\n          indent2(\"return \" + generateParserObject() + \";\"),\n          \"});\",\n        ];\n      },\n\n      globals() {\n        if ((Object.keys(dependencies).length > 0)\n            || (ast.imports.length > 0)) {\n          throw new Error(\"Dependencies not supported in format 'globals'.\");\n        }\n        if (!options.exportVar) {\n          throw new Error(\"No export variable defined for format 'globals'.\");\n        }\n\n        return [\n          ...generateGeneratedByComment(),\n          \"(function(root) {\",\n          \"  \\\"use strict\\\";\",\n          toplevelCode,\n          \"\",\n          indent2(\"root.\" + options.exportVar + \" = \" + generateParserObject() + \";\"),\n          \"})(this);\",\n        ];\n      },\n\n      umd() {\n        if (ast.imports.length > 0) {\n          throw new Error(\"Imports are not supported in format 'umd'.\");\n        }\n\n        const dependencyVars = Object.keys(dependencies);\n        const dependencyIds = dependencyVars.map(v => dependencies[v]);\n        const deps = \"[\"\n          + dependencyIds.map(\n            id => \"\\\"\" + stringEscape(id) + \"\\\"\"\n          ).join(\", \")\n          + \"]\";\n        const requires = dependencyIds.map(\n          id => \"require(\\\"\" + stringEscape(id) + \"\\\")\"\n        ).join(\", \");\n        const params = dependencyVars.join(\", \");\n\n        const parts = generateGeneratedByComment();\n        parts.push(\n          \"(function(root, factory) {\",\n          \"  if (typeof define === \\\"function\\\" && define.amd) {\",\n          \"    define(\" + deps + \", factory);\",\n          \"  } else if (typeof module === \\\"object\\\" && module.exports) {\",\n          \"    module.exports = factory(\" + requires + \");\"\n        );\n\n        if (options.exportVar) {\n          parts.push(\n            \"  } else {\",\n            \"    root.\" + options.exportVar + \" = factory();\"\n          );\n        }\n\n        parts.push(\n          \"  }\",\n          \"})(this, function(\" + params + \") {\",\n          \"  \\\"use strict\\\";\",\n          toplevelCode,\n          \"\",\n          indent2(\"return \" + generateParserObject() + \";\"),\n          \"});\"\n        );\n\n        return parts;\n      },\n    };\n\n    const parts = generators[options.format || \"bare\"]();\n\n    return new SourceNode(\n      // eslint-disable-next-line @stylistic/function-call-argument-newline -- This expression has a better readability when on two lines\n      null, null, options.grammarSource,\n      parts.map(s => (s instanceof SourceNode ? s : s + \"\\n\"))\n    );\n  }\n\n  ast.code = generateWrapper(generateToplevel());\n}\n\nmodule.exports = generateJS;\n","\"use strict\";\n\nconst asts = require(\"../asts\");\nconst visitor = require(\"../visitor\");\n\n// Removes proxy rules -- that is, rules that only delegate to other rule.\nfunction removeProxyRules(ast, options, session) {\n  function isProxyRule(node) {\n    return node.type === \"rule\" && node.expression.type === \"rule_ref\";\n  }\n\n  function replaceRuleRefs(ast, from, to) {\n    const replace = visitor.build({\n      rule_ref(node) {\n        if (node.name === from) {\n          node.name = to;\n\n          session.info(\n            `Proxy rule \"${from}\" replaced by the rule \"${to}\"`,\n            node.location,\n            [{\n              message: \"This rule will be used\",\n              location: asts.findRule(ast, to).nameLocation,\n            }]\n          );\n        }\n      },\n    });\n\n    replace(ast);\n  }\n\n  ast.rules.forEach(rule => {\n    if (isProxyRule(rule)) {\n      replaceRuleRefs(ast, rule.name, rule.expression.name);\n    }\n  });\n}\n\nmodule.exports = removeProxyRules;\n","// @ts-check\n\"use strict\";\n\nconst { stringEscape } = require(\"../utils\");\n\n/**\n * @typedef {import(\"../../peg\")} PEG\n */\n\n/** @type {PEG.compiler.visitor} */\nconst visitor = require(\"../visitor\");\nconst { codePointLen1 } = require(\"../utils\");\n\n/**\n * @param {unknown} target\n * @param {unknown} source\n */\nfunction cloneOver(target, source) {\n  const t = /** @type {Record<string,unknown>} */ (target);\n  const s = /** @type {Record<string,unknown>} */ (source);\n  Object.keys(t).forEach(key => delete t[key]);\n  Object.keys(s).forEach(key => { t[key] = s[key]; });\n}\n\n/**\n * Clean up the parts array of a `class` node, by sorting,\n * then removing \"contained\" ranges, and merging overlapping\n * or adjacent ranges.\n *\n * @param {PEG.ast.CharacterClass[\"parts\"]} parts\n */\nfunction cleanParts(parts) {\n  // Sort parts on increasing start, and then decreasing end.\n  parts.sort((a, b) => {\n    const [aStart, aEnd] = Array.isArray(a) ? a : [a, a];\n    const [bStart, bEnd] = Array.isArray(b) ? b : [b, b];\n    if (aStart !== bStart) {\n      return aStart < bStart ? -1 : 1;\n    }\n    if (aEnd !== bEnd) {\n      return aEnd > bEnd ? -1 : 1;\n    }\n    return 0;\n  });\n\n  /** @type {string | PEG.ast.ClassEscape} */\n  let prevStart = \"\";\n  /** @type {string | PEG.ast.ClassEscape} */\n  let prevEnd = \"\";\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i];\n    const [curStart, curEnd] = Array.isArray(part) ? part : [part, part];\n    if ((typeof curStart === \"string\") && (typeof curEnd === \"string\")\n        && (typeof prevStart === \"string\") && (typeof prevEnd === \"string\")) {\n      if (curEnd <= prevEnd) {\n        // Current range is contained in previous range,\n        // so drop it.\n        parts.splice(i--, 1);\n        continue;\n      }\n      if (prevEnd.charCodeAt(0) + 1 >= curStart.charCodeAt(0)) {\n        // Current and previous ranges overlap, or are adjacent.\n        // Drop the current, and extend the previous range.\n        parts.splice(i--, 1);\n        parts[i] = [prevStart, prevEnd = curEnd];\n        continue;\n      }\n    }\n    prevStart = curStart;\n    prevEnd = curEnd;\n  }\n  return parts;\n}\n\nconst LAST_LOW = String.fromCodePoint(0xD7FF);\nconst FIRST_SURROGATE = 0xD800;\nconst LAST_SURROGATE = 0xDFFF;\nconst FIRST_HIGH = String.fromCodePoint(0xE000);\n\n/**\n * Split Unicode ranges in classes that span over the surrogate range.\n * @param {PEG.ast.Grammar} ast\n * @param {PEG.Session} session\n */\nfunction splitUnicodeRanges(ast, session) {\n  const split = visitor.build({\n    /**\n     * @param {PEG.ast.CharacterClass} node\n     */\n    class(node) {\n      if (!node.unicode) {\n        return;\n      }\n      const extras = [];\n      for (const p of node.parts) {\n        if (Array.isArray(p)) {\n          const [s, e] = p.map(c => /** @type {number} */(c.codePointAt(0)));\n          if ((s < FIRST_SURROGATE) && (e > LAST_SURROGATE)) {\n            session.info(\n              `Removing surrogate range from [${stringEscape(p[0])}-${stringEscape(p[1])}]`,\n              node.location\n            );\n            extras.push([FIRST_HIGH, p[1]]);\n            p[1] = LAST_LOW;\n          }\n        }\n      }\n      node.parts.push(...extras);\n    },\n  });\n  split(ast);\n}\n\n/**\n * Merges a choice character classes into a character class\n * @type {PEG.Pass}\n */\nfunction mergeCharacterClasses(ast, _options, session) {\n  // Build a map from rule names to rules for quick lookup of\n  // ref_rules.\n  const rules = Object.create(null);\n  ast.rules.forEach(rule => (rules[rule.name] = rule.expression));\n  // Keep a set of which rules have been processed, so that when\n  // we find a ref_rule, we can make sure its processed, before we\n  // try to use it.\n  const processedRules = new Set();\n\n  splitUnicodeRanges(ast, session);\n\n  // Mutually-recursive.  Get around use-before-declaration.\n  const [asClass, merge] = [\n    /**\n     * Determine whether a node can be represented as a simple character class,\n     * and return that class if so.\n     *\n     * @param {PEG.ast.Expression} node - the node to inspect\n     * @param {boolean} [clone=false] - if true, always return a new node that\n     *   can be modified by the caller\n     * @returns {PEG.ast.CharacterClass | null}\n     */\n    (node, clone = false) => { // \"asClass\"\n      // eslint-disable-next-line default-case\n      switch (node.type) {\n        case \"class\":\n          if (node.inverted) {\n            // Only combine positives, which are more common.\n            // Negatives are more subtle.\n            break;\n          }\n          return clone ? { ...node, parts: [...node.parts] } : node;\n        case \"literal\": {\n          const ul = codePointLen1(node.value);\n          if (ul < 0) {\n            break;\n          }\n          return {\n            type: \"class\",\n            parts: [node.value],\n            inverted: false,\n            ignoreCase: node.ignoreCase,\n            location: node.location,\n            unicode: (ul > 0xFFFF),\n          };\n        }\n        case \"rule_ref\": {\n          const ref = rules[node.name];\n          if (!ref) { // Undefined rule\n            break;\n          }\n          if (!processedRules.has(node.name)) {\n            processedRules.add(node.name);\n            merge(ref);\n          }\n          const cls = asClass(ref, true);\n          if (cls) {\n            cls.location = node.location;\n          }\n          return cls;\n        }\n      }\n      return null;\n    },\n    visitor.build({ // \"merge\"\n      choice(node) {\n        /** @type {PEG.ast.CharacterClass | null} */\n        let prev = null;\n        let changed = false;\n\n        node.alternatives.forEach((alt, i) => {\n          merge(alt);\n          const cls = asClass(alt);\n          if (!cls) {\n            prev = null;\n            return;\n          }\n          if (prev && (prev.ignoreCase === cls.ignoreCase)) {\n            // Combine the two parts sets, leaving two copies of prev\n            // to be cleaned up later.\n            prev.parts.push(...cls.parts);\n            // Leave prev as-is until we decide to merge it with cls.\n            node.alternatives[i - 1] = prev;\n            // Don't change the number of items during foreach\n            node.alternatives[i] = prev;\n            prev.unicode = prev.unicode || cls.unicode;\n            prev.location = {\n              // Fix this when imports work.  Needs a combined source class.\n              source: prev.location.source,\n              start: prev.location.start,\n              end: cls.location.end,\n            };\n            changed = true;\n          } else {\n            prev = cls;\n          }\n        });\n        if (changed) {\n          // Remove dups, these are places where we removed a merged class.\n          node.alternatives = node.alternatives.filter(\n            (alt, i, arr) => !i || alt !== arr[i - 1]\n          );\n          node.alternatives.forEach((alt, i) => {\n            if (alt.type === \"class\") {\n              alt.parts = cleanParts(alt.parts);\n              // Convert single-char classes back to string literals.\n              if (alt.parts.length === 1\n                  && !Array.isArray(alt.parts[0])\n                  && (typeof alt.parts[0] === \"string\")\n                  && !alt.inverted) { // Don't check alt.unicode on purpose\n                node.alternatives[i] = {\n                  type: \"literal\",\n                  value: alt.parts[0],\n                  ignoreCase: alt.ignoreCase,\n                  location: alt.location,\n                };\n              }\n            }\n          });\n          if (node.alternatives.length === 1) {\n            cloneOver(node, node.alternatives[0]);\n          }\n        }\n      },\n      text(node) {\n        merge(node.expression);\n        if (node.expression.type === \"class\"\n            || node.expression.type === \"literal\") {\n          const location = node.location;\n          cloneOver(node, node.expression);\n          node.location = location;\n        }\n      },\n    }),\n  ];\n\n  ast.rules.forEach(rule => {\n    processedRules.add(rule.name);\n    merge(rule.expression);\n  });\n}\n\nmodule.exports = mergeCharacterClasses;\n","\"use strict\";\nconst visitor = require(\"../visitor\");\n\n/**\n * Remove rules that cannot be reached from the allowedStartRules.  This\n * includes rules that are never referenced in the input grammar, rules that\n * only they call, and rules removed by previous passes such as\n * remove-proxy-rules and merge-character-classes.\n *\n * @type {PEG.Pass}\n */\nfunction removeUnusedRules(ast, options, session) {\n  const rules = Object.create(null);\n  ast.rules.forEach(rule => { rules[rule.name] = rule; });\n  // Follow the call graph, starting at each of the startRules.\n  // Try to not visit the same portion of the graph more than once.\n  // report-infinite-recursion should have already found and errored\n  // on loops.\n  const queue = [...options.allowedStartRules];\n  const found = new Set();\n  const findRefs = visitor.build({\n    rule_ref(node) {\n      queue.push(node.name);\n    },\n  });\n  while (queue.length) {\n    const r = queue.shift();\n    if (!found.has(r)) {\n      found.add(r);\n      findRefs(rules[r]);\n    }\n  }\n  ast.rules = ast.rules.filter(r => {\n    if (found.has(r.name)) {\n      return true;\n    }\n    session.info(`Removing unused rule: \"${r.name}\"`, r.location);\n    return false;\n  });\n}\n\nmodule.exports = removeUnusedRules;\n","// @ts-check\n\"use strict\";\n\n/** @type {PEG.Pass} */\nfunction reportDuplicateImports(ast, _options, session) {\n  /** @type {Record<string, PEG.LocationRange>} */\n  const all = {};\n\n  for (const imp of ast.imports) {\n    for (const what of imp.what) {\n      if (what.type === \"import_binding_all\") {\n        if (Object.prototype.hasOwnProperty.call(all, what.binding)) {\n          session.error(\n            `Module \"${what.binding}\" is already imported`,\n            what.location,\n            [{\n              message: \"Original module location\",\n              location: all[what.binding],\n            }]\n          );\n        }\n        all[what.binding] = what.location;\n      }\n    }\n  }\n}\n\nmodule.exports = reportDuplicateImports;\n","\"use strict\";\n\nconst visitor = require(\"../visitor\");\n\n// Checks that each label is defined only once within each scope.\nfunction reportDuplicateLabels(ast, options, session) {\n  function cloneEnv(env) {\n    const clone = {};\n\n    Object.keys(env).forEach(name => {\n      clone[name] = env[name];\n    });\n\n    return clone;\n  }\n\n  function checkExpressionWithClonedEnv(node, env) {\n    // eslint-disable-next-line no-use-before-define -- Mutual recursion\n    check(node.expression, cloneEnv(env));\n  }\n\n  const check = visitor.build({\n    rule(node) {\n      check(node.expression, { });\n    },\n\n    choice(node, env) {\n      node.alternatives.forEach(alternative => {\n        check(alternative, cloneEnv(env));\n      });\n    },\n\n    action: checkExpressionWithClonedEnv,\n\n    labeled(node, env) {\n      const label = node.label;\n      if (label && Object.prototype.hasOwnProperty.call(env, label)) {\n        session.error(\n          `Label \"${node.label}\" is already defined`,\n          node.labelLocation,\n          [{\n            message: \"Original label location\",\n            location: env[label],\n          }]\n        );\n      }\n\n      check(node.expression, env);\n\n      env[node.label] = node.labelLocation;\n    },\n\n    text: checkExpressionWithClonedEnv,\n    simple_and: checkExpressionWithClonedEnv,\n    simple_not: checkExpressionWithClonedEnv,\n    optional: checkExpressionWithClonedEnv,\n    zero_or_more: checkExpressionWithClonedEnv,\n    one_or_more: checkExpressionWithClonedEnv,\n    repeated(node, env) {\n      if (node.delimiter) {\n        check(node.delimiter, cloneEnv(env));\n      }\n\n      check(node.expression, cloneEnv(env));\n    },\n    group: checkExpressionWithClonedEnv,\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportDuplicateLabels;\n","\"use strict\";\n\nconst visitor = require(\"../visitor\");\n\n// Checks that each rule is defined only once.\nfunction reportDuplicateRules(ast, options, session) {\n  const rules = {};\n\n  const check = visitor.build({\n    rule(node) {\n      if (Object.prototype.hasOwnProperty.call(rules, node.name)) {\n        session.error(\n          `Rule \"${node.name}\" is already defined`,\n          node.nameLocation,\n          [{\n            message: \"Original rule location\",\n            location: rules[node.name],\n          }]\n        );\n\n        // Do not rewrite original rule location\n        return;\n      }\n\n      rules[node.name] = node.nameLocation;\n    },\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportDuplicateRules;\n","\"use strict\";\n\nconst asts = require(\"../asts\");\nconst visitor = require(\"../visitor\");\n\n// Reports left recursion in the grammar, which prevents infinite recursion in\n// the generated parser.\n//\n// Both direct and indirect recursion is detected. The pass also correctly\n// reports cases like this:\n//\n//   start = \"a\"? start\n//\n// In general, if a rule reference can be reached without consuming any input,\n// it can lead to left recursion.\nfunction reportInfiniteRecursion(ast, options, session) {\n  // Array with rule names for error message\n  const visitedRules = [];\n  // Array with rule_refs for diagnostic\n  const backtraceRefs = [];\n  const seen = new Set();\n\n  const check = visitor.build({\n    rule(node) {\n      if ((session.errors > 0) || seen.has(node.name)) {\n        return;\n      }\n      seen.add(node.name);\n\n      visitedRules.push(node.name);\n      check(node.expression);\n      visitedRules.pop();\n    },\n\n    sequence(node) {\n      if (session.errors > 0) {\n        return;\n      }\n      node.elements.every(element => {\n        check(element);\n        if (session.errors > 0) {\n          return false;\n        }\n        return !asts.alwaysConsumesOnSuccess(ast, element);\n      });\n    },\n\n    repeated(node) {\n      if (session.errors > 0) {\n        return;\n      }\n      check(node.expression);\n\n      // If an expression does not consume input then recursion\n      // over delimiter is possible\n      if (node.delimiter\n       && !asts.alwaysConsumesOnSuccess(ast, node.expression)\n      ) {\n        check(node.delimiter);\n      }\n    },\n\n    rule_ref(node) {\n      if (session.errors > 0) {\n        return;\n      }\n\n      backtraceRefs.push(node);\n\n      const rule = asts.findRule(ast, node.name);\n\n      if (visitedRules.indexOf(node.name) !== -1) {\n        visitedRules.push(node.name);\n\n        session.error(\n          \"Possible infinite loop when parsing (left recursion: \"\n            + visitedRules.join(\" -> \")\n            + \")\",\n          rule.nameLocation,\n          backtraceRefs.map((ref, i, a) => ({\n            message: i + 1 !== a.length\n              ? `Step ${i + 1}: call of the rule \"${ref.name}\" without input consumption`\n              : `Step ${i + 1}: calls itself without input consumption - left recursion`,\n            location: ref.location,\n          }))\n        );\n\n        // Because we enter into recursion we should break it\n        return;\n      }\n\n      // Because we run all checks in one stage, some rules could be missing - this check\n      // executed in parallel\n      if (rule) {\n        check(rule);\n      }\n      backtraceRefs.pop();\n    },\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportInfiniteRecursion;\n","\"use strict\";\n\nconst asts = require(\"../asts\");\nconst visitor = require(\"../visitor\");\n\n// Reports expressions that don't consume any input inside |*|, |+| or repeated in the\n// grammar, which prevents infinite loops in the generated parser.\nfunction reportInfiniteRepetition(ast, options, session) {\n  const check = visitor.build({\n    zero_or_more(node) {\n      if (!asts.alwaysConsumesOnSuccess(ast, node.expression)) {\n        session.error(\n          \"Possible infinite loop when parsing (repetition used with an expression that may not consume any input)\",\n          node.location\n        );\n      }\n    },\n\n    one_or_more(node) {\n      if (!asts.alwaysConsumesOnSuccess(ast, node.expression)) {\n        session.error(\n          \"Possible infinite loop when parsing (repetition used with an expression that may not consume any input)\",\n          node.location\n        );\n      }\n    },\n\n    repeated(node) {\n      // No need to check min or max.  They can only be numbers, variable\n      // names, or code blocks.\n\n      if (node.delimiter) {\n        check(node.delimiter);\n      }\n      if (asts.alwaysConsumesOnSuccess(ast, node.expression)\n          || (node.delimiter\n              && asts.alwaysConsumesOnSuccess(ast, node.delimiter))) {\n        return;\n      }\n      if (node.max.value === null) {\n        session.error(\n          \"Possible infinite loop when parsing (unbounded range repetition used with an expression that may not consume any input)\",\n          node.location\n        );\n      } else {\n        // If minimum is `null` it is equals to maximum (parsed from `|exact|` syntax)\n        const min = node.min ? node.min : node.max;\n\n        // Because the high boundary is defined, infinity repetition is not possible\n        // but the grammar will waste of CPU\n        session.warning(\n          min.type === \"constant\" && node.max.type === \"constant\"\n            ? `An expression may not consume any input and may always match ${node.max.value} times`\n            : \"An expression may not consume any input and may always match with a maximum repetition count\",\n          node.location\n        );\n      }\n    },\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportInfiniteRepetition;\n","\"use strict\";\n\nconst asts = require(\"../asts\");\nconst visitor = require(\"../visitor\");\n\n// Checks that all referenced rules exist.\nfunction reportUndefinedRules(ast, options, session) {\n  const check = visitor.build({\n    rule_ref(node) {\n      if (!asts.findRule(ast, node.name)) {\n        session.error(\n          `Rule \"${node.name}\" is not defined`,\n          node.location\n        );\n      }\n    },\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportUndefinedRules;\n","\"use strict\";\n\nconst visitor = require(\"../visitor\");\n\n//\n// Compiler pass to ensure the following are enforced:\n//\n//   - plucking can not be done with an action block\n//\nfunction reportIncorrectPlucking(ast, options, session) {\n  const check = visitor.build({\n    action(node) {\n      check(node.expression, node);\n    },\n\n    labeled(node, action) {\n      if (node.pick) {\n        if (action) {\n          session.error(\n            \"\\\"@\\\" cannot be used with an action block\",\n            node.labelLocation,\n            [{\n              message: \"Action block location\",\n              location: action.codeLocation,\n            }]\n          );\n        }\n      }\n\n      check(node.expression);\n    },\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportIncorrectPlucking;\n","// @ts-check\n\"use strict\";\n\nconst visitor = require(\"../visitor\");\nconst { ALWAYS_MATCH, NEVER_MATCH } = require(\"./inference-match-result\");\n\n/** @type {PEG.Pass} */\nfunction reportUnreachable(ast, options, session) {\n  const visit = visitor.build({\n    /**\n     * @param {PEG.ast.Choice} node\n     */\n    choice(node) {\n      node.alternatives.forEach(a => visit(a));\n      for (let i = 0; i < node.alternatives.length - 1; i++) {\n        const alt = node.alternatives[i];\n        if (alt.match === ALWAYS_MATCH) {\n          session.warning(\n            \"Always matches.  Following alternatives may not be reachable.\",\n            alt.location\n          );\n        }\n      }\n    },\n    /**\n     * @param {PEG.ast.Prefixed} node\n     */\n    simple_and(node) {\n      visit(node.expression);\n      if (node.expression.match === ALWAYS_MATCH) {\n        session.warning(\n          \"Always matches, making the & predicate redundant.\",\n          node.expression.location\n        );\n      } else if (node.expression.match === NEVER_MATCH) {\n        session.warning(\n          \"Never matches, making the & predicate always fail.\",\n          node.expression.location\n        );\n      }\n    },\n    /**\n     * @param {PEG.ast.Prefixed} node\n     */\n    simple_not(node) {\n      visit(node.expression);\n      if (node.expression.match === ALWAYS_MATCH) {\n        session.warning(\n          \"Always matches, making the ! predicate always fail.\",\n          node.expression.location\n        );\n      } else if (node.expression.match === NEVER_MATCH) {\n        session.warning(\n          \"Never matches, making the ! predicate redundant.\",\n          node.expression.location\n        );\n      }\n    },\n  });\n  visit(ast);\n}\n\nmodule.exports = reportUnreachable;\n","\"use strict\";\n\nconst GrammarError = require(\"../grammar-error\");\n\nclass Defaults {\n  constructor(options) {\n    options = typeof options !== \"undefined\" ? options : {};\n\n    if (typeof options.error === \"function\") { this.error = options.error; }\n    if (typeof options.warning === \"function\") { this.warning = options.warning; }\n    if (typeof options.info === \"function\") { this.info = options.info; }\n  }\n\n  // eslint-disable-next-line class-methods-use-this -- Abstract\n  error() {\n    // Intentionally empty placeholder\n  }\n\n  // eslint-disable-next-line class-methods-use-this -- Abstract\n  warning() {\n    // Intentionally empty placeholder\n  }\n\n  // eslint-disable-next-line class-methods-use-this -- Abstract\n  info() {\n    // Intentionally empty placeholder\n  }\n}\n\nclass Session {\n  constructor(options) {\n    this._callbacks = new Defaults(options);\n    this._firstError = null;\n    this.errors = 0;\n    /** @type {import(\"../peg\").Problem[]} */\n    this.problems = [];\n    /** @type {import(\"../peg\").Stage} */\n    this.stage = null;\n  }\n\n  error(...args) {\n    ++this.errors;\n    // In order to preserve backward compatibility we cannot change `GrammarError`\n    // constructor, nor throw another class of error:\n    // - if we change `GrammarError` constructor, this will break plugins that\n    //   throws `GrammarError`\n    // - if we throw another Error class, this will break parser clients that\n    //   catches GrammarError\n    //\n    // So we use a compromise: we throw an `GrammarError` with all found problems\n    // in the `problems` property, but the thrown error itself is the first\n    // registered error.\n    //\n    // Thus when the old client catches the error it can find all properties on\n    // the Grammar error that it want. On the other hand the new client can\n    // inspect the `problems` property to get all problems.\n    if (this._firstError === null) {\n      this._firstError = new GrammarError(...args);\n      this._firstError.stage = this.stage;\n      this._firstError.problems = this.problems;\n    }\n\n    this.problems.push([\"error\", ...args]);\n    this._callbacks.error(this.stage, ...args);\n  }\n\n  warning(...args) {\n    this.problems.push([\"warning\", ...args]);\n    this._callbacks.warning(this.stage, ...args);\n  }\n\n  info(...args) {\n    this.problems.push([\"info\", ...args]);\n    this._callbacks.info(this.stage, ...args);\n  }\n\n  checkErrors() {\n    if (this.errors !== 0) {\n      throw this._firstError;\n    }\n  }\n}\n\nmodule.exports = Session;\n","\"use strict\";\n\nconst addImportedRules = require(\"./passes/add-imported-rules\");\nconst fixLibraryNumbers = require(\"./passes/fix-library-numbers\");\nconst generateBytecode = require(\"./passes/generate-bytecode\");\nconst generateJS = require(\"./passes/generate-js\");\nconst inferenceMatchResult = require(\"./passes/inference-match-result\");\nconst removeProxyRules = require(\"./passes/remove-proxy-rules\");\nconst mergeCharacterClasses = require(\"./passes/merge-character-classes\");\nconst removeUnusedRules = require(\"./passes/remove-unused-rules\");\nconst reportDuplicateImports = require(\"./passes/report-duplicate-imports\");\nconst reportDuplicateLabels = require(\"./passes/report-duplicate-labels\");\nconst reportDuplicateRules = require(\"./passes/report-duplicate-rules\");\nconst reportInfiniteRecursion = require(\"./passes/report-infinite-recursion\");\nconst reportInfiniteRepetition = require(\"./passes/report-infinite-repetition\");\nconst reportUndefinedRules = require(\"./passes/report-undefined-rules\");\nconst reportIncorrectPlucking = require(\"./passes/report-incorrect-plucking\");\nconst reportUnreachable = require(\"./passes/report-unreachable\");\nconst Session = require(\"./session\");\nconst visitor = require(\"./visitor\");\nconst { base64 } = require(\"./utils\");\n\nfunction processOptions(options, defaults) {\n  const processedOptions = {};\n\n  Object.keys(options).forEach(name => {\n    processedOptions[name] = options[name];\n  });\n\n  Object.keys(defaults).forEach(name => {\n    if (!Object.prototype.hasOwnProperty.call(processedOptions, name)) {\n      processedOptions[name] = defaults[name];\n    }\n  });\n\n  return processedOptions;\n}\n\nfunction isSourceMapCapable(target) {\n  if (typeof target === \"string\") {\n    return target.length > 0;\n  }\n  return target && (typeof target.offset === \"function\");\n}\n\nconst compiler = {\n  // AST node visitor builder. Useful mainly for plugins which manipulate the\n  // AST.\n  visitor,\n\n  // Compiler passes.\n  //\n  // Each pass is a function that is passed the AST. It can perform checks on it\n  // or modify it as needed. If the pass encounters a semantic error, it throws\n  // |peg.GrammarError|.\n  passes: {\n    prepare: [\n      addImportedRules,\n      reportInfiniteRecursion,\n    ],\n    check: [\n      reportUndefinedRules,\n      reportDuplicateRules,\n      reportDuplicateLabels,\n      reportInfiniteRepetition,\n      reportIncorrectPlucking,\n      reportDuplicateImports,\n    ],\n    transform: [\n      fixLibraryNumbers,\n      removeProxyRules,\n      mergeCharacterClasses,\n      removeUnusedRules,\n      inferenceMatchResult,\n    ],\n    semantic: [\n      reportUnreachable, // Not a transform, but has to be after inferenceMatchResult\n    ],\n    generate: [\n      generateBytecode,\n      generateJS,\n    ],\n  },\n\n  // Generates a parser from a specified grammar AST. Throws |peg.GrammarError|\n  // if the AST contains a semantic error. Note that not all errors are detected\n  // during the generation and some may protrude to the generated parser and\n  // cause its malfunction.\n  compile(ast, passes, options) {\n    options = options !== undefined ? options : {};\n\n    const defaultStartRules = [ast.rules[0].name];\n    options = processOptions(options, {\n      allowedStartRules: defaultStartRules,\n      cache: false,\n      dependencies: {},\n      exportVar: null,\n      format: \"bare\",\n      output: \"parser\",\n      trace: false,\n    });\n\n    if (options.allowedStartRules === null\n        || options.allowedStartRules === undefined) {\n      options.allowedStartRules = defaultStartRules;\n    }\n\n    if (!Array.isArray(options.allowedStartRules)) {\n      throw new Error(\"allowedStartRules must be an array\");\n    }\n    if (options.allowedStartRules.length === 0) {\n      options.allowedStartRules = defaultStartRules;\n    }\n    const allRules = ast.rules.map(r => r.name);\n    // \"*\" means all rules are start rules.  \"*\" is not a valid rule name.\n    if (options.allowedStartRules.some(r => r === \"*\")) {\n      options.allowedStartRules = allRules;\n    } else {\n      for (const rule of options.allowedStartRules) {\n        if (allRules.indexOf(rule) === -1) {\n          throw new Error(`Unknown start rule \"${rule}\"`);\n        }\n      }\n    }\n    // Due to https://github.com/mozilla/source-map/issues/444\n    // grammarSource is required\n    if (((options.output === \"source-and-map\")\n         || (options.output === \"source-with-inline-map\"))\n        && !isSourceMapCapable(options.grammarSource)) {\n      throw new Error(\"Must provide grammarSource (as a string or GrammarLocation) in order to generate source maps\");\n    }\n\n    const session = new Session(options);\n    Object.keys(passes).forEach(stage => {\n      session.stage = stage;\n      session.info(`Process stage ${stage}`);\n\n      passes[stage].forEach(pass => {\n        session.info(`Process pass ${stage}.${pass.name}`);\n\n        pass(ast, options, session);\n      });\n\n      // Collect all errors by stage\n      session.checkErrors();\n    });\n\n    switch (options.output) {\n      case \"parser\":\n        // eslint-disable-next-line no-eval -- Required\n        return eval(ast.code.toString());\n\n      case \"source\":\n        return ast.code.toString();\n\n      case \"source-and-map\":\n        return ast.code;\n\n      case \"source-with-inline-map\": {\n        if (typeof TextEncoder === \"undefined\") {\n          throw new Error(\"TextEncoder is not supported by this platform\");\n        }\n        const sourceMap = ast.code.toStringWithSourceMap();\n        const encoder = new TextEncoder();\n        const b64 = base64(\n          encoder.encode(JSON.stringify(sourceMap.map.toJSON()))\n        );\n        return sourceMap.code + `\\\n//\\x23 sourceMappingURL=data:application/json;charset=utf-8;base64,${b64}\n`;\n      }\n\n      case \"ast\":\n        return ast;\n\n      default:\n        throw new Error(\"Invalid output format: \" + options.output + \".\");\n    }\n  },\n};\n\nmodule.exports = compiler;\n","\"use strict\";\n\nconst GrammarError = require(\"./grammar-error\");\nconst GrammarLocation = require(\"./grammar-location\");\nconst asts = require(\"./compiler/asts.js\");\nconst compiler = require(\"./compiler\");\nconst parser = require(\"./parser\");\nconst { version: VERSION } = require(\"./version\");\n\nconst RESERVED_WORDS = [\n  // Reserved keywords as of ECMAScript 2015\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"class\",\n  \"const\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"delete\",\n  \"do\",\n  \"else\",\n  \"export\",\n  \"extends\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"import\",\n  \"in\",\n  \"instanceof\",\n  \"new\",\n  \"return\",\n  \"super\",\n  \"switch\",\n  \"this\",\n  \"throw\",\n  \"try\",\n  \"typeof\",\n  \"var\",\n  \"void\",\n  \"while\",\n  \"with\",\n\n  // Special constants\n  \"null\",\n  \"true\",\n  \"false\",\n\n  // These are always reserved:\n  \"enum\",\n\n  // The following are only reserved when they are found in strict mode code\n  // Peggy generates code in strict mode, so they are applicable\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  \"yield\",\n\n  // The following are only reserved when they are found in module code:\n  \"await\",\n\n  // The following are reserved as future keywords by ECMAScript 1..3\n  // specifications, but not any more in modern ECMAScript. We don't need these\n  // because the code-generation of Peggy only targets ECMAScript >= 5.\n  //\n  // - abstract\n  // - boolean\n  // - byte\n  // - char\n  // - double\n  // - final\n  // - float\n  // - goto\n  // - int\n  // - long\n  // - native\n  // - short\n  // - synchronized\n  // - throws\n  // - transient\n  // - volatile\n\n  // These are not reserved keywords, but using them as variable names is problematic.\n  \"arguments\", // Conflicts with a special variable available inside functions.\n  \"eval\", // Redeclaring eval() is prohibited in strict mode\n\n  // A few identifiers have a special meaning in some contexts without being\n  // reserved words of any kind. These we don't need to worry about as they can\n  // all be safely used as variable names.\n  //\n  // - as\n  // - async\n  // - from\n  // - get\n  // - of\n  // - set\n];\n\nconst peg = {\n  // Peggy version (filled in by /tools/release).\n  VERSION,\n  /**\n   * Default list of reserved words. Contains list of currently and future\n   * JavaScript (ECMAScript 2015) reserved words.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words\n   */\n  RESERVED_WORDS,\n  GrammarError,\n  GrammarLocation,\n  parser,\n  compiler,\n\n  // Generates a parser from a specified grammar and returns it.\n  //\n  // The grammar must be a string in the format described by the meta-grammar in\n  // the parser.pegjs file.\n  //\n  // Throws |peg.parser.SyntaxError| if the grammar contains a syntax error or\n  // |peg.GrammarError| if it contains a semantic error. Note that not all\n  // errors are detected during the generation and some may protrude to the\n  // generated parser and cause its malfunction.\n  generate(grammar, options) {\n    options = options !== undefined ? options : {};\n\n    function copyPasses(passes) {\n      const converted = {};\n      Object.keys(passes).forEach(stage => {\n        converted[stage] = passes[stage].slice();\n      });\n\n      return converted;\n    }\n\n    const plugins = \"plugins\" in options ? options.plugins : [];\n    const config = {\n      parser: peg.parser,\n      passes: copyPasses(peg.compiler.passes),\n      reservedWords: peg.RESERVED_WORDS.slice(),\n    };\n\n    plugins.forEach(p => { p.use(config, options); });\n\n    if (!Array.isArray(grammar)) {\n      grammar = [{\n        source: options.grammarSource,\n        text: grammar,\n      }];\n    }\n\n    const combined = asts.combine(\n      grammar.map(({ source, text }) => config.parser.parse(text, {\n        grammarSource: source,\n        reservedWords: config.reservedWords,\n      }))\n    );\n\n    return peg.compiler.compile(\n      combined,\n      config.passes,\n      options\n    );\n  },\n};\n\nmodule.exports = peg;\n","#!/usr/bin/env node\r\nimport fs from 'node:fs/promises';\r\nimport { watchFile } from 'node:fs';\r\nimport { argv } from 'node:process';\r\n\r\nimport {\r\n  compileGrammarFromFile,\r\n  validateGrammar,\r\n  analyzeGrammarAdvanced,\r\n} from '../grammar/index.js';\r\n\r\nimport Parser from '../parser/index.js';\r\n\r\n// FIX: Ensure toParseError and formatCompilationError are imported\r\n// Adjust the import path if your utility file is named error-utils.js/ts\r\nimport { formatError, formatCompilationError } from '../utils/index.js';\r\n\r\n// Define the valid format types with const assertion for type safety\r\nconst VALID_FORMATS = ['bare', 'commonjs', 'es', 'globals', 'umd'] as const;\r\ntype OutputFormat = typeof VALID_FORMATS[number];\r\n\r\n// FIX: Remove unused imports for ASTNode and ParseError\r\n// import { ASTNode, } from '../utils/index';\r\n// import { ParseError } from '../parser/index.js';\r\n\r\n\r\nfunction printHelp() {\r\n  console.log(`\r\nUsage: parsergen <grammar.peg> [options]\r\n\r\nOptions:\r\n  --test <input>          Test grammar by parsing input string\r\n  --validate              Only validate grammar (no parsing)\r\n  --analyze               Show grammar metadata\r\n  --out <file>            Output compiled parser as JS\r\n  --format <target>       Format for output: ${VALID_FORMATS.join(' | ')} (default: es)\r\n  --ast                   Print parse AST\r\n  --watch                 Watch grammar file and auto-recompile\r\n  --help, -h              Show help\r\n`);\r\n}\r\n\r\nfunction isValidFormat(format: string): format is OutputFormat {\r\n  return VALID_FORMATS.includes(format as OutputFormat);\r\n}\r\n\r\nasync function compileAndWrite(grammarPath: string, outFile: string, format: OutputFormat) {\r\n  const grammarText = await fs.readFile(grammarPath, 'utf-8');\r\n\r\n  // Import Peggy directly to generate source code\r\n  const PEG = await import('peggy');\r\n\r\n  // Create format-specific options for Peggy\r\n  const baseOptions = {\r\n    allowedStartRules: ['*'],\r\n    cache: false,\r\n    optimize: 'speed' as const,\r\n    output: 'source' as const,\r\n    trace: false,\r\n  };\r\n\r\n  let compiledSource: string;\r\n\r\n  // Handle each format with proper typing\r\n  switch (format) {\r\n    case 'bare':\r\n      compiledSource = PEG.generate(grammarText, {\r\n        ...baseOptions,\r\n        format: 'bare' as const,\r\n      });\r\n      break;\r\n    case 'commonjs':\r\n      compiledSource = PEG.generate(grammarText, {\r\n        ...baseOptions,\r\n        format: 'commonjs' as const,\r\n      });\r\n      break;\r\n    case 'es':\r\n      compiledSource = PEG.generate(grammarText, {\r\n        ...baseOptions,\r\n        format: 'es' as const,\r\n      });\r\n      break;\r\n    case 'globals':\r\n      compiledSource = PEG.generate(grammarText, {\r\n        ...baseOptions,\r\n        format: 'globals' as const,\r\n        exportVar: 'Parser', // Required for globals format\r\n      });\r\n      break;\r\n    case 'umd':\r\n      compiledSource = PEG.generate(grammarText, {\r\n        ...baseOptions,\r\n        format: 'umd' as const,\r\n        exportVar: 'Parser', // Also required for UMD format\r\n      });\r\n      break;\r\n    default:\r\n      // This case should ideally not be reached due to isValidFormat check\r\n      throw new Error(`Unsupported format: ${format}`);\r\n  }\r\n\r\n  await fs.writeFile(outFile, compiledSource, 'utf-8');\r\n  console.log(`✅ Rebuilt parser: ${outFile}`);\r\n}\r\n\r\nasync function main() {\r\n  const args = argv.slice(2);\r\n  const grammarPath = args[0];\r\n\r\n  if (!grammarPath || args.includes('--help') || args.includes('-h')) {\r\n    printHelp();\r\n    return;\r\n  }\r\n\r\n  const grammarText = await fs.readFile(grammarPath, 'utf-8');\r\n\r\n  // Validate\r\n  if (args.includes('--validate')) {\r\n    const result = validateGrammar(grammarText);\r\n    if (result.valid) {\r\n      console.log('✅ Grammar is valid.');\r\n    } else {\r\n      console.error('❌ Grammar is invalid:\\n' + result.error);\r\n    }\r\n    process.exit(result.valid ? 0 : 1);\r\n  }\r\n\r\n  // Analyze\r\n  if (args.includes('--analyze')) {\r\n    console.log('📊 Metadata:', analyzeGrammarAdvanced(grammarText));\r\n    return;\r\n  }\r\n\r\n  const outIndex = args.indexOf('--out');\r\n  const outFile = outIndex !== -1 ? args[outIndex + 1] : null;\r\n\r\n  const formatIndex = args.indexOf('--format');\r\n  const formatArg = formatIndex !== -1 ? args[formatIndex + 1] : 'es';\r\n\r\n  // Validate format argument\r\n  if (!isValidFormat(formatArg)) {\r\n    console.error(`❌ Invalid format: ${formatArg}. Valid formats: ${VALID_FORMATS.join(', ')}`);\r\n    process.exit(1);\r\n  }\r\n\r\n  const format: OutputFormat = formatArg;\r\n\r\n  // Watch mode\r\n  if (args.includes('--watch') && outFile) {\r\n    console.log(`👀 Watching ${grammarPath}...`);\r\n    await compileAndWrite(grammarPath, outFile, format);\r\n    watchFile(grammarPath, { interval: 300 }, async () => {\r\n      try {\r\n        await compileAndWrite(grammarPath, outFile, format);\r\n      } catch (err: unknown) { // Use 'unknown' for caught errors\r\n        // FIX: Use formatCompilationError to handle the error and provide the grammar text\r\n        console.error('❌ Error during rebuild:\\n' + formatCompilationError(err, grammarText));\r\n      }\r\n    });\r\n    return;\r\n  }\r\n\r\n  // Normal out compile\r\n  if (outFile) {\r\n    await compileAndWrite(grammarPath, outFile, format);\r\n    return;\r\n  }\r\n\r\n  // Default: compile and optionally test\r\n  const parser = await compileGrammarFromFile(grammarPath);\r\n  console.log(`✅ Grammar compiled: ${grammarPath}`);\r\n\r\n  const testIndex = args.indexOf('--test');\r\n  if (testIndex !== -1 && args[testIndex + 1]) {\r\n    const input = args[testIndex + 1];\r\n    const result = Parser.parseInput(parser, input);\r\n\r\n    if (!Parser.ParserUtils.isParseError(result)) { // Type of 'result' is now ParseResult<ASTNode> in this block\r\n      console.log('✅ Parse Success');\r\n      if (args.includes('--ast')) {\r\n        console.log(JSON.stringify(result.result, null, 2));\r\n      }\r\n    } else { // Type of 'result' is now ParseError in this block\r\n      console.error('❌ Parse Error:\\n' + formatError(result));\r\n      process.exit(1);\r\n    }\r\n  } else {\r\n    console.log('ℹ️  No --test provided. Grammar OK.');\r\n  }\r\n}\r\n\r\nmain();","import type { Location } from './types';\r\nimport * as colors from 'colorette'; // Use colorette\r\n\r\n/**\r\n * Highlight the source input with a caret (^) and optional colorization\r\n */\r\nexport function highlightSnippet(input: string, location: Location, useColor = true): string {\r\n  const lines = input.split('\\n');\r\n  const lineNum = location.start.line;\r\n  const colNum = location.start.column;\r\n\r\n  if (lineNum < 1 || lineNum > lines.length) return '';\r\n\r\n  const targetLine = lines[lineNum - 1];\r\n\r\n  const prefix = `${lineNum}: `;\r\n  const pointerLine = ' '.repeat(prefix.length + colNum - 1) + '^';\r\n\r\n  const lineStr = useColor\r\n    ? prefix + colors.red(targetLine) // Using colors.red (colorette's default red is bright)\r\n    : prefix + targetLine;\r\n\r\n  const pointerStr = useColor\r\n    ? colors.yellow(pointerLine)\r\n    : pointerLine;\r\n\r\n  const resultLines = [];\r\n\r\n  if (lineNum > 1) resultLines.push(`${lineNum - 1}: ${lines[lineNum - 2]}`);\r\n  resultLines.push(lineStr);\r\n  resultLines.push(pointerStr);\r\n  if (lineNum < lines.length) resultLines.push(`${lineNum + 1}: ${lines[lineNum]}`);\r\n\r\n  return resultLines.join('\\n');\r\n}\r\n\r\n/**\r\n * Enhanced snippet highlighting with range support and more context\r\n */\r\nexport function highlightSnippetAdvanced(\r\n  input: string,\r\n  location: Location,\r\n  options: {\r\n    useColor?: boolean;\r\n    contextLines?: number;\r\n    showLineNumbers?: boolean;\r\n    highlightRange?: boolean;\r\n    maxLineLength?: number;\r\n  } = {}\r\n): string {\r\n  const {\r\n    useColor = true,\r\n    contextLines = 1,\r\n    showLineNumbers = true,\r\n    highlightRange = true,\r\n    maxLineLength = 120\r\n  } = options;\r\n\r\n  const lines = input.split('\\n');\r\n  const startLine = location.start.line;\r\n  const endLine = location.end.line;\r\n  const startCol = location.start.column;\r\n  const endCol = location.end.column;\r\n\r\n  if (startLine < 1 || startLine > lines.length) return '';\r\n\r\n  const firstLine = Math.max(1, startLine - contextLines);\r\n  const lastLine = Math.min(lines.length, endLine + contextLines);\r\n\r\n  const resultLines: string[] = [];\r\n  const maxLineNumWidth = lastLine.toString().length;\r\n\r\n  for (let i = firstLine; i <= lastLine; i++) {\r\n    const line = lines[i - 1];\r\n    const truncatedLine = line.length > maxLineLength\r\n      ? line.substring(0, maxLineLength) + '...'\r\n      : line;\r\n\r\n    const lineNumStr = showLineNumbers\r\n      ? `${i.toString().padStart(maxLineNumWidth)}: `\r\n      : '';\r\n\r\n    let displayLine = truncatedLine;\r\n\r\n    // Highlight the error range\r\n    if (highlightRange && i >= startLine && i <= endLine) {\r\n      if (useColor) {\r\n        if (i === startLine && i === endLine) {\r\n          // Single line highlight\r\n          const before = displayLine.substring(0, startCol - 1);\r\n          const highlight = displayLine.substring(startCol - 1, endCol - 1);\r\n          const after = displayLine.substring(endCol - 1);\r\n          displayLine = before + colors.bgRed(highlight) + after;\r\n        } else if (i === startLine) {\r\n          // First line of multi-line highlight\r\n          const before = displayLine.substring(0, startCol - 1);\r\n          const highlight = displayLine.substring(startCol - 1);\r\n          displayLine = before + colors.bgRed(highlight);\r\n        } else if (i === endLine) {\r\n          // Last line of multi-line highlight\r\n          const highlight = displayLine.substring(0, endCol - 1);\r\n          const after = displayLine.substring(endCol - 1);\r\n          displayLine = colors.bgRed(highlight) + after;\r\n        } else {\r\n          // Middle lines of multi-line highlight\r\n          displayLine = colors.bgRed(displayLine);\r\n        }\r\n      }\r\n    }\r\n\r\n    const fullLine = useColor && (i >= startLine && i <= endLine)\r\n      ? lineNumStr + displayLine\r\n      : lineNumStr + displayLine;\r\n\r\n    resultLines.push(fullLine);\r\n\r\n    // Add pointer line for single-line errors\r\n    if (i === startLine && startLine === endLine && highlightRange) {\r\n      const pointerStart = lineNumStr.length + startCol - 1;\r\n      const pointerLength = Math.max(1, endCol - startCol);\r\n      const pointer = ' '.repeat(pointerStart) + '^'.repeat(pointerLength);\r\n\r\n      resultLines.push(useColor ? colors.yellow(pointer) : pointer);\r\n    }\r\n  }\r\n\r\n  return resultLines.join('\\n');\r\n}\r\n\r\n/**\r\n * Highlight multiple locations in the same input\r\n */\r\nexport function highlightMultipleLocations(\r\n  input: string,\r\n  locations: Array<{ location: Location; label?: string; color?: string }>,\r\n  options: {\r\n    useColor?: boolean;\r\n    contextLines?: number;\r\n    showLineNumbers?: boolean;\r\n  } = {}\r\n): string {\r\n  const { useColor = true, contextLines = 1, showLineNumbers = true } = options;\r\n\r\n  const lines = input.split('\\n');\r\n  const colorNames = ['red', 'blue', 'green', 'yellow', 'magenta', 'cyan'] as const;\r\n\r\n  type ColoretteStyleName = typeof colorNames[number];\r\n\r\n  const sortedLocations = [...locations].sort((a, b) =>\r\n    a.location.start.line - b.location.start.line\r\n  );\r\n\r\n  const firstLine = Math.max(1,\r\n    Math.min(...sortedLocations.map(l => l.location.start.line)) - contextLines\r\n  );\r\n  const lastLine = Math.min(lines.length,\r\n    Math.max(...sortedLocations.map(l => l.location.end.line)) + contextLines\r\n  );\r\n\r\n  const resultLines: string[] = [];\r\n  const maxLineNumWidth = lastLine.toString().length;\r\n\r\n  for (let i = firstLine; i <= lastLine; i++) {\r\n    const line = lines[i - 1];\r\n    const lineNumStr = showLineNumbers\r\n      ? `${i.toString().padStart(maxLineNumWidth)}: `\r\n      : '';\r\n\r\n    let displayLine = line;\r\n\r\n    const lineLocations = sortedLocations.filter(l =>\r\n      l.location.start.line <= i && l.location.end.line >= i\r\n    );\r\n\r\n    if (useColor && lineLocations.length > 0) {\r\n      lineLocations.sort((a, b) => a.location.start.column - b.location.start.column);\r\n\r\n      let offset = 0;\r\n      for (const [index, { location, color }] of lineLocations.entries()) {\r\n        const colorName = (color || colorNames[index % colorNames.length]) as ColoretteStyleName;\r\n        // Ensure colorFn is a function that takes a string and returns a string\r\n        const colorFn: (text: string) => string = colors[colorName] || colors.red;\r\n\r\n        const startCol = i === location.start.line ? location.start.column - 1 : 0;\r\n        const endCol = i === location.end.line ? location.end.column - 1 : line.length;\r\n\r\n        const before = displayLine.substring(0, startCol + offset);\r\n        const highlight = displayLine.substring(startCol + offset, endCol + offset);\r\n        const after = displayLine.substring(endCol + offset);\r\n\r\n        // FIX: Apply underline as a separate function call to the result of the color function\r\n        displayLine = before + colors.underline(colorFn(highlight)) + after;\r\n        // FIX: Calculate offset using colors.underline directly\r\n        offset += colors.underline('').length;\r\n      }\r\n    }\r\n\r\n    resultLines.push(lineNumStr + displayLine);\r\n\r\n    for (const [index, { location, label }] of lineLocations.entries()) {\r\n      if (i === location.start.line && location.start.line === location.end.line) {\r\n        const colorName = colorNames[index % colorNames.length] as ColoretteStyleName;\r\n        const colorFn: ((text: string) => string) | null = useColor ? (colors[colorName] || colors.red) : null;\r\n\r\n        const pointerStart = lineNumStr.length + location.start.column - 1;\r\n        const pointerLength = Math.max(1, location.end.column - location.start.column);\r\n        const pointer = ' '.repeat(pointerStart) + '^'.repeat(pointerLength);\r\n        const labelStr = label ? ` ${label}` : '';\r\n\r\n        const pointerLine = colorFn\r\n          ? colorFn(pointer + labelStr) // Call the color function directly\r\n          : pointer + labelStr;\r\n\r\n        resultLines.push(pointerLine);\r\n      }\r\n    }\r\n  }\r\n\r\n  return resultLines.join('\\n');\r\n}\r\n\r\n/**\r\n * Simple function to create a snippet without full location data\r\n */\r\nexport function createSnippet(\r\n  input: string,\r\n  line: number,\r\n  column: number,\r\n  useColor = true\r\n): string {\r\n  const location = {\r\n    start: { line, column, offset: 0 },\r\n    end: { line, column, offset: 0 }\r\n  };\r\n  return highlightSnippet(input, location, useColor);\r\n}\r\n\r\n/**\r\n * Get line and column information for a given offset\r\n */\r\nexport function getLocationFromOffset(input: string, offset: number): {\r\n  line: number;\r\n  column: number;\r\n  offset: number;\r\n} {\r\n  const lines = input.substring(0, offset).split('\\n');\r\n  const line = lines.length;\r\n  const column = lines[lines.length - 1].length + 1;\r\n\r\n  return { line, column, offset };\r\n}\r\n\r\n/**\r\n * Get offset from line and column\r\n */\r\nexport function getOffsetFromLocation(input: string, line: number, column: number): number {\r\n  const lines = input.split('\\n');\r\n\r\n  if (line < 1 || line > lines.length) return -1;\r\n  if (column < 1 || column > lines[line - 1].length + 1) return -1;\r\n\r\n  let offset = 0;\r\n  for (let i = 0; i < line - 1; i++) {\r\n    offset += lines[i].length + 1; // +1 for newline\r\n  }\r\n  offset += column - 1;\r\n\r\n  return offset;\r\n}","import type { Location } from './types';\r\nimport type { ParseError } from '../parser/index'; // Consider if this should be from a dedicated types file like '../parser/types'\r\nimport { highlightSnippet } from './highlight';\r\nimport * as colors from 'colorette'; // Correctly imported colorette as 'colors'\r\n\r\n// Type guard to safely check if an error is a ParseError\r\nexport function isParseError(err: unknown): err is ParseError {\r\n    return (\r\n        typeof err === 'object' &&\r\n        err !== null &&\r\n        'error' in err && // Check if 'error' property exists\r\n        typeof (err as Record<string, unknown>).error === 'string' && // Now check its type\r\n        'success' in err &&\r\n        typeof (err as Record<string, unknown>).success === 'boolean'\r\n        // Add other essential ParseError properties if they must exist for it to be a ParseError\r\n    );\r\n}\r\n\r\n// Type guard to check if an error is a Peggy-style error\r\nexport function isPeggyError(err: unknown): boolean {\r\n    return (\r\n        typeof err === 'object' &&\r\n        err !== null &&\r\n        'message' in err &&\r\n        typeof (err as Record<string, unknown>).message === 'string' &&\r\n        ('location' in err || 'expected' in err || 'found' in err)\r\n    );\r\n}\r\n\r\n// Safe wrapper for unknown errors with enhanced Peggy support\r\nexport function toParseError(err: unknown): ParseError {\r\n    // If already a ParseError (type guard)\r\n    if (isParseError(err)) {\r\n        return err;\r\n    }\r\n\r\n    // Peggy-style error\r\n    if (isPeggyError(err)) {\r\n        const peggyError = err as Record<string, unknown>;\r\n        return {\r\n            error: peggyError.message as string,\r\n            location: isValidLocation(peggyError.location) ? (peggyError.location as Location) : undefined,\r\n            success: false,\r\n            expected: Array.isArray(peggyError.expected) ? (peggyError.expected as string[]) : undefined,\r\n            found: typeof peggyError.found === 'string' ? (peggyError.found as string) : undefined,\r\n            input: typeof peggyError.input === 'string' ? (peggyError.input as string) : undefined,\r\n            snippet: undefined\r\n        };\r\n    }\r\n\r\n    // Standard JS Error\r\n    if (err instanceof Error) {\r\n        return {\r\n            error: err.message,\r\n            location: undefined,\r\n            success: false,\r\n            expected: undefined,\r\n            found: undefined,\r\n            input: undefined,\r\n            snippet: undefined\r\n        };\r\n    }\r\n\r\n    // Fallback: unknown or malformed\r\n    return {\r\n        error: typeof err === 'string' ? err : 'Unknown error',\r\n        location: undefined,\r\n        success: false,\r\n        expected: undefined,\r\n        found: undefined,\r\n        input: undefined,\r\n        snippet: undefined\r\n    };\r\n}\r\n\r\n// CORRECTED isValidLocation FUNCTION\r\nfunction isValidLocation(loc: unknown): loc is Location {\r\n    if (typeof loc !== 'object' || loc === null) {\r\n        return false;\r\n    }\r\n\r\n    const locationObject = loc as Record<string, unknown>; // Assert to a record for property access\r\n\r\n    // Check for 'start' and 'end' properties\r\n    if (!('start' in locationObject) || !('end' in locationObject)) {\r\n        return false;\r\n    }\r\n\r\n    const start = locationObject.start;\r\n    const end = locationObject.end;\r\n\r\n    // Check if 'start' is a non-null object\r\n    if (typeof start !== 'object' || start === null) {\r\n        return false;\r\n    }\r\n\r\n    const startObject = start as Record<string, unknown>; // Assert start to a record\r\n    // Check start properties\r\n    if (\r\n        !('line' in startObject) || typeof startObject.line !== 'number' ||\r\n        !('column' in startObject) || typeof startObject.column !== 'number' ||\r\n        !('offset' in startObject) || typeof startObject.offset !== 'number'\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    // Check if 'end' is a non-null object\r\n    if (typeof end !== 'object' || end === null) {\r\n        return false;\r\n    }\r\n\r\n    const endObject = end as Record<string, unknown>; // Assert end to a record\r\n    // Check end properties\r\n    if (\r\n        !('line' in endObject) || typeof endObject.line !== 'number' ||\r\n        !('column' in endObject) || typeof endObject.column !== 'number' ||\r\n        !('offset' in endObject) || typeof endObject.offset !== 'number'\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    return true; // All checks passed\r\n}\r\n// END CORRECTED isValidLocation FUNCTION\r\n\r\nexport function formatLocation(location: Location): string {\r\n    const { start, end } = location;\r\n    return (start.line === end.line && start.column === end.column)\r\n        ? `Line ${start.line}, Col ${start.column}`\r\n        : `Line ${start.line}, Col ${start.column} → Line ${end.line}, Col ${end.column}`;\r\n}\r\n\r\nexport function formatError(error: ParseError): string {\r\n    const errorMessage = error.error || 'Unknown error';\r\n    const parts: string[] = [`❌ Parse Error: ${errorMessage}`];\r\n\r\n    if (error.location) {\r\n        parts.push(`↪ at ${formatLocation(error.location)}`);\r\n    }\r\n\r\n    if (error.expected && error.expected.length > 0) {\r\n        parts.push(`Expected: ${error.expected.join(', ')}`);\r\n    }\r\n\r\n    if (error.found !== undefined) {\r\n        parts.push(`Found: \"${error.found}\"`);\r\n    }\r\n\r\n    if (error.snippet || (error.input && error.location)) {\r\n        try {\r\n            // FIX: Pass false for useColors to highlightSnippet in the non-colored formatError\r\n            const snippet = error.snippet || highlightSnippet(error.input!, error.location!, false);\r\n            parts.push('\\n--- Snippet ---\\n' + snippet);\r\n        } catch {\r\n            parts.push('\\n--- Snippet unavailable ---');\r\n        }\r\n    }\r\n\r\n    return parts.join('\\n');\r\n}\r\n\r\nexport function formatErrorWithColors(error: ParseError, useColors: boolean = true): string {\r\n    if (!useColors) {\r\n        return formatError(error);\r\n    }\r\n\r\n    const errorMessage = error.error || 'Unknown error';\r\n    const parts: string[] = [\r\n        `${colors.red('❌ Parse Error:')} ${errorMessage}` // FIX: Use colors.red\r\n    ];\r\n\r\n    if (error.location) {\r\n        parts.push(`${colors.blue('↪ at')} ${formatLocation(error.location)}`); // FIX: Use colors.blue\r\n    }\r\n\r\n    if (error.expected && error.expected.length > 0) {\r\n        parts.push(`${colors.yellow('Expected:')} ${error.expected.join(', ')}`); // FIX: Use colors.yellow\r\n    }\r\n\r\n    if (error.found !== undefined) {\r\n        parts.push(`${colors.yellow('Found:')} \"${error.found}\"`); // FIX: Use colors.yellow\r\n    }\r\n\r\n    if (error.snippet || (error.input && error.location)) {\r\n        try {\r\n            const snippet = error.snippet || highlightSnippet(error.input!, error.location!, useColors);\r\n            parts.push('\\n' + colors.dim('--- Snippet ---') + '\\n' + snippet); // FIX: Use colors.dim\r\n        } catch {\r\n            parts.push('\\n' + colors.dim('--- Snippet unavailable ---')); // FIX: Use colors.dim\r\n        }\r\n    }\r\n\r\n    return parts.join('\\n');\r\n}\r\n\r\nexport function formatSuccessMessage(message: string): string {\r\n    return colors.green(`✅ ${message}`); // FIX: Use colors.green\r\n}\r\n\r\nexport function formatWarningMessage(message: string): string {\r\n    return colors.yellow(`⚠️  ${message}`); // FIX: Use colors.yellow\r\n}\r\n\r\nexport function formatInfoMessage(message: string): string {\r\n    return colors.blue(`ℹ️  ${message}`); // FIX: Use colors.blue\r\n}\r\n\r\nexport function formatMultipleErrors(errors: ParseError[], useColors: boolean = true): string {\r\n    if (!errors || errors.length === 0) return '';\r\n\r\n    const header = useColors\r\n        ? colors.red(colors.bold(`Found ${errors.length} error${errors.length > 1 ? 's' : ''}:`)) // FIX: Nest colors.red and colors.bold\r\n        : `Found ${errors.length} error${errors.length > 1 ? 's' : ''}:`;\r\n\r\n    const formattedErrors = errors.map((error, index) => {\r\n        const errorNum = useColors\r\n            ? colors.dim(`[${index + 1}/${errors.length}]`) // FIX: Use colors.dim\r\n            : `[${index + 1}/${errors.length}]`;\r\n\r\n        return `${errorNum}\\n${formatErrorWithColors(error, useColors)}`;\r\n    });\r\n\r\n    return [header, ...formattedErrors].join('\\n\\n');\r\n}\r\n\r\nexport function formatAnyError(err: unknown, useColors: boolean = true): string {\r\n    const parseError = toParseError(err);\r\n    return formatErrorWithColors(parseError, useColors);\r\n}\r\n\r\nexport function formatAnyErrors(errors: unknown[], useColors: boolean = true): string {\r\n    if (!errors || errors.length === 0) return '';\r\n\r\n    const parseErrors = errors.map(toParseError);\r\n    return formatMultipleErrors(parseErrors, useColors);\r\n}\r\n\r\nexport function wrapCompilationError(err: unknown, context: string = 'Grammar compilation'): Error {\r\n    const parseError = toParseError(err);\r\n    const formattedError = formatErrorWithColors(parseError, true);\r\n    return new Error(`${context} failed:\\n${formattedError}`);\r\n}\r\n\r\nexport function isGrammarError(err: unknown): boolean {\r\n    if (typeof err === 'object' && err !== null) {\r\n        const message = ('message' in err && typeof (err as Record<string, unknown>).message === 'string')\r\n            ? (err as Record<string, unknown>).message\r\n            : ('error' in err && typeof (err as Record<string, unknown>).error === 'string'\r\n                ? (err as Record<string, unknown>).error\r\n                : '');\r\n        return typeof message === 'string' && /expected.+found/i.test(message);\r\n    }\r\n\r\n    if (err instanceof Error) {\r\n        return /expected.+found/i.test(err.message);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function getErrorSuggestions(error: ParseError): string[] {\r\n    const suggestions: string[] = [];\r\n    const errorMsg = error.error?.toLowerCase() || '';\r\n\r\n    if (errorMsg.includes('expected') && errorMsg.includes('but')) {\r\n        suggestions.push('Check for missing or incorrect syntax near the error location');\r\n    }\r\n\r\n    if (errorMsg.includes('rule') || errorMsg.includes('undefined')) {\r\n        suggestions.push('Verify all referenced rules are defined');\r\n    }\r\n\r\n    if (errorMsg.includes('end of input')) {\r\n        suggestions.push('Check for missing closing brackets, quotes, or semicolons');\r\n    }\r\n\r\n    if (errorMsg.includes('duplicate')) {\r\n        suggestions.push('Remove duplicate rule definitions');\r\n    }\r\n\r\n    if (error.expected && error.expected.length > 0) {\r\n        const expectedItems = error.expected.slice(0, 3).join(', ');\r\n        suggestions.push(`Try using one of: ${expectedItems}`);\r\n    }\r\n\r\n    return suggestions;\r\n}\r\n\r\nexport function formatErrorWithSuggestions(error: ParseError, useColors: boolean = true): string {\r\n    const baseFormatted = formatErrorWithColors(error, useColors);\r\n    const suggestions = getErrorSuggestions(error);\r\n\r\n    if (suggestions.length === 0) {\r\n        return baseFormatted;\r\n    }\r\n\r\n    const suggestionHeader = useColors\r\n        ? colors.cyan('\\n💡 Suggestions:') // FIX: Use colors.cyan\r\n        : '\\n💡 Suggestions:';\r\n\r\n    const formattedSuggestions = suggestions.map((suggestion, index) => {\r\n        const bullet = useColors ? colors.dim(`  ${index + 1}.`) : `  ${index + 1}.`; // FIX: Use colors.dim\r\n        return `${bullet} ${suggestion}`;\r\n    }).join('\\n');\r\n\r\n    return `${baseFormatted}${suggestionHeader}\\n${formattedSuggestions}`;\r\n}\r\n\r\nexport function formatCompilationError(err: unknown, grammarSource?: string): string {\r\n    const parseError = toParseError(err);\r\n\r\n    if (grammarSource && !parseError.input) {\r\n        parseError.input = grammarSource;\r\n    }\r\n\r\n    return formatErrorWithSuggestions(parseError, true);\r\n}\r\n\r\nexport function getErrorContext(error: ParseError): {\r\n    message: string;\r\n    location?: string;\r\n    line?: number;\r\n    column?: number;\r\n    expected?: string[];\r\n    found?: string;\r\n} {\r\n    return {\r\n        message: error.error || 'Unknown error',\r\n        location: error.location ? formatLocation(error.location) : undefined,\r\n        line: error.location?.start?.line,\r\n        column: error.location?.start?.column,\r\n        expected: error.expected,\r\n        found: error.found\r\n    };\r\n}\r\n\r\nexport function formatDebugError(err: unknown): string {\r\n    const parseError = toParseError(err);\r\n    const context = getErrorContext(parseError);\r\n\r\n    const parts = [\r\n        `🐛 Debug Error Information:`,\r\n        `  Message: ${context.message}`,\r\n        `  Location: ${context.location || 'Unknown'}`,\r\n        `  Expected: ${context.expected?.join(', ') || 'Unknown'}`,\r\n        `  Found: ${context.found || 'Unknown'}`,\r\n        `  Original Error Type: ${\r\n            typeof err === 'object' && err !== null && 'constructor' in err\r\n                ? (err as { constructor: { name: string } }).constructor.name\r\n                : typeof err\r\n        }`,\r\n        `  Has Location: ${!!parseError.location}`,\r\n        `  Has Input: ${!!parseError.input}`\r\n    ];\r\n\r\n    if (parseError.input && parseError.location) {\r\n        parts.push(`  Input Length: ${parseError.input.length}`);\r\n        parts.push(`  Error Position: ${parseError.location.start.line}:${parseError.location.start.column}`);\r\n    }\r\n\r\n    return parts.join('\\n');\r\n}","import type { ParserBuildOptions, LocationRange } from 'peggy';\r\nimport { formatError, formatCompilationError, formatAnyError } from '../utils/index';\r\nimport PEG from 'peggy';\r\n\r\nconst generate = PEG.generate;\r\n\r\n// --- Corrected Type Definitions for Error Handling ---\r\n\r\n/**\r\n * Represents the structure of an error expected by the formatting utilities.\r\n * This aligns with the user's 'ParseError' type by including `success` and `error`.\r\n */\r\nexport interface ParseError extends Error {\r\n  message: string;\r\n  location: LocationRange;\r\n  expected?: string[];\r\n  found?: string;\r\n  // Properties required by the consuming formatError functions\r\n  success: false;\r\n  error: string;\r\n}\r\n\r\n/**\r\n * Type guard to check if an error has the shape of a Peggy-generated error.\r\n * @param error The error object to check.\r\n * @returns True if the object has the core Peggy error properties.\r\n */\r\nfunction isParseError(error: unknown): error is ParseError {\r\n  return (\r\n    typeof error === 'object' &&\r\n    error !== null &&\r\n    'message' in error &&\r\n    'location' in error\r\n  );\r\n}\r\n\r\n// --- Interfaces ---\r\n\r\nexport interface Plugin {\r\n  use: (config: { rules: unknown[] }, options: Record<string, unknown>) => void;\r\n  [key: string]: unknown;\r\n}\r\n\r\nexport interface AnalysisResult {\r\n  errors: string[];\r\n  warnings: string[];\r\n}\r\n\r\nexport interface CompiledGrammar<ASTNode = unknown> {\r\n  parse: (input: string, options?: ParserBuildOptions) => ASTNode;\r\n  source: string;\r\n  options: CompileOptions;\r\n  analyze?: (ast: ASTNode) => AnalysisResult;\r\n}\r\n\r\nexport interface CompileOptions {\r\n  allowedStartRules?: string[];\r\n  cache?: boolean;\r\n  dependencies?: Record<string, unknown>;\r\n  exportVar?: string;\r\n  format?: 'bare' | 'commonjs' | 'es' | 'globals' | 'umd';\r\n  grammarSource?: string | LocationRange;\r\n  header?: string | string[];\r\n  optimize?: 'speed' | 'size';\r\n  output?: 'parser' | 'source';\r\n  plugins?: Plugin[];\r\n  trace?: boolean;\r\n}\r\n\r\n// --- Core Functions ---\r\n\r\nexport function compileGrammar<ASTNode = unknown>(\r\n  grammar: string,\r\n  options: CompileOptions = {},\r\n  analyzer?: (ast: ASTNode) => AnalysisResult\r\n): CompiledGrammar<ASTNode> {\r\n  try {\r\n    const defaultOptions: CompileOptions = {\r\n      allowedStartRules: ['*'],\r\n      cache: false,\r\n      format: 'bare',\r\n      optimize: 'speed',\r\n      output: 'parser',\r\n      trace: false,\r\n      ...options,\r\n    };\r\n\r\n    const parser = generate(grammar, defaultOptions as ParserBuildOptions);\r\n    return {\r\n      parse: parser.parse.bind(parser),\r\n      source: grammar,\r\n      options: defaultOptions,\r\n      analyze: analyzer,\r\n    };\r\n  } catch (error: unknown) {\r\n    // Corrected logic: No longer checks for `formatCompilationError` as it's always defined.\r\n    // The type guard now narrows to the `ParseError` interface expected by the formatters.\r\n    const formattedError = isParseError(error)\r\n      ? formatCompilationError(error, grammar)\r\n      : formatAnyError(error);\r\n    throw new Error(`Grammar compilation failed:\\n${formattedError}`);\r\n  }\r\n}\r\n\r\nexport async function compileGrammarFromFile<ASTNode = unknown>(\r\n  filePath: string,\r\n  options: CompileOptions = {},\r\n  analyzer?: (ast: ASTNode) => AnalysisResult\r\n): Promise<CompiledGrammar<ASTNode>> {\r\n  try {\r\n    const fs = await import('fs/promises');\r\n    const grammar = await fs.readFile(filePath, 'utf-8');\r\n    return compileGrammar<ASTNode>(\r\n      grammar,\r\n      {\r\n        ...options,\r\n        grammarSource: filePath,\r\n      },\r\n      analyzer\r\n    );\r\n  } catch (error: unknown) {\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    throw new Error(`Failed to compile grammar from file ${filePath}: ${message}`);\r\n  }\r\n}\r\n\r\nexport function validateGrammar(grammar: string): { valid: boolean; error?: string } {\r\n  try {\r\n    generate(grammar, { output: 'source' });\r\n    return { valid: true };\r\n  } catch (error: unknown) {\r\n    // Use the type guard to safely format the error.\r\n    const message = isParseError(error) ? formatError(error) : formatAnyError(error);\r\n    return {\r\n      valid: false,\r\n      error: String(message),\r\n    };\r\n  }\r\n}\r\n\r\n// --- Analysis Functions (unchanged) ---\r\n\r\nexport interface GrammarAnalysis {\r\n  rules: RuleInfo[];\r\n  startRule?: string;\r\n  dependencies: Map<string, string[]>;\r\n  unreachableRules: string[];\r\n  leftRecursive: string[];\r\n  warnings: string[];\r\n}\r\n\r\nexport interface RuleInfo {\r\n  name: string;\r\n  line: number;\r\n  column: number;\r\n  expression: string;\r\n  references: string[];\r\n  isStartRule: boolean;\r\n  isLeftRecursive: boolean;\r\n}\r\n\r\nexport function analyzeGrammarAdvanced(grammar: string): GrammarAnalysis {\r\n  const lines = grammar.split('\\n');\r\n  const rules: RuleInfo[] = [];\r\n  const dependencies = new Map<string, string[]>();\r\n  const warnings: string[] = [];\r\n\r\n  const ruleDefinitionRegex = /^([a-zA-Z_][a-zA-Z0-9_]*)\\s*(\".*?\")?\\s*=/;\r\n  let currentRuleLines: string[] = [];\r\n  let currentRuleInfo: Omit<RuleInfo, 'expression' | 'references' | 'isLeftRecursive'> | null = null;\r\n\r\n  lines.forEach((line, i) => {\r\n    const ruleMatch = line.match(ruleDefinitionRegex);\r\n    if (ruleMatch) {\r\n      if (currentRuleInfo && currentRuleLines.length > 0) {\r\n        rules.push(finalizeRule(currentRuleInfo, currentRuleLines, rules.length === 0));\r\n      }\r\n      currentRuleInfo = {\r\n        name: ruleMatch[1],\r\n        line: i + 1,\r\n        column: line.indexOf(ruleMatch[1]) + 1,\r\n        isStartRule: false,\r\n      };\r\n      currentRuleLines = [line];\r\n    } else if (currentRuleInfo) {\r\n      currentRuleLines.push(line);\r\n    }\r\n  });\r\n\r\n  if (currentRuleInfo && currentRuleLines.length > 0) {\r\n    rules.push(finalizeRule(currentRuleInfo, currentRuleLines, rules.length === 0));\r\n  }\r\n\r\n  rules.forEach(rule => {\r\n    dependencies.set(rule.name, rule.references);\r\n  });\r\n\r\n  const reachableRules = new Set<string>();\r\n  const startRule = rules.find(r => r.isStartRule);\r\n  if (startRule) {\r\n    findReachableRules(startRule.name, dependencies, reachableRules);\r\n  }\r\n  const unreachableRules = rules.filter(r => !reachableRules.has(r.name)).map(r => r.name);\r\n  const leftRecursive = rules.filter(r => r.isLeftRecursive).map(r => r.name);\r\n\r\n  if (unreachableRules.length > 0) {\r\n    warnings.push(`Unreachable rules found: ${unreachableRules.join(', ')}`);\r\n  }\r\n  if (leftRecursive.length > 0) {\r\n    warnings.push(`Immediate left-recursive rules found: ${leftRecursive.join(', ')}. Peggy handles this, but it can signal complex logic.`);\r\n  }\r\n\r\n  return { rules, startRule: startRule?.name, dependencies, unreachableRules, leftRecursive, warnings };\r\n}\r\n\r\nfunction finalizeRule(info: Omit<RuleInfo, 'expression' | 'references' | 'isLeftRecursive'>, lines: string[], isStart: boolean): RuleInfo {\r\n  const expression = lines.join('\\n');\r\n  const name = info.name;\r\n  return { ...info, expression, references: extractReferences(expression, name), isStartRule: isStart, isLeftRecursive: checkImmediateLeftRecursion(expression, name) };\r\n}\r\n\r\nfunction extractReferences(expression: string, ruleName: string): string[] {\r\n  const grammarOnly = expression.replace(/{[^}]*}/g, ' ').replace(/\"[^\"]*\"/g, ' ').replace(/'[^']*'/g, ' ');\r\n  const matches = grammarOnly.match(/\\b[a-zA-Z_][a-zA-Z0-9_]*\\b/g) || [];\r\n  const references = new Set(matches.filter(m => m !== ruleName));\r\n  return Array.from(references);\r\n}\r\n\r\nfunction checkImmediateLeftRecursion(expression: string, ruleName: string): boolean {\r\n  const body = expression.substring(expression.indexOf('=') + 1);\r\n  const alternatives = body.split('/');\r\n  return alternatives.some(alt => {\r\n    const trimmedAlt = alt.trim();\r\n    return trimmedAlt.startsWith(ruleName) && !trimmedAlt.startsWith(ruleName + '_');\r\n  });\r\n}\r\n\r\nfunction findReachableRules(ruleName: string, dependencies: Map<string, string[]>, reachable: Set<string>): void {\r\n  if (reachable.has(ruleName) || !dependencies.has(ruleName)) return;\r\n  reachable.add(ruleName);\r\n  const deps = dependencies.get(ruleName) || [];\r\n  for (const dep of deps) {\r\n    findReachableRules(dep, dependencies, reachable);\r\n  }\r\n}\r\n\r\n// --- Grammar Builder Class (unchanged) ---\r\n\r\nexport class GrammarBuilder<ASTNode = unknown> {\r\n  private rules: string[] = [];\r\n  private headers: string[] = [];\r\n  private options: CompileOptions = {};\r\n  private semanticAnalyzer?: (ast: ASTNode) => AnalysisResult;\r\n\r\n  rule(name: string, expression: string): this {\r\n    this.rules.push(`${name} = ${expression}`);\r\n    return this;\r\n  }\r\n\r\n  header(code: string): this {\r\n    this.headers.push(code);\r\n    return this;\r\n  }\r\n\r\n  option<K extends keyof CompileOptions>(key: K, value: CompileOptions[K]): this {\r\n    this.options[key] = value;\r\n    return this;\r\n  }\r\n\r\n  analyzer(analyzer: (ast: ASTNode) => AnalysisResult): this {\r\n    this.semanticAnalyzer = analyzer;\r\n    return this;\r\n  }\r\n\r\n  build(): CompiledGrammar<ASTNode> {\r\n    return compileGrammar<ASTNode>(this.toString(), this.options, this.semanticAnalyzer);\r\n  }\r\n\r\n  toString(): string {\r\n    const headerBlock = this.headers.length > 0 ? `{ ${this.headers.join('\\n')} }\\n\\n` : '';\r\n    return headerBlock + this.rules.join('\\n\\n');\r\n  }\r\n}\r\n\r\nexport function createGrammarBuilder<ASTNode = unknown>(): GrammarBuilder<ASTNode> {\r\n  return new GrammarBuilder<ASTNode>();\r\n}","import { CompiledGrammar } from '../grammar/index.js';\r\nimport { type Location } from '../utils/index.js';\r\n\r\n// Assuming these types come from the PEG.js or similar parser library\r\nexport interface ParserTracer {\r\n  trace(event: { type: string; rule: string; result?: unknown; location: Location }): void;\r\n}\r\n\r\nexport interface ParserOptions {\r\n  grammarSource?: string;\r\n  startRule?: string;\r\n  tracer?: ParserTracer;\r\n  enableSymbolTable?: boolean;\r\n  enableDiagnostics?: boolean;\r\n  enableOptimization?: boolean;\r\n  peg$library?: boolean; // This is a common PEG.js option\r\n  [key: string]: unknown; // Allow other arbitrary options\r\n}\r\n\r\n// Enhanced AST Node interfaces\r\nexport interface ASTNode {\r\n  type: string;\r\n  location?: Location;\r\n  children?: ASTNode[];\r\n  value?: unknown;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\nexport interface ParseResult<T = ASTNode> { // Default T to ASTNode\r\n  result: T;\r\n  success: true;\r\n  ast?: ASTNode;\r\n  symbols?: SymbolTable;\r\n  diagnostics?: Diagnostic[];\r\n}\r\n\r\nexport interface ParseError {\r\n  success: false;\r\n  error: string;\r\n  location?: Location;\r\n  expected?: string[];\r\n  found?: string;\r\n  stack?: string;\r\n  input?: string;\r\n  snippet?: string;\r\n  diagnostics?: Diagnostic[];\r\n}\r\n\r\n// Use ParserOptions directly for parsing functions\r\nexport type ParseOptions = ParserOptions; // Alias for clarity, but essentially the same\r\n\r\n// Symbol Table for semantic analysis\r\nexport class SymbolTable {\r\n  private scopes: Map<string, Map<string, Symbol>> = new Map();\r\n  private currentScope = 'global';\r\n  private scopeStack: string[] = ['global'];\r\n\r\n  constructor() {\r\n    this.scopes.set('global', new Map());\r\n  }\r\n\r\n  enterScope(scopeName: string): void {\r\n    this.currentScope = scopeName;\r\n    this.scopeStack.push(scopeName);\r\n    if (!this.scopes.has(scopeName)) {\r\n      this.scopes.set(scopeName, new Map());\r\n    }\r\n  }\r\n\r\n  exitScope(): void {\r\n    this.scopeStack.pop();\r\n    this.currentScope = this.scopeStack[this.scopeStack.length - 1] || 'global';\r\n  }\r\n\r\n  define(symbol: Symbol): void {\r\n    const scope = this.scopes.get(this.currentScope)!;\r\n    scope.set(symbol.name, symbol);\r\n  }\r\n\r\n  lookup(name: string): Symbol | undefined {\r\n    // Search from current scope up to global\r\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\r\n      const scopeName = this.scopeStack[i];\r\n      const scope = this.scopes.get(scopeName);\r\n      if (scope?.has(name)) {\r\n        return scope.get(name);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  getAllSymbols(): Symbol[] {\r\n    const symbols: Symbol[] = [];\r\n    for (const scope of this.scopes.values()) {\r\n      symbols.push(...scope.values());\r\n    }\r\n    return symbols;\r\n  }\r\n\r\n  getSymbolsInScope(scopeName: string): Symbol[] {\r\n    return Array.from(this.scopes.get(scopeName)?.values() || []);\r\n  }\r\n\r\n  // New getter for currentScope to avoid 'any' type assertion\r\n  getCurrentScope(): string {\r\n    return this.currentScope;\r\n  }\r\n}\r\n\r\nexport interface Symbol {\r\n  name: string;\r\n  type: string;\r\n  scope: string;\r\n  location: Location;\r\n  value?: unknown;\r\n  metadata?: Record<string, unknown>;\r\n}\r\n\r\n// Diagnostic system for better error reporting\r\nexport interface Diagnostic {\r\n  severity: 'error' | 'warning' | 'info' | 'hint';\r\n  message: string;\r\n  location: Location;\r\n  code?: string;\r\n  source?: string;\r\n  relatedInformation?: DiagnosticRelatedInformation[];\r\n}\r\n\r\nexport interface DiagnosticRelatedInformation {\r\n  location: Location;\r\n  message: string;\r\n}\r\n\r\nexport class DiagnosticCollector {\r\n  private diagnostics: Diagnostic[] = [];\r\n\r\n  error(message: string, location: Location, code?: string): void {\r\n    this.diagnostics.push({\r\n      severity: 'error',\r\n      message,\r\n      location,\r\n      code,\r\n      source: 'parser'\r\n    });\r\n  }\r\n\r\n  warning(message: string, location: Location, code?: string): void {\r\n    this.diagnostics.push({\r\n      severity: 'warning',\r\n      message,\r\n      location,\r\n      code,\r\n      source: 'parser'\r\n    });\r\n  }\r\n\r\n  info(message: string, location: Location, code?: string): void {\r\n    this.diagnostics.push({\r\n      severity: 'info',\r\n      message,\r\n      location,\r\n      code,\r\n      source: 'parser'\r\n    });\r\n  }\r\n\r\n  hint(message: string, location: Location, code?: string): void {\r\n    this.diagnostics.push({\r\n      severity: 'hint',\r\n      message,\r\n      location,\r\n      code,\r\n      source: 'parser'\r\n    });\r\n  }\r\n\r\n  getDiagnostics(): Diagnostic[] {\r\n    return [...this.diagnostics];\r\n  }\r\n\r\n  addDiagnostics(newDiagnostics: Diagnostic[]): void {\r\n    this.diagnostics.push(...newDiagnostics);\r\n  }\r\n\r\n  clear(): void {\r\n    this.diagnostics = [];\r\n  }\r\n\r\n  hasDiagnostics(): boolean {\r\n    return this.diagnostics.length > 0;\r\n  }\r\n\r\n  hasErrors(): boolean {\r\n    return this.diagnostics.some(d => d.severity === 'error');\r\n  }\r\n}\r\n\r\n// AST Visitor pattern for tree traversal\r\nexport interface ASTVisitor<T = unknown> {\r\n  visit(node: ASTNode, _context?: unknown): T; // _context marked as unused\r\n  visitChildren?(node: ASTNode, _context?: unknown): T | void; // Adjusted return type to T | void\r\n}\r\n\r\nexport class ASTWalker {\r\n  static walk<T>(node: ASTNode, visitor: ASTVisitor<T>, context?: unknown): T {\r\n    const result = visitor.visit(node, context);\r\n\r\n    if (node.children && visitor.visitChildren) {\r\n      const childResults: T[] = node.children.map(child => // Explicitly type childResults as T[]\r\n        ASTWalker.walk(child, visitor, context)\r\n      );\r\n      // Ensure context is an object before spreading\r\n      const newContext = typeof context === 'object' && context !== null ? context : {};\r\n      const childrenVisitResult = visitor.visitChildren(node, { ...newContext, childResults });\r\n      // If visitChildren returns a value, prioritize it, otherwise fall back to result\r\n      return (childrenVisitResult !== undefined ? childrenVisitResult : result);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  static walkPostOrder<T>(node: ASTNode, visitor: ASTVisitor<T>, context?: unknown): T {\r\n    if (node.children && visitor.visitChildren) {\r\n      const childResults: T[] = node.children.map(child => // Explicitly type childResults as T[]\r\n        ASTWalker.walkPostOrder(child, visitor, context)\r\n      );\r\n      // Ensure context is an object before spreading\r\n      const newContext = typeof context === 'object' && context !== null ? context : {};\r\n      visitor.visitChildren(node, { ...newContext, childResults }); // visitChildren can return void here\r\n    }\r\n\r\n    return visitor.visit(node, context);\r\n  }\r\n}\r\n\r\n// AST Transformation utilities\r\nexport interface ASTTransform {\r\n  transform(node: ASTNode): ASTNode;\r\n  shouldTransform?(node: ASTNode): boolean;\r\n}\r\n\r\nexport class ASTTransformer {\r\n  private transforms: ASTTransform[] = [];\r\n\r\n  addTransform(transform: ASTTransform): void {\r\n    this.transforms.push(transform);\r\n  }\r\n\r\n  transform(ast: ASTNode): ASTNode {\r\n    let result = ast;\r\n\r\n    for (const transform of this.transforms) {\r\n      result = this.applyTransform(result, transform);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private applyTransform(node: ASTNode, transform: ASTTransform): ASTNode {\r\n    if (transform.shouldTransform && !transform.shouldTransform(node)) {\r\n      return node;\r\n    }\r\n\r\n    const transformed = transform.transform(node);\r\n\r\n    if (transformed.children) {\r\n      transformed.children = transformed.children.map(child =>\r\n        this.applyTransform(child, transform)\r\n      );\r\n    }\r\n\r\n    return transformed;\r\n  }\r\n}\r\n\r\n// Semantic Analysis base class\r\nexport abstract class SemanticAnalyzer {\r\n  protected symbolTable: SymbolTable;\r\n  protected diagnostics: DiagnosticCollector;\r\n\r\n  constructor(symbolTable: SymbolTable, diagnostics: DiagnosticCollector) { // Added parameters for injection\r\n    this.symbolTable = symbolTable;\r\n    this.diagnostics = diagnostics;\r\n  }\r\n\r\n  abstract analyze(ast: ASTNode): void;\r\n\r\n  getSymbolTable(): SymbolTable {\r\n    return this.symbolTable;\r\n  }\r\n\r\n  getDiagnostics(): Diagnostic[] {\r\n    return this.diagnostics.getDiagnostics();\r\n  }\r\n\r\n  hasErrors(): boolean {\r\n    return this.diagnostics.hasErrors();\r\n  }\r\n}\r\n\r\n// Code Generation base class\r\nexport abstract class CodeGenerator { // Removed <T = string> and made it explicit\r\n  protected output: string[] = []; // Changed to string[]\r\n  protected indentLevel = 0;\r\n  protected indentString = '  ';\r\n\r\n  abstract generate(ast: ASTNode): string; // Changed to string\r\n\r\n  protected indent(): void {\r\n    this.indentLevel++;\r\n  }\r\n\r\n  protected dedent(): void {\r\n    this.indentLevel = Math.max(0, this.indentLevel - 1);\r\n  }\r\n\r\n  protected emit(code: string): void { // Changed to string\r\n    this.output.push(code);\r\n  }\r\n\r\n  protected emitIndented(code: string): void {\r\n    // No need for type assertion anymore as emit expects string\r\n    this.emit(this.indentString.repeat(this.indentLevel) + code);\r\n  }\r\n\r\n  protected getOutput(): string[] { // Changed to string[]\r\n    return [...this.output];\r\n  }\r\n\r\n  protected clear(): void {\r\n    this.output = [];\r\n    this.indentLevel = 0;\r\n  }\r\n}\r\n\r\n// Interpreter base class\r\nexport abstract class Interpreter<T = unknown> {\r\n  protected environment: Map<string, unknown> = new Map();\r\n  protected callStack: string[] = [];\r\n\r\n  abstract interpret(ast: ASTNode): T;\r\n\r\n  protected getVariable(name: string): unknown {\r\n    return this.environment.get(name);\r\n  }\r\n\r\n  protected setVariable(name: string, value: unknown): void {\r\n    this.environment.set(name, value);\r\n  }\r\n\r\n  protected enterFunction(name: string): void {\r\n    this.callStack.push(name);\r\n  }\r\n\r\n  protected exitFunction(): void {\r\n    this.callStack.pop();\r\n  }\r\n\r\n  protected getCurrentFunction(): string | undefined {\r\n    return this.callStack[this.callStack.length - 1];\r\n  }\r\n\r\n  getEnvironment(): Map<string, unknown> {\r\n    return new Map(this.environment);\r\n  }\r\n}\r\n\r\n// Enhanced parser with compiler features\r\nexport function parseWithSemanticAnalysis<T extends ASTNode>( // T extends ASTNode\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  analyzerInstance?: SemanticAnalyzer, // Renamed to avoid conflict with class name\r\n  options: ParserOptions = {}\r\n): ParseResult<T> | ParseError {\r\n  const enhancedOptions: ParserOptions = {\r\n    ...options,\r\n    enableSymbolTable: true, // Ensure parser attempts to build symbol table if it supports it\r\n    enableDiagnostics: true // Ensure parser attempts to collect diagnostics if it supports it\r\n  };\r\n\r\n  const diagnosticsCollector = new DiagnosticCollector();\r\n  let symbolTable: SymbolTable | undefined;\r\n\r\n  try {\r\n    // Attempt to parse the input. The result is expected to be the AST.\r\n    const ast: T = grammar.parse(input, enhancedOptions) as T; // Explicitly cast to T\r\n\r\n    // If a semantic analyzer is provided, run it\r\n    if (analyzerInstance) {\r\n      // The analyzer will populate its own symbol table and diagnostics\r\n      analyzerInstance.analyze(ast);\r\n      symbolTable = analyzerInstance.getSymbolTable();\r\n      diagnosticsCollector.addDiagnostics(analyzerInstance.getDiagnostics());\r\n\r\n      if (analyzerInstance.hasErrors()) {\r\n        return {\r\n          success: false,\r\n          error: 'Semantic analysis failed',\r\n          diagnostics: diagnosticsCollector.getDiagnostics(),\r\n          input\r\n        };\r\n      }\r\n    } else {\r\n      // If no analyzer, and options suggest symbol table/diagnostics, create them.\r\n      // Note: Without an analyzer or parser support, these will be empty.\r\n      if (enhancedOptions.enableSymbolTable) {\r\n        symbolTable = new SymbolTable();\r\n      }\r\n      if (enhancedOptions.enableDiagnostics) {\r\n        // Diagnostics would typically come from the parser itself if no analyzer.\r\n        // For this simplified example, they remain empty if no analyzer.\r\n      }\r\n    }\r\n\r\n    return {\r\n      result: ast,\r\n      success: true,\r\n      ast: ast,\r\n      symbols: symbolTable,\r\n      diagnostics: diagnosticsCollector.getDiagnostics()\r\n    };\r\n  } catch (error: unknown) {\r\n    const parseError = createParseError(error, input, options);\r\n    if (parseError.diagnostics) { // If createParseError added diagnostics\r\n      diagnosticsCollector.addDiagnostics(parseError.diagnostics);\r\n    } else { // Or create a basic error diagnostic\r\n      diagnosticsCollector.error(parseError.error, parseError.location || { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }, 'parse-error');\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: parseError.error,\r\n      location: parseError.location,\r\n      expected: parseError.expected,\r\n      found: parseError.found,\r\n      stack: parseError.stack,\r\n      input: parseError.input,\r\n      snippet: parseError.snippet,\r\n      diagnostics: diagnosticsCollector.getDiagnostics()\r\n    };\r\n  }\r\n}\r\n\r\n// Language Server Protocol support\r\nexport interface LSPCapabilities {\r\n  textDocument?: {\r\n    completion?: boolean;\r\n    hover?: boolean;\r\n    signatureHelp?: boolean;\r\n    definition?: boolean;\r\n    references?: boolean;\r\n    documentHighlight?: boolean;\r\n    documentSymbol?: boolean;\r\n    codeAction?: boolean;\r\n    codeLens?: boolean;\r\n    formatting?: boolean;\r\n    rangeFormatting?: boolean;\r\n    onTypeFormatting?: boolean;\r\n    rename?: boolean;\r\n    publishDiagnostics?: boolean;\r\n    foldingRange?: boolean;\r\n    selectionRange?: boolean;\r\n    semanticTokens?: boolean;\r\n  };\r\n}\r\n\r\nexport interface CompletionItem {\r\n  label: string;\r\n  kind: 'Text' | 'Method' | 'Function' | 'Constructor' | 'Field' | 'Variable' | 'Class' | 'Interface' | 'Module' | 'Property' | 'Unit' | 'Value' | 'Enum' | 'Keyword' | 'Snippet' | 'Color' | 'File' | 'Reference';\r\n  detail?: string;\r\n  documentation?: string;\r\n  insertText?: string;\r\n  sortText?: string;\r\n  filterText?: string;\r\n}\r\n\r\nexport class LanguageServer {\r\n  private grammar: CompiledGrammar;\r\n  private symbolTable: SymbolTable;\r\n  private diagnosticCollector: DiagnosticCollector; // Renamed to avoid conflict\r\n  private capabilities: LSPCapabilities;\r\n\r\n  constructor(grammar: CompiledGrammar, capabilities: LSPCapabilities = {}) {\r\n    this.grammar = grammar;\r\n    this.symbolTable = new SymbolTable();\r\n    this.diagnosticCollector = new DiagnosticCollector(); // Initialize\r\n    this.capabilities = capabilities;\r\n  }\r\n\r\n  async completion(_input: string, _position: { line: number; column: number }): Promise<CompletionItem[]> {\r\n    const symbols = this.symbolTable.getAllSymbols();\r\n    const completions: CompletionItem[] = [];\r\n\r\n    // Add symbol-based completions\r\n    for (const symbol of symbols) {\r\n      completions.push({\r\n        label: symbol.name,\r\n        kind: this.getCompletionKind(symbol.type),\r\n        detail: symbol.type,\r\n        documentation: symbol.metadata?.description as string\r\n      });\r\n    }\r\n\r\n    // Add keyword completions (would be language-specific)\r\n    const keywords = ['if', 'else', 'while', 'for', 'function', 'return', 'var', 'let', 'const'];\r\n    for (const keyword of keywords) {\r\n      completions.push({\r\n        label: keyword,\r\n        kind: 'Keyword',\r\n        insertText: keyword\r\n      });\r\n    }\r\n\r\n    return completions;\r\n  }\r\n\r\n  async hover(input: string, position: { line: number; column: number }): Promise<string | null> {\r\n    // Find symbol at position and return hover information\r\n    const wordAtPosition = this.getWordAtPosition(input, position);\r\n    if (!wordAtPosition) return null;\r\n\r\n    const symbol = this.symbolTable.lookup(wordAtPosition);\r\n    if (!symbol) return null;\r\n\r\n    return `**${symbol.name}**: ${symbol.type}\\n\\n${symbol.metadata?.description || ''}`;\r\n  }\r\n\r\n  async getDiagnosticsForInput(input: string): Promise<Diagnostic[]> { // Renamed method\r\n    this.diagnosticCollector.clear(); // Clear diagnostics for a fresh run\r\n    this.symbolTable = new SymbolTable(); // Clear/reset symbol table for a fresh run\r\n\r\n    try {\r\n      // Define local classes to improve type inference clarity\r\n      class TempSemanticAnalyzer extends SemanticAnalyzer {\r\n        constructor(symbolTable: SymbolTable, diagnostics: DiagnosticCollector) {\r\n          super(symbolTable, diagnostics);\r\n        }\r\n        analyze(ast: ASTNode): void {\r\n          class TempASTVisitor implements ASTVisitor<void> {\r\n            constructor(private _symbolTableRef: SymbolTable, private _diagnosticsRef: DiagnosticCollector) {}\r\n            visit(node: ASTNode, _context?: unknown): void { // _context marked as unused\r\n              if (node.type === 'Identifier' && typeof node.value === 'string') {\r\n                const symbolName = node.value;\r\n                if (!this._symbolTableRef.lookup(symbolName)) {\r\n                  this._diagnosticsRef.warning(`Undefined identifier: '${symbolName}'`, node.location || { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }, 'undefined-var');\r\n                }\r\n              }\r\n              // Example: define variables when encountered\r\n              if (node.type === 'VariableDeclaration' && node.children && node.children[0]?.type === 'Identifier') {\r\n                const varName = node.children[0].value as string;\r\n                this._symbolTableRef.define({\r\n                  name: varName,\r\n                  type: 'variable',\r\n                  // Accessing currentScope via the new public getter\r\n                  scope: this._symbolTableRef.getCurrentScope(),\r\n                  location: node.children[0].location || { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } },\r\n                  metadata: { description: `Declared variable '${varName}'` }\r\n                });\r\n              }\r\n            }\r\n            visitChildren(_node: ASTNode, _context?: unknown): void { // _node and _context marked as unused, return type void\r\n                // No specific action needed for children in this simple example\r\n                // Return type is void as per ASTVisitor interface for this use case.\r\n            }\r\n          }\r\n          const visitor = new TempASTVisitor(this.symbolTable, this.diagnostics); // Pass TempSemanticAnalyzer's instances\r\n          ASTWalker.walk(ast, visitor);\r\n        }\r\n      }\r\n\r\n      const tempAnalyzer = new TempSemanticAnalyzer(this.symbolTable, this.diagnosticCollector); // Pass LanguageServer's instances\r\n\r\n      const parseResult = parseWithSemanticAnalysis(this.grammar, input, tempAnalyzer, {\r\n        enableDiagnostics: true,\r\n        enableSymbolTable: true,\r\n      });\r\n\r\n      // Update the LanguageServer's symbol table and diagnostics from the parse result\r\n      if (parseResult.success) {\r\n        if (parseResult.symbols) {\r\n          this.symbolTable = parseResult.symbols; // Replace with the analyzer's populated symbol table\r\n        }\r\n        this.diagnosticCollector.addDiagnostics(parseResult.diagnostics || []);\r\n      } else {\r\n        // If it's a parse error, add its diagnostics\r\n        this.diagnosticCollector.addDiagnostics(parseResult.diagnostics || []);\r\n        // If there are no specific diagnostics, add a generic error\r\n        if (!parseResult.diagnostics || parseResult.diagnostics.length === 0) {\r\n           const errorLocation = parseResult.location || { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } };\r\n           this.diagnosticCollector.error(parseResult.error, errorLocation, 'parse-error');\r\n        }\r\n      }\r\n      return this.diagnosticCollector.getDiagnostics();\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      const errorLocation = (error as { location?: Location }).location;\r\n\r\n      this.diagnosticCollector.error(errorMessage, errorLocation || { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }, 'internal-error');\r\n      return this.diagnosticCollector.getDiagnostics();\r\n    }\r\n  }\r\n\r\n  private getCompletionKind(type: string): CompletionItem['kind'] {\r\n    switch (type.toLowerCase()) {\r\n      case 'function': return 'Function';\r\n      case 'variable': return 'Variable';\r\n      case 'class': return 'Class';\r\n      case 'interface': return 'Interface';\r\n      case 'module': return 'Module';\r\n      case 'property': return 'Property';\r\n      case 'method': return 'Method';\r\n      default: return 'Text';\r\n    }\r\n  }\r\n\r\n  private getWordAtPosition(input: string, position: { line: number; column: number }): string | null {\r\n    const lines = input.split('\\n');\r\n    if (position.line >= lines.length) return null;\r\n\r\n    const line = lines[position.line];\r\n    if (position.column >= line.length) return null;\r\n\r\n    const wordRegex = /\\b\\w+\\b/g;\r\n    let match;\r\n    while ((match = wordRegex.exec(line)) !== null) {\r\n      if (match.index <= position.column && position.column < match.index + match[0].length) {\r\n        return match[0];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n// REPL (Read-Eval-Print Loop) implementation\r\nexport class REPL {\r\n  private grammar: CompiledGrammar;\r\n  private interpreter?: Interpreter;\r\n  private history: string[] = [];\r\n  private variables: Map<string, unknown> = new Map();\r\n\r\n  constructor(grammar: CompiledGrammar, interpreter?: Interpreter) {\r\n    this.grammar = grammar;\r\n    this.interpreter = interpreter;\r\n  }\r\n\r\n  async evaluate(input: string): Promise<{ result: unknown; output: string; error?: string }> {\r\n    this.history.push(input);\r\n\r\n    try {\r\n      // Pass options to parseWithSemanticAnalysis.\r\n      // The REPL's interpreter will then work on the AST.\r\n      const parseResult = parseWithSemanticAnalysis(this.grammar, input, undefined, {\r\n        enableSymbolTable: true,\r\n        enableDiagnostics: true,\r\n      });\r\n\r\n      if (!parseResult.success) {\r\n        return {\r\n          result: null,\r\n          output: '',\r\n          error: ParserUtils.formatError(parseResult) // Use ParserUtils to format error\r\n        };\r\n      }\r\n\r\n      if (this.interpreter) {\r\n        // Ensure parseResult.result is ASTNode for interpreter\r\n        const result = this.interpreter.interpret(parseResult.result as ASTNode);\r\n        return {\r\n          result,\r\n          output: this.formatOutput(result),\r\n        };\r\n      } else {\r\n        return {\r\n          result: parseResult.result,\r\n          output: this.formatAST(parseResult.result as ASTNode),\r\n        };\r\n      }\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      return {\r\n        result: null,\r\n        output: '',\r\n        error: errorMessage\r\n      };\r\n    }\r\n  }\r\n\r\n  getHistory(): string[] {\r\n    return [...this.history];\r\n  }\r\n\r\n  clearHistory(): void {\r\n    this.history = [];\r\n  }\r\n\r\n  private formatOutput(value: unknown): string {\r\n    if (typeof value === 'object') {\r\n      return JSON.stringify(value, null, 2);\r\n    }\r\n    return String(value);\r\n  }\r\n\r\n  private formatAST(ast: ASTNode): string {\r\n    return JSON.stringify(ast, null, 2);\r\n  }\r\n}\r\n\r\n// Export enhanced parsing utilities\r\nexport function parseInput<T = ASTNode>( // Default T to ASTNode\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  options: ParserOptions = {}\r\n): ParseResult<T> | ParseError {\r\n  try {\r\n    const result: T = grammar.parse(input, options) as T; // Explicitly cast to T\r\n    return {\r\n      result,\r\n      success: true,\r\n      ast: result as ASTNode, // result is the AST\r\n      symbols: options.enableSymbolTable ? new SymbolTable() : undefined, // SymbolTable is created here, but needs to be populated by an analyzer\r\n      diagnostics: options.enableDiagnostics ? [] : undefined // Diagnostics are empty here, would be populated by analyzer or parser if it supports it\r\n    };\r\n  }\r\n  catch (error: unknown) {\r\n    return createParseError(error, input, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a parser function from a compiled grammar\r\n */\r\nexport function createParser(grammar: { parse: (input: string, options?: ParserOptions) => ASTNode }) { // Changed options type and return type\r\n  return (input: string) => {\r\n    try {\r\n      const result: ASTNode = grammar.parse(input) as ASTNode; // Explicitly cast to ASTNode\r\n      return result; // Return the AST directly\r\n    } catch (err) {\r\n      return {\r\n        success: false,\r\n        error: err instanceof Error ? err.message : String(err),\r\n        input,\r\n        stack: err instanceof Error ? err.stack : undefined,\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Enhanced error recovery with multiple strategies\r\n */\r\nexport function parseWithAdvancedRecovery<T = ASTNode>( // Default T to ASTNode\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  _options: ParserOptions = {} // _options marked as unused\r\n): { result?: T; errors: ParseError[]; recoveryStrategy?: string } {\r\n  const errors: ParseError[] = [];\r\n\r\n  // Try original parse first\r\n  try {\r\n    const result: T = grammar.parse(input, _options) as T; // Explicitly cast to T\r\n    return { result, errors, recoveryStrategy: 'original' };\r\n  } catch (error: unknown) {\r\n    const parseError = createParseError(error, input, _options);\r\n    errors.push(parseError);\r\n\r\n    const lines = input.split('\\n');\r\n    if (!parseError.location) {\r\n      return { errors };\r\n    }\r\n\r\n    const errorLine = parseError.location.start.line;\r\n\r\n    // Strategy 1: Remove the error line\r\n    if (errorLine > 0 && errorLine <= lines.length) {\r\n      try {\r\n        const recoveredInput = [\r\n          ...lines.slice(0, errorLine - 1),\r\n          ...lines.slice(errorLine)\r\n        ].join('\\n');\r\n\r\n        const result: T = grammar.parse(recoveredInput, _options) as T; // Explicitly cast to T\r\n        return { result, errors, recoveryStrategy: 'removeErrorLine' };\r\n      } catch (_recoveryError: unknown) { // _recoveryError marked as unused\r\n        errors.push(createParseError(_recoveryError, input, _options));\r\n      }\r\n    }\r\n\r\n    // Strategy 2: Remove everything from error to end\r\n    if (errorLine > 1) {\r\n      try {\r\n        const recoveredInput = lines.slice(0, errorLine - 1).join('\\n');\r\n        if (recoveredInput.trim()) {\r\n          const result: T = grammar.parse(recoveredInput, _options) as T; // Explicitly cast to T\r\n          return { result, errors, recoveryStrategy: 'removeFromError' };\r\n        }\r\n      } catch (_recoveryError: unknown) { // _recoveryError marked as unused\r\n        errors.push(createParseError(_recoveryError, input, _options));\r\n      }\r\n    }\r\n\r\n    // Strategy 3: Insert common missing tokens\r\n    if (parseError.expected) {\r\n      const commonTokens = [';', '}', ')', ']', '\"', \"'\"];\r\n      for (const token of commonTokens) {\r\n        if (parseError.expected.includes(token)) {\r\n          try {\r\n            const errorPos = parseError.location.start.offset;\r\n            const recoveredInput =\r\n              input.slice(0, errorPos) + token + input.slice(errorPos);\r\n\r\n            const result: T = grammar.parse(recoveredInput, _options) as T; // Explicitly cast to T\r\n            return { result, errors, recoveryStrategy: 'insertMissing' };\r\n          } catch (_recoveryError: unknown) { // _recoveryError marked as unused\r\n            // Continue to next token\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return { errors };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a detailed parse error\r\n */\r\nfunction createParseError(\r\n  error: unknown,\r\n  input: string,\r\n  _options: ParserOptions // _options marked as unused\r\n): ParseError {\r\n  const errorObj = error as {\r\n    message?: string;\r\n    location?: Location;\r\n    expected?: Array<{ description?: string; text?: string; toString(): string }>;\r\n    found?: unknown;\r\n    stack?: string;\r\n  };\r\n\r\n  const parseError: ParseError = {\r\n    success: false,\r\n    error: errorObj.message || 'Parse error',\r\n    input\r\n  };\r\n\r\n  if (errorObj.location) {\r\n    parseError.location = {\r\n      start: {\r\n        line: errorObj.location.start.line,\r\n        column: errorObj.location.start.column,\r\n        offset: errorObj.location.start.offset\r\n      },\r\n      end: {\r\n        line: errorObj.location.end.line,\r\n        column: errorObj.location.end.column,\r\n        offset: errorObj.location.end.offset\r\n      }\r\n    };\r\n  }\r\n\r\n  if (errorObj.expected) {\r\n    parseError.expected = errorObj.expected.map((exp) =>\r\n      exp.description || exp.text || exp.toString()\r\n    );\r\n  }\r\n\r\n  if (errorObj.found !== undefined && errorObj.found !== null) { // Added null check\r\n    parseError.found = errorObj.found.toString();\r\n  }\r\n\r\n  parseError.stack = errorObj.stack;\r\n\r\n  if (parseError.location) {\r\n    parseError.snippet = generateErrorSnippet(input, parseError.location);\r\n  }\r\n\r\n  return parseError;\r\n}\r\n\r\n/**\r\n * Generate a code snippet showing the error location\r\n */\r\nfunction generateErrorSnippet(input: string, location: Location): string {\r\n  const lines = input.split('\\n');\r\n  const lineNum = location.start.line;\r\n  const colNum = location.start.column;\r\n\r\n  if (lineNum > lines.length) {\r\n    return '';\r\n  }\r\n\r\n  const line = lines[lineNum - 1];\r\n\r\n  const contextLines: string[] = [];\r\n\r\n  if (lineNum > 1) {\r\n    contextLines.push(`${lineNum - 1}: ${lines[lineNum - 2]}`);\r\n  }\r\n\r\n  contextLines.push(`${lineNum}: ${line}`);\r\n  contextLines.push(`${' '.repeat(lineNum.toString().length)}: ${' '.repeat(colNum - 1)}^`);\r\n\r\n  if (lineNum < lines.length) {\r\n    contextLines.push(`${lineNum + 1}: ${lines[lineNum]}`);\r\n  }\r\n\r\n  return contextLines.join('\\n');\r\n}\r\n\r\n// Stub implementations for the missing functions from original-parser\r\n// These would need to be implemented based on your actual requirements\r\nexport function parseMultiple<T = ASTNode>( // Default T to ASTNode\r\n  grammar: CompiledGrammar,\r\n  inputs: string[],\r\n  options: ParserOptions = {}\r\n): Array<ParseResult<T> | ParseError> {\r\n  return inputs.map(input => parseInput<T>(grammar, input, options));\r\n}\r\n\r\nexport function parseStream<T = ASTNode>( // Default T to ASTNode\r\n  grammar: CompiledGrammar,\r\n  stream: ReadableStream<string>,\r\n  options: ParserOptions = {}\r\n): AsyncGenerator<ParseResult<T> | ParseError> {\r\n  // This would need to be implemented based on your streaming requirements\r\n  throw new Error('parseStream not implemented - requires actual stream processing logic');\r\n}\r\n\r\nexport function parseWithTimeout<T = ASTNode>( // Default T to ASTNode\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  timeoutMs: number,\r\n  options: ParserOptions = {}\r\n): Promise<ParseResult<T> | ParseError> {\r\n  return new Promise((resolve, reject) => {\r\n    const timeoutId = setTimeout(() => {\r\n      reject(new Error(`Parse timeout after ${timeoutMs}ms`));\r\n    }, timeoutMs);\r\n\r\n    try {\r\n      const result = parseInput<T>(grammar, input, options);\r\n      clearTimeout(timeoutId);\r\n      resolve(result);\r\n    } catch (error) {\r\n      clearTimeout(timeoutId);\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n\r\nexport function validateSyntax(\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  options: ParserOptions = {}\r\n): { valid: boolean; errors: string[] } {\r\n  const result = parseInput(grammar, input, options);\r\n  if (result.success) {\r\n    return { valid: true, errors: [] };\r\n  } else {\r\n    // Collect errors from diagnostics if available, otherwise use the main error\r\n    const errors = result.diagnostics?.map(d => d.message) || [result.error];\r\n    return { valid: false, errors: errors };\r\n  }\r\n}\r\n\r\nexport class StreamingParser {\r\n  private grammar: CompiledGrammar;\r\n  private buffer = '';\r\n  private options: ParserOptions;\r\n\r\n  constructor(grammar: CompiledGrammar, options: ParserOptions = {}) {\r\n    this.grammar = grammar;\r\n    this.options = options;\r\n  }\r\n\r\n  addChunk(chunk: string): Array<ParseResult | ParseError> {\r\n    this.buffer += chunk;\r\n    const results: Array<ParseResult | ParseError> = [];\r\n\r\n    // Simple line-based parsing - would need more sophisticated logic\r\n    const lines = this.buffer.split('\\n');\r\n    this.buffer = lines.pop() || '';\r\n\r\n    for (const line of lines) {\r\n      if (line.trim()) {\r\n        results.push(parseInput(this.grammar, line, this.options));\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  flush(): ParseResult | ParseError | null {\r\n    if (this.buffer.trim()) {\r\n      const result = parseInput(this.grammar, this.buffer, this.options);\r\n      this.buffer = '';\r\n      return result;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nexport class ParserUtils {\r\n  static formatError(error: ParseError): string {\r\n    let formatted = `Parse Error: ${error.error}`;\r\n\r\n    if (error.location) {\r\n      formatted += ` at line ${error.location.start.line}, column ${error.location.start.column}`;\r\n    }\r\n\r\n    if (error.expected && error.expected.length > 0) {\r\n      formatted += `\\nExpected: ${error.expected.join(', ')}`;\r\n    }\r\n\r\n    if (error.found) {\r\n      formatted += `\\nFound: ${error.found}`;\r\n    }\r\n\r\n    if (error.snippet) {\r\n      formatted += `\\n\\n${error.snippet}`;\r\n    }\r\n\r\n    return formatted;\r\n  }\r\n\r\n  static isParseError(result: ParseResult | ParseError): result is ParseError {\r\n    return !result.success;\r\n  }\r\n\r\n  static extractValue<T>(result: ParseResult<T> | ParseError): T | null {\r\n    return result.success ? result.result : null;\r\n  }\r\n}\r\n\r\n// Performance monitoring wrapper\r\nexport class PerformanceParser {\r\n  private grammar: CompiledGrammar;\r\n  private metrics: Map<string, number[]> = new Map();\r\n\r\n  constructor(grammar: CompiledGrammar) {\r\n    this.grammar = grammar;\r\n  }\r\n\r\n  parse<T = ASTNode>(input: string, options: ParserOptions = {}): ParseResult<T> | ParseError {\r\n    const start = performance.now();\r\n    const result = parseInput<T>(this.grammar, input, options);\r\n    const end = performance.now();\r\n\r\n    const duration = end - start;\r\n    const inputSize = input.length;\r\n    const key = `${inputSize}`;\r\n\r\n    if (!this.metrics.has(key)) {\r\n      this.metrics.set(key, []);\r\n    }\r\n    this.metrics.get(key)!.push(duration);\r\n\r\n    return result;\r\n  }\r\n\r\n  getMetrics(): Record<string, { avg: number; min: number; max: number; count: number }> {\r\n    const result: Record<string, { avg: number; min: number; max: number; count: number }> = {}; // Corrected 'number' to 'count'\r\n\r\n    for (const [key, times] of this.metrics) {\r\n      const avg = times.reduce((a, b) => a + b, 0) / times.length;\r\n      const min = Math.min(...times);\r\n      const max = Math.max(...times);\r\n\r\n      result[key] = { avg, min, max, count: times.length }; // Corrected 'number' to 'count'\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport async function parseTextFile(\r\n  grammar: CompiledGrammar,\r\n  filePath: string,\r\n  _options: ParserOptions = {} // Marked as unused\r\n): Promise<ParseResult | ParseError> {\r\n  // This would need actual file system access\r\n  throw new Error('parseTextFile not implemented - requires file system access');\r\n}\r\n\r\n// Optional default export with all utilities\r\nexport default {\r\n  parseInput,\r\n  parseWithSemanticAnalysis,\r\n  parseMultiple,\r\n  parseStream,\r\n  parseWithTimeout,\r\n  validateSyntax,\r\n  parseWithAdvancedRecovery,\r\n  createParser,\r\n  ASTWalker,\r\n  ASTTransformer,\r\n  SymbolTable,\r\n  DiagnosticCollector,\r\n  LanguageServer,\r\n  REPL,\r\n  StreamingParser,\r\n  ParserUtils,\r\n  PerformanceParser\r\n};\r\n"],"mappings":"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L,MAAM;AAChB0L,uBAAK3G,KAAK8G,OAAAA;AACVF,wBAAM5G,KAAK/E,IAAAA;gBACb,OAAO;AAEL2L,wBAAM5G,KAAK6G,GAAAA;gBACb;cACF;AAEAL,yBAAWI,MAAMhH,OAAO+G,IAAAA;YAC1B;AAEA,kBAAMK,WAAWR,SAAShF,MAAM,CAAA,EAAGyF,QAAO;AAC1C,uBAAWJ,OAAOG,UAAU;AAC1B5H,oBAAMY,KAAKoG,eAAeS,GAAAA,CAAAA;AAC1BzH,oBAAMY,KAAK,EAAA;YACb;UACF,OAAO;AACLZ,kBAAMY,KAAKoG,eAAeI,QAAAA,CAAAA;AAC1BpH,kBAAMY,KAAK,EAAA;UACb;QACF;AAEAZ,cAAMY,KACJ,+CACA,uDACA,uBACA,iCACA,2BACA,iCACA,kCACA,OACA,IACA,uBACA,2CACA,4BACA,yBACA,0EACA,mBACA,mDACA,WACA,wCACA,wGACA,4CACA,gBACA,yFACA,oBACA,wCACA,2EACA,yCACA,wEACA,kDACA,2CACA,kCACA,sDACA,+DACA,yCACA,kBACA,mCACA,WACA,SACA,mBACA,OACA,IACA,4CACA,0BACA,8DACA,SACA,IACA,8FACA,4DACA,iBACA,mCACA,6BACA,4EACA,WACA,mBACA,SACA,IACA,mCACA,gCACA,yCACA,sCACA,qCACA,qCACA,qCACA,qCACA,yEACA,6EACA,SACA,IACA,iCACA,gCACA,yCACA,qCACA,qCACA,oCACA,qCACA,qCACA,qCACA,qCACA,yEACA,6EACA,SACA,IACA,0CACA,gCACA,mEACA,YACA,IACA,8BACA,uDACA,0CACA,mEACA,oCACA,cACA,IACA,4HACA,YACA,IACA,iBACA,mCACA,YACA,IACA,iBACA,kCACA,YACA,IACA,8BACA,2CACA,YACA,UACA,IACA,mDACA,yEACA,SACA,IACA,6CACA,iEACA,8BACA,IACA,wCACA,sBACA,2DACA,4DACA,kDACA,oBACA,eACA,aACA,oCACA,WACA,IACA,wCACA,mBACA,qCACA,IACA,mBACA,gEACA,IACA,oBACA,yDACA,yBACA,wDACA,WACA,SACA,IACA,uCACA,+EACA,SACA,IACA,qGACA,OACA,KACA,EAAA;AAGF,YAAIxD,SAAQyD,OAAO;AACjBb,gBAAMY,KACJ,6BACA,qBACA,6BACA,OACA,IACA,oBACA,0BACA,IACA,6BACA,yBACA,+EACA,+EACA,0CACA,uEACA,aACA,SACA,IACA,6BACA,4BACA,uBACA,+BACA,kBACA,IACA,4BACA,+BACA,uBACA,kBACA,IACA,2BACA,+BACA,uBACA,kBACA,IACA,kBACA,uEACA,SACA,OACA,KACA,EAAA;QAEJ;AAEA,cAAMkH,qBAAqB,QACvBlK,kBAAkBnB,IAAIsC,CAAAA,OAAK,OAAOA,EAAAA,KAAMhD,KAAKgD,EAAAA,CAAAA;CAAO,EAAEY,KAAK,EAAA,IAC3D;AACJ,cAAMoI,oBAAoBhM,KAAK6B,kBAAkB,CAAA,CAAE;AAEnDoC,cAAMY,KACJ,wCACA,qDACA,IACA,4BACA,+CACA,IACA,sCAAsCkH,qBAAqB,KAC3D,mCAAmCC,oBAAoB,KACvD,IACA5I,eAAAA,GACA,IACA,gDACA,qCACA,2DACA,uCACA,kEACA,wDACA,EAAA;AAGF,YAAI/B,SAAQ0D,OAAO;AACjBd,gBAAMY,KACJ,gCACA,EAAA;QAEJ;AAEA,YAAIxD,SAAQyD,OAAO;AACjBb,gBAAMY,KACJ,sFACA,EAAA;QAEJ;AAEAZ,cAAMY,KACJ,qBACA,IACA,8BACA,6DACA,4FACA,SACA,IACA,0EACA,OACA,IACA,uBACA,0DACA,OACA,IACA,yBACA,4BACA,OACA,IACA,wBACA,gBACA,6BACA,8BACA,2BACA,UACA,OACA,IACA,2BACA,8DACA,OACA,IACA,gDACA,yCACA,oBACA,2DACA,IACA,uCACA,8CACA,qDACA,kBACA,UACA,OACA,IACA,yCACA,yCACA,oBACA,2DACA,IACA,sDACA,OACA,IACA,kDACA,0CACA,+BACA,oBACA,SACA,wCACA,OACA,IACA,yDACA,qDACA,OACA,IACA,2EACA,uEACA,OACA,IACA,qCACA,+BACA,OACA,IACA,qCACA,+BACA,OACA,IACA,kDACA,8CACA,OACA,IACA,2CACA,+CACA,cACA,IACA,sBACA,yBACA,gBACA,kDACA,+CACA,kBACA,oBACA,gDACA,WACA,IACA,2CACA,qBACA,+BACA,mCACA,YACA,IACA,2BACA,6CACA,6BACA,iCACA,oBACA,+BACA,aACA,IACA,gBACA,WACA,IACA,6CACA,IACA,yBACA,SACA,OACA,IACA,8DACA,gEACA,4DACA,IACA,qBACA,6BACA,kBACA,6BACA,uCACA,2CACA,YACA,gBACA,2BACA,qCACA,yCACA,YACA,UACA,gFACA,mDACA,+CACA,SACA,mBACA,OACA,IACA,mCACA,qDACA,IACA,2CACA,uCACA,mCACA,SACA,IACA,2CACA,OACA,IACA,wDACA,kEACA,OACA,IACA,oEACA,mCACA,wDACA,mBACA,gBACA,kBACA,UACA,OACA,EAAA;AAGF,YAAIzD,KAAIuK,QAAQpL,SAAS,GAAG;AAC1B0D,gBAAMY,KACJ,gDACA,iDACA,+BACA,mCACA,2CACA,4BACA,kDACA,WACA,2CACA,sCACA,4CACA,sDACA,iFACA,OACA,EAAA;QAEJ;AAEAzD,QAAAA,KAAI4D,MAAMiH,QAAQ7G,CAAAA,SAAAA;AAChBnB,gBAAMY,KAAI,GAAItC,QAAQ4C,qBAAqBC,IAAAA,CAAAA,CAAAA;QAC7C,CAAA;AAEA,YAAIhE,KAAI8K,aAAa;AACnB,cAAIvJ,MAAMC,QAAQxB,KAAI8K,WAAW,GAAG;AAClC,uBAAWC,QAAQ/K,KAAI8K,aAAa;AAClCjI,oBAAMY,KAAKoG,eAAekB,IAAAA,CAAAA;AAC1BlI,oBAAMY,KAAK,EAAA;YACb;UACF,OAAO;AACLZ,kBAAMY,KAAKoG,eAAe7J,KAAI8K,WAAW,CAAA;AACzCjI,kBAAMY,KAAK,EAAA;UACb;QACF;AAEAZ,cAAMY;UACJ;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;AAGF,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","names":["exports","module","GrammarLocation","source","start","toString","String","offset","loc","line","column","offsetStart","range","offsetEnd","end","exports","module","GrammarLocation","require","GrammarError","SyntaxError","message","location","diagnostics","name","undefined","stage","problems","toString","str","source","start","line","column","diag","format","sources","srcLines","map","text","String","split","entry","indent","src","find","s","offset_s","offsetStart","e","end","last","length","hatLen","padEnd","padStart","formatProblem","severity","maxLine","reduce","t","Math","max","apply","d","filter","p","join","exports","module","visitor","build","functions","visit","node","args","type","visitNop","visitExpression","expression","visitChildren","property","forEach","child","DEFAULT_FUNCTIONS","grammar","imp","imports","topLevelInitializer","Array","isArray","tli","initializer","init","rules","rule","grammar_import","top_level_initializer","named","choice","action","sequence","labeled","text","simple_and","simple_not","optional","zero_or_more","one_or_more","repeated","delimiter","group","semantic_and","semantic_not","rule_ref","library_ref","literal","class","any","Object","keys","prototype","hasOwnProperty","call","exports","module","visitor","require","combinePossibleArrays","a","b","aa","Array","isArray","push","asts","findRule","ast","name","i","rules","length","undefined","indexOfRule","alwaysConsumesOnSuccess","node","consumesTrue","consumesFalse","consumes","build","choice","alternatives","every","sequence","elements","some","simple_and","simple_not","optional","zero_or_more","repeated","min","max","type","value","expression","delimiter","semantic_and","semantic_not","rule_ref","rule","library_ref","literal","class","any","combine","reduce","combined","topLevelInitializer","initializer","concat","exports","module","addImportedRules","ast","libraryNumber","imp","imports","what","original","undefined","type","binding","rename","TypeError","rules","push","name","nameLocation","location","expression","library","from","exports","module","visitor","require","findLibraryNumber","ast","name","libraryNumber","imp","imports","what","type","binding","fixLibraryNumbers","_options","session","check","build","library_ref","node","library","error","location","exports","module","opcodes","PUSH","PUSH_EMPTY_STRING","PUSH_UNDEFINED","PUSH_NULL","PUSH_FAILED","PUSH_EMPTY_ARRAY","PUSH_CURR_POS","POP","POP_CURR_POS","POP_N","NIP","APPEND","WRAP","TEXT","PLUCK","IF","IF_ERROR","IF_NOT_ERROR","IF_LT","IF_GE","IF_LT_DYNAMIC","IF_GE_DYNAMIC","WHILE_NOT_ERROR","MATCH_ANY","MATCH_STRING","MATCH_STRING_IC","MATCH_CHAR_CLASS","MATCH_UNICODE_CLASS","MATCH_REGEXP","ACCEPT_N","ACCEPT_STRING","FAIL","LOAD_SAVED_POS","UPDATE_SAVED_POS","CALL","RULE","LIBRARY_RULE","SILENT_FAILS_ON","SILENT_FAILS_OFF","SOURCE_MAP_PUSH","SOURCE_MAP_POP","SOURCE_MAP_LABEL_PUSH","SOURCE_MAP_LABEL_POP","exports","module","Intern","options","stringify","String","convert","x","items","offsets","Object","create","add","input","c","s","num","undefined","push","get","i","map","fn","exports","module","visitor","require","asts","GrammarError","ALWAYS_MATCH","SOMETIMES_MATCH","NEVER_MATCH","inferenceMatchResult","ast","sometimesMatch","node","match","alwaysMatch","inference","expression","inferenceExpression","inferenceElements","elements","forChoice","length","always","never","i","result","build","rule","oldResult","count","location","named","choice","alternatives","action","sequence","labeled","text","simple_and","simple_not","optional","zero_or_more","one_or_more","repeated","dMatch","delimiter","min","max","type","value","group","semantic_and","semantic_not","rule_ref","findRule","name","library_ref","literal","class","parts","any","exports","module","asts","require","op","visitor","Intern","ALWAYS_MATCH","SOMETIMES_MATCH","NEVER_MATCH","generateBytecode","ast","options","literals","classes","stringify","JSON","convert","node","value","parts","inverted","ignoreCase","unicode","expectations","importedNames","functions","locations","addFunctionConst","predicate","params","func","body","code","location","codeLocation","pattern","index","findIndex","f","push","addLocation","cloneEnv","env","clone","Object","keys","forEach","name","buildSequence","first","args","concat","buildCondition","match","condCode","thenCode","elseCode","length","buildLoop","bodyCode","buildCall","functionIndex","delta","sp","map","CALL","buildSimplePredicate","expression","negative","context","PUSH_CURR_POS","SILENT_FAILS_ON","generate","action","SILENT_FAILS_OFF","IF_ERROR","IF_NOT_ERROR","POP","POP_CURR_POS","PUSH_UNDEFINED","PUSH_FAILED","buildSemanticPredicate","UPDATE_SAVED_POS","IF","buildAppendLoop","expressionCode","WHILE_NOT_ERROR","APPEND","unknownBoundary","boundary","b","Error","type","buildRangeCall","offset","pre","post","NIP","buildCheckMax","max","checkCode","IF_GE","IF_GE_DYNAMIC","buildCheckMin","min","IF_LT","IF_LT_DYNAMIC","buildRangeBody","delimiterNode","expressionMatch","wrapGenerators","generators","output","generator","generated","undefined","SOURCE_MAP_PUSH","SOURCE_MAP_POP","build","grammar","rules","items","rule","bytecode","pluck","named","nameIndex","add","FAIL","choice","buildAlternativesCode","alternatives","slice","emitCall","elements","LOAD_SAVED_POS","sequence","buildElementsCode","processedCount","POP_N","PLUCK","eSP","WRAP","labeled","label","pick","labelLocation","SOURCE_MAP_LABEL_PUSH","SOURCE_MAP_LABEL_POP","text","TEXT","simple_and","simple_not","optional","PUSH_NULL","zero_or_more","PUSH_EMPTY_ARRAY","one_or_more","repeated","hasMin","hasBoundedMax","minCode","maxCode","firstExpressionCode","delimiter","checkMaxCode","firstElemCode","mainLoopCode","group","semantic_and","semantic_not","rule_ref","RULE","indexOfRule","library_ref","LIBRARY_RULE","libraryNumber","literal","needConst","stringIndex","toLowerCase","expectedIndex","MATCH_STRING_IC","MATCH_STRING","ACCEPT_N","ACCEPT_STRING","PUSH_EMPTY_STRING","class","classIndex","MATCH_UNICODE_CLASS","MATCH_CHAR_CLASS","any","MATCH_ANY","exports","intToCharMap","split","encode","number","length","TypeError","exports","base64","require","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","toVLQSigned","aValue","encode","base64VLQ_encode","encoded","digit","vlq","exports","getArg","aArgs","aName","aDefaultValue","arguments","length","Error","supportsNullProto","obj","Object","create","identity","s","toSetString","aStr","isProtoString","fromSetString","slice","charCodeAt","i","strcmp","aStr1","aStr2","compareByGeneratedPositionsInflated","mappingA","mappingB","cmp","generatedLine","generatedColumn","source","originalLine","originalColumn","name","PROTOCOL","PROTOCOL_AND_HOST","createSafeHandler","cb","input","type","getURLType","base","buildSafeBase","url","URL","result","toString","computeRelativeURL","withBase","buildUniqueSegment","prefix","str","id","ident","indexOf","maxDotParts","split","segment","ABSOLUTE_SCHEME","test","rootURL","targetURL","targetParts","pathname","rootParts","pop","shift","relativePath","map","concat","join","search","hash","ensureDirectory","replace","normalize","aRoot","aPath","pathType","rootType","undefined","newPath","relative","relativeIfPossible","urlType","root","target","_err","protocol","user","password","hostname","port","exports","ArraySet","_array","_set","Map","fromArray","aArray","aAllowDuplicates","set","i","len","length","add","size","aStr","isDuplicate","has","idx","push","indexOf","get","Error","at","aIdx","toArray","slice","exports","util","require","generatedPositionAfter","mappingA","mappingB","lineA","generatedLine","lineB","columnA","generatedColumn","columnB","compareByGeneratedPositionsInflated","MappingList","_array","_sorted","_last","unsortedForEach","aCallback","aThisArg","forEach","add","aMapping","push","toArray","sort","exports","base64VLQ","require","util","ArraySet","MappingList","SourceMapGenerator","aArgs","_file","getArg","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","fromSourceMap","aSourceMapConsumer","sourceRoot","generator","file","eachMapping","mapping","newMapping","generated","line","generatedLine","column","generatedColumn","source","relative","original","originalLine","originalColumn","name","addMapping","sources","forEach","sourceFile","sourceRelative","has","add","content","sourceContentFor","setSourceContent","_validateMapping","String","aSourceFile","aSourceContent","Object","create","toSetString","keys","length","applySourceMap","aSourceMapPath","Error","newSources","toArray","newNames","unsortedForEach","originalPositionFor","join","srcFile","aGenerated","aOriginal","aSource","aName","JSON","stringify","_serializeMappings","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","result","next","nameIdx","sourceIdx","mappings","i","len","compareByGeneratedPositionsInflated","encode","indexOf","_generateSourcesContent","aSources","aSourceRoot","map","key","prototype","hasOwnProperty","call","toJSON","version","_version","names","sourcesContent","toString","exports","SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","length","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","nextLine","eachMapping","mapping","generatedLine","addMappingWithCode","code","substr","generatedColumn","splice","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","originalLine","originalColumn","aChunk","Array","isArray","chunk","push","TypeError","prepend","i","unshift","walk","aFn","len","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","replace","aSourceFile","aSourceContent","toSetString","walkSourceContents","Object","keys","fromSetString","toString","str","toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports","SourceMapGenerator","require","SourceNode","exports","module","SourceNode","require","GrammarLocation","Stack","ruleName","varName","type","bytecode","sp","maxSp","labels","sourceMapStack","name","i","RangeError","sourceNode","location","chunks","start","offsetStart","line","column","String","source","push","exprCode","label","code","length","splice","parts","sourceMapPopInternal","newLoc","offset","end","outerNode","concat","join","pop","n","undefined","Array","from","v","top","index","result","defines","checkedIf","pos","generateIf","generateElse","baseSp","ifResult","thenSp","elseResult","Error","checkedLoop","generateBody","sourceMapPush","elt","map","chunk","sourceMapPop","outer","exports","version","exports","hex","ch","codePointAt","toString","toUpperCase","stringEscape","s","value","replace","regexpClassEscape","base64","u8","A","rem","length","len","res","i","codePointLen1","iter","Symbol","iterator","first","next","done","second","exports","module","OPS_TO_PREFIXED_TYPES","OPS_TO_SUFFIXED_TYPES","OPS_TO_SEMANTIC_PREDICATE_TYPES","peg$SyntaxError","SyntaxError","message","expected","found","location","name","format","sources","str","src","st","find","s","source","text","split","start","offset_s","offset","loc","line","column","e","end","filler","padEnd","toString","length","last","hatLen","buildMessage","hex","ch","codePointAt","toUpperCase","nonPrintable","Object","prototype","hasOwnProperty","call","RegExp","unicodeEscape","replace","literalEscape","classEscape","DESCRIBE_EXPECTATION_FNS","literal","expectation","class","escapedParts","parts","map","part","Array","isArray","inverted","join","unicode","any","other","description","describeExpectation","type","describeExpected","descriptions","sort","j","i","slice","describeFound","peg$parse","input","options","undefined","peg$FAILED","peg$source","grammarSource","peg$startRuleFunctions","Grammar","peg$parseGrammar","ImportsAndSource","peg$parseImportsAndSource","peg$startRuleFunction","peg$c0","peg$c1","peg$c2","peg$c3","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$r0","peg$r1","peg$r2","peg$r3","peg$r4","peg$r5","peg$r6","peg$r7","peg$r8","peg$r9","peg$r10","peg$r11","peg$r12","peg$r13","peg$r14","peg$r15","peg$r16","peg$r17","peg$r18","peg$r19","peg$r20","peg$e0","peg$anyExpectation","peg$e1","peg$literalExpectation","peg$e2","peg$e3","peg$e4","peg$e5","peg$e6","peg$e7","peg$e8","peg$e9","peg$e10","peg$e11","peg$e12","peg$e13","peg$classExpectation","peg$e14","peg$e15","peg$e16","peg$e17","peg$e18","peg$e19","peg$e20","peg$e21","peg$e22","peg$e23","peg$e24","peg$e25","peg$otherExpectation","peg$e26","peg$e27","peg$e28","peg$e29","peg$e30","peg$e31","peg$e32","peg$e33","peg$e34","peg$e35","peg$e36","peg$e37","peg$e38","peg$e39","peg$e40","peg$e41","peg$e42","peg$e43","peg$e44","peg$e45","peg$e46","peg$e47","peg$e48","peg$e49","peg$e50","peg$e51","peg$e52","peg$e53","peg$e54","peg$e55","peg$e56","peg$e57","peg$e58","peg$e59","peg$e60","peg$e61","peg$e62","peg$e63","peg$e64","peg$e65","peg$e66","peg$e67","peg$e68","peg$e69","peg$e70","peg$f0","imports","topLevelInitializer","initializer","rules","peg$f1","body","peg$f2","code","codeLocation","peg$f3","peg$f4","what","from","peg$f5","peg$f6","first","others","unshift","peg$f7","binding","peg$f8","peg$f9","peg$f10","rename","renameLocation","peg$f11","peg$f12","peg$f13","id","peg$f14","peg$f15","reservedWords","has","error","peg$f16","peg$f17","peg$f18","displayName","expression","nameLocation","peg$f19","head","tail","alternatives","concat","peg$f20","peg$f21","pick","elements","peg$f22","pluck","label","startsWith","labelLocation","peg$f23","peg$f24","peg$f25","peg$f26","operator","peg$f27","peg$f28","boundaries","delimiter","min","max","value","peg$f29","peg$f30","exact","peg$f31","peg$f32","peg$f33","peg$f34","peg$f35","library","libraryNumber","peg$f36","peg$f37","peg$f38","peg$f39","ignoreCase","peg$f40","chars","peg$f41","peg$f42","flags","filter","Boolean","flat","some","c","peg$f43","er","peg$f44","ret","fromEntries","keys","peg$f45","peg$f46","peg$f47","begin","peg$f48","peg$f49","peg$f50","peg$f51","peg$f52","peg$f53","peg$f54","peg$f55","peg$f56","digits","String","fromCharCode","parseInt","peg$f57","peg$f58","fromCodePoint","peg$f59","peg$f60","peg$f61","peg$currPos","peg$savedPos","peg$posDetailsCache","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","startRule","Error","substring","range","peg$computeLocation","peg$buildStructuredError","peg$buildSimpleError","peg$getUnicode","pos","cp","peg$endExpectation","peg$computePosDetails","details","p","charCodeAt","startPos","endPos","startPosDetails","endPosDetails","res","peg$fail","push","s0","s1","s2","s3","s4","s5","s6","s7","s8","peg$parseImportDeclarations","peg$parse__","peg$parseTopLevelInitializer","peg$parseInitializer","peg$parseRule","peg$parseImportsAsText","peg$parseGrammarBody","charAt","peg$parseImportDeclaration","s9","substr","peg$parseImportClause","peg$parseFromClause","peg$parseModuleSpecifier","peg$parseNameSpaceImport","peg$parseNamedImports","peg$parseImportedDefaultBinding","peg$parseImportedBinding","peg$parseImportsList","peg$parseImportSpecifier","peg$parseModuleExportName","peg$parseStringLiteral","peg$parseBindingIdentifier","peg$parseIdentifierName","peg$parseCodeBlock","peg$parseEOS","peg$parseChoiceExpression","peg$parseActionExpression","peg$parseSequenceExpression","peg$parseLabeledExpression","peg$parsePluck","peg$parseLabelColon","peg$parsePrefixedExpression","peg$parsePrefixedOperator","peg$parseSuffixedExpression","test","peg$parsePrimaryExpression","peg$parseSuffixedOperator","peg$parseRepeatedExpression","s10","s11","peg$parseBoundaries","peg$parseBoundary","peg$parseInteger","peg$parseLiteralMatcher","peg$parseCharacterClassMatcher","peg$parseAnyMatcher","peg$parseRuleReferenceExpression","peg$parseSemanticPredicateExpression","peg$parseSemanticPredicateOperator","peg$parseSourceCharacter","peg$parseSourceCharacterLow","peg$parseSourceCharacterHigh","peg$parseWhiteSpace","peg$parseLineTerminator","peg$parseLineTerminatorSequence","peg$parseComment","peg$parseMultiLineComment","peg$parseSingleLineComment","peg$parseMultiLineCommentNoLineTerminator","peg$parseIdentifierStart","peg$parseIdentifierPart","peg$parseUnicodeEscapeSequence","peg$parseDoubleStringCharacter","peg$parseSingleStringCharacter","peg$parseEscapeSequence","peg$parseLineContinuation","peg$parseAtomEscape","peg$parseClassCharacterRange","peg$parseClassCharacter","peg$parseClassFlags","peg$parseCharacterClassEscape","toLowerCase","peg$parseUnicodePropertyValueExpression","peg$parseUnicodePropertyName","peg$parseUnicodePropertyValue","peg$parseLoneUnicodePropertyNameOrValue","peg$parseUnicodePropertyNameCharacter","peg$parseUnicodePropertyValueCharacter","peg$parseDecimalDigit","peg$parseAsciiLetter","peg$parseClassFlag","peg$parseCharacterEscapeSequence","peg$parseHexEscapeSequence","peg$parseSingleEscapeCharacter","peg$parseNonEscapeCharacter","peg$parseEscapeCharacter","peg$parseHexDigit","peg$parseBareCodeBlock","peg$parseCode","peg$parse_","peg$parseEOF","Set","peg$success","peg$throw","peg$library","StartRules","parse","exports","module","asts","require","op","Stack","version","stringEscape","regexpClassEscape","SourceNode","GrammarLocation","parse","toSourceNode","code","location","name","start","offsetStart","line","column","lines","split","length","String","source","map","l","i","wrapInSourceNode","prefix","chunk","suffix","end","offsetEnd","generateJS","ast","options","literals","locations","classes","expectations","functions","importedNames","Error","allowedStartRules","dependencies","reIndent","str","indent","leadingSpace","match","body","replace","RegExp","indent2","sawEol","inSourceNode","helper","Array","isArray","s","children","endsWith","r","e","f","gi","generateTables","buildLiteral","literal","buildRegexp","cls","inverted","value","part","join","ignoreCase","unicode","buildExpectation","type","parts","JSON","stringify","buildFunc","a","params","grammarSource","c","concat","generateRuleHeader","ruleNameCode","ruleIndexCode","push","trace","cache","rules","generateRuleFooter","resultCode","generateRuleFunction","rule","bytecode","stack","compile","bc","ip","undefined","compileCondition","cond","argCount","thenFn","baseLength","thenLength","elseLength","thenCode","elseCode","checkedIf","slice","getChunkCode","inputChunkLength","getIncrCode","varName","compileInputChunkCondition","condFn","inputChunk","ACCEPT_N","pop","sp","unshift","compileLoop","bodyLength","bodyCode","checkedLoop","compileCall","paramsLength","p","index","PUSH_EMPTY_STRING","PUSH_CURR_POS","PUSH_UNDEFINED","PUSH_NULL","PUSH_FAILED","PUSH_EMPTY_ARRAY","POP","POP_CURR_POS","POP_N","NIP","APPEND","top","WRAP","TEXT","PLUCK","n","IF","IF_ERROR","IF_NOT_ERROR","IF_LT","IF_GE","IF_LT_DYNAMIC","IF_GE_DYNAMIC","WHILE_NOT_ERROR","MATCH_ANY","MATCH_STRING","litNum","optimized","charCodeAt","MATCH_STRING_IC","MATCH_CHAR_CLASS","regNum","MATCH_UNICODE_CLASS","ACCEPT_STRING","FAIL","LOAD_SAVED_POS","UPDATE_SAVED_POS","CALL","RULE","LIBRARY_RULE","nm","cnm","SILENT_FAILS_ON","SILENT_FAILS_OFF","SOURCE_MAP_PUSH","sourceMapPush","SOURCE_MAP_POP","sourceMapPop","SOURCE_MAP_LABEL_PUSH","labels","label","SOURCE_MAP_LABEL_POP","nameLocation","defines","indexOfRule","result","ast2SourceNode","node","codeLocation","generateToplevel","topLevel","topLevelInitializer","format","imps","codes","tli","imports","startRule","reversed","reverse","startRuleFunctions","startRuleFunction","forEach","initializer","init","generateWrapper","toplevelCode","generateGeneratedByComment","generateParserObject","res","generators","bare","Object","keys","commonjs","dependencyVars","variable","impLen","from","es","amd","dependencyIds","v","deps","id","globals","exportVar","umd","requires","exports","module","asts","require","visitor","removeProxyRules","ast","options","session","isProxyRule","node","type","expression","replaceRuleRefs","from","to","replace","build","rule_ref","name","info","location","message","findRule","nameLocation","rules","forEach","rule","exports","module","stringEscape","require","visitor","codePointLen1","cloneOver","target","source","t","s","Object","keys","forEach","key","cleanParts","parts","sort","a","b","aStart","aEnd","Array","isArray","bStart","bEnd","prevStart","prevEnd","i","length","part","curStart","curEnd","splice","charCodeAt","LAST_LOW","String","fromCodePoint","FIRST_SURROGATE","LAST_SURROGATE","FIRST_HIGH","splitUnicodeRanges","ast","session","split","build","class","node","unicode","extras","p","e","map","c","codePointAt","info","location","push","mergeCharacterClasses","_options","rules","create","rule","name","expression","processedRules","Set","asClass","merge","clone","type","inverted","ul","value","ignoreCase","ref","has","add","cls","choice","prev","changed","alternatives","alt","start","end","filter","arr","text","exports","module","visitor","require","removeUnusedRules","ast","options","session","rules","Object","create","forEach","rule","name","queue","allowedStartRules","found","Set","findRefs","build","rule_ref","node","push","length","r","shift","has","add","filter","info","location","exports","module","reportDuplicateImports","ast","_options","session","all","imp","imports","what","type","Object","prototype","hasOwnProperty","call","binding","error","location","message","exports","module","visitor","require","reportDuplicateLabels","ast","options","session","cloneEnv","env","clone","Object","keys","forEach","name","checkExpressionWithClonedEnv","node","check","expression","build","rule","choice","alternatives","alternative","action","labeled","label","prototype","hasOwnProperty","call","error","labelLocation","message","location","text","simple_and","simple_not","optional","zero_or_more","one_or_more","repeated","delimiter","group","exports","module","visitor","require","reportDuplicateRules","ast","options","session","rules","check","build","rule","node","Object","prototype","hasOwnProperty","call","name","error","nameLocation","message","location","exports","module","asts","require","visitor","reportInfiniteRecursion","ast","options","session","visitedRules","backtraceRefs","seen","Set","check","build","rule","node","errors","has","name","add","push","expression","pop","sequence","elements","every","element","alwaysConsumesOnSuccess","repeated","delimiter","rule_ref","findRule","indexOf","error","join","nameLocation","map","ref","i","a","message","length","location","exports","module","asts","require","visitor","reportInfiniteRepetition","ast","options","session","check","build","zero_or_more","node","alwaysConsumesOnSuccess","expression","error","location","one_or_more","repeated","delimiter","max","value","min","warning","type","exports","module","asts","require","visitor","reportUndefinedRules","ast","options","session","check","build","rule_ref","node","findRule","name","error","location","exports","module","visitor","require","reportIncorrectPlucking","ast","options","session","check","build","action","node","expression","labeled","pick","error","labelLocation","message","location","codeLocation","exports","module","visitor","require","ALWAYS_MATCH","NEVER_MATCH","reportUnreachable","ast","options","session","visit","build","choice","node","alternatives","forEach","a","i","length","alt","match","warning","location","simple_and","expression","simple_not","exports","module","GrammarError","require","Defaults","options","error","warning","info","_a","Session","_callbacks","_firstError","errors","problems","stage","args","push","checkErrors","addImportedRules","require","fixLibraryNumbers","generateBytecode","generateJS","inferenceMatchResult","removeProxyRules","mergeCharacterClasses","removeUnusedRules","reportDuplicateImports","reportDuplicateLabels","reportDuplicateRules","reportInfiniteRecursion","reportInfiniteRepetition","reportUndefinedRules","reportIncorrectPlucking","reportUnreachable","Session","visitor","base64","processOptions","options","defaults","processedOptions","Object","keys","forEach","name","prototype","hasOwnProperty","call","isSourceMapCapable","target","length","offset","compiler","passes","prepare","check","transform","semantic","generate","compile","ast","undefined","defaultStartRules","rules","allowedStartRules","cache","dependencies","exportVar","format","output","trace","Array","isArray","Error","allRules","map","r","some","rule","indexOf","grammarSource","session","stage","info","pass","checkErrors","eval","code","toString","TextEncoder","sourceMap","toStringWithSourceMap","encoder","b64","encode","JSON","stringify","toJSON","module","exports","exports","module","GrammarError","require","GrammarLocation","asts","compiler","parser","version","VERSION","RESERVED_WORDS","peg","generate","grammar","options","undefined","copyPasses","passes","converted","Object","keys","forEach","stage","slice","plugins","config","reservedWords","p","use","Array","isArray","source","grammarSource","text","combined","combine","map","parse","compile","highlightSnippet","input","location","useColor","lines","split","lineNum","start","line","colNum","column","length","targetLine","prefix","pointerLine","repeat","lineStr","red","pointerStr","yellow","resultLines","push","join","colors","isParseError","err","error","success","isPeggyError","message","toParseError","peggyError","location","isValidLocation","undefined","expected","Array","isArray","found","input","snippet","Error","loc","locationObject","start","end","startObject","line","column","offset","endObject","formatLocation","formatError","errorMessage","parts","push","length","join","highlightSnippet","formatErrorWithColors","useColors","red","blue","yellow","dim","formatAnyError","err","useColors","parseError","toParseError","formatErrorWithColors","getErrorSuggestions","error","suggestions","errorMsg","toLowerCase","includes","push","expected","length","expectedItems","slice","join","formatErrorWithSuggestions","useColors","baseFormatted","formatErrorWithColors","suggestionHeader","cyan","formattedSuggestions","map","suggestion","index","bullet","dim","formatCompilationError","err","grammarSource","parseError","toParseError","input","generate","PEG","isParseError","error","compileGrammar","grammar","options","analyzer","defaultOptions","allowedStartRules","cache","format","optimize","output","trace","parser","parse","bind","source","analyze","formattedError","formatCompilationError","formatAnyError","Error","compileGrammarFromFile","filePath","fs","readFile","grammarSource","message","String","validateGrammar","valid","formatError","analyzeGrammarAdvanced","lines","split","rules","dependencies","Map","warnings","ruleDefinitionRegex","currentRuleLines","currentRuleInfo","forEach","line","i","ruleMatch","match","length","push","finalizeRule","name","column","indexOf","isStartRule","rule","set","references","reachableRules","Set","startRule","find","r","findReachableRules","unreachableRules","filter","has","map","leftRecursive","isLeftRecursive","join","info","isStart","expression","extractReferences","checkImmediateLeftRecursion","ruleName","grammarOnly","replace","matches","m","Array","from","body","substring","alternatives","some","alt","trimmedAlt","trim","startsWith","reachable","add","deps","get","dep","SymbolTable","scopes","Map","currentScope","scopeStack","set","enterScope","scopeName","push","has","exitScope","pop","length","define","symbol","scope","get","name","lookup","i","undefined","getAllSymbols","symbols","values","getSymbolsInScope","Array","from","getCurrentScope","DiagnosticCollector","diagnostics","error","message","location","code","severity","source","warning","info","hint","getDiagnostics","addDiagnostics","newDiagnostics","clear","hasDiagnostics","hasErrors","some","d","ASTWalker","walk","node","visitor","context","result","visit","children","visitChildren","childResults","map","child","newContext","childrenVisitResult","walkPostOrder","ASTTransformer","transforms","addTransform","transform","ast","applyTransform","shouldTransform","transformed","SemanticAnalyzer","symbolTable","getSymbolTable","parseWithSemanticAnalysis","grammar","input","analyzerInstance","options","enhancedOptions","enableSymbolTable","enableDiagnostics","diagnosticsCollector","DiagnosticCollector","symbolTable","ast","parse","analyze","getSymbolTable","addDiagnostics","getDiagnostics","hasErrors","success","error","diagnostics","SymbolTable","result","symbols","parseError","createParseError","location","start","line","column","offset","end","expected","found","stack","snippet","LanguageServer","capabilities","diagnosticCollector","completion","_input","_position","getAllSymbols","completions","symbol","push","label","name","kind","getCompletionKind","type","detail","documentation","metadata","description","keywords","keyword","insertText","hover","position","wordAtPosition","getWordAtPosition","lookup","getDiagnosticsForInput","clear","TempSemanticAnalyzer","SemanticAnalyzer","_a","TempASTVisitor","_symbolTableRef","_diagnosticsRef","visit","node","_context","value","symbolName","warning","children","varName","define","scope","getCurrentScope","visitChildren","_node","visitor","ASTWalker","walk","tempAnalyzer","parseResult","length","errorLocation","errorMessage","Error","message","toLowerCase","lines","split","wordRegex","match","exec","index","REPL","interpreter","history","variables","Map","evaluate","undefined","output","ParserUtils","formatError","interpret","formatOutput","formatAST","getHistory","clearHistory","JSON","stringify","String","parseInput","createParser","err","parseWithAdvancedRecovery","_options","errors","recoveryStrategy","errorLine","recoveredInput","slice","join","_recoveryError","trim","commonTokens","token","includes","errorPos","errorObj","map","exp","text","toString","generateErrorSnippet","lineNum","colNum","contextLines","repeat","parseMultiple","inputs","parseStream","stream","parseWithTimeout","timeoutMs","Promise","resolve","reject","timeoutId","setTimeout","clearTimeout","validateSyntax","valid","d","StreamingParser","buffer","addChunk","chunk","results","pop","flush","formatted","isParseError","extractValue","PerformanceParser","metrics","performance","now","duration","inputSize","key","has","set","get","getMetrics","times","avg","reduce","a","b","min","Math","max","count","parseInput","parseWithSemanticAnalysis","parseMultiple","parseStream","parseWithTimeout","validateSyntax","parseWithAdvancedRecovery","createParser","ASTWalker","ASTTransformer","SymbolTable","DiagnosticCollector","LanguageServer","REPL","StreamingParser","ParserUtils","PerformanceParser","VALID_FORMATS","printHelp","console","log","join","isValidFormat","format","includes","compileAndWrite","grammarPath","outFile","grammarText","fs","readFile","PEG","baseOptions","allowedStartRules","cache","optimize","output","trace","compiledSource","generate","exportVar","Error","writeFile","main","args","argv","slice","result","validateGrammar","valid","error","process","exit","analyzeGrammarAdvanced","outIndex","indexOf","formatIndex","formatArg","watchFile","interval","err","formatCompilationError","parser","compileGrammarFromFile","testIndex","input","Parser","parseInput","ParserUtils","isParseError","JSON","stringify","formatError"]}