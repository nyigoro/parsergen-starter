{"version":3,"sources":["../src/utils/highlight.ts","../src/utils/format.ts","../src/utils/ast.ts","../src/grammar/index.ts","../src/lexer/index.ts","../src/parser/index.ts"],"sourcesContent":["import type { Location } from './types';\r\nimport chalk from 'chalk';\r\n\r\n/**\r\n * Highlight the source input with a caret (^) and optional colorization\r\n */\r\nexport function highlightSnippet(input: string, location: Location, useColor = true): string {\r\n  const lines = input.split('\\n');\r\n  const lineNum = location.start.line;\r\n  const colNum = location.start.column;\r\n\r\n  if (lineNum < 1 || lineNum > lines.length) return '';\r\n\r\n  const targetLine = lines[lineNum - 1];\r\n\r\n  const prefix = `${lineNum}: `;\r\n  const pointerLine = ' '.repeat(prefix.length + colNum - 1) + '^';\r\n\r\n  const lineStr = useColor\r\n    ? prefix + chalk.redBright(targetLine)\r\n    : prefix + targetLine;\r\n\r\n  const pointerStr = useColor\r\n    ? chalk.yellow(pointerLine)\r\n    : pointerLine;\r\n\r\n  const resultLines = [];\r\n\r\n  if (lineNum > 1) resultLines.push(`${lineNum - 1}: ${lines[lineNum - 2]}`);\r\n  resultLines.push(lineStr);\r\n  resultLines.push(pointerStr);\r\n  if (lineNum < lines.length) resultLines.push(`${lineNum + 1}: ${lines[lineNum]}`);\r\n\r\n  return resultLines.join('\\n');\r\n}\r\n\r\n/**\r\n * Enhanced snippet highlighting with range support and more context\r\n */\r\nexport function highlightSnippetAdvanced(\r\n  input: string, \r\n  location: Location, \r\n  options: {\r\n    useColor?: boolean;\r\n    contextLines?: number;\r\n    showLineNumbers?: boolean;\r\n    highlightRange?: boolean;\r\n    maxLineLength?: number;\r\n  } = {}\r\n): string {\r\n  const {\r\n    useColor = true,\r\n    contextLines = 1,\r\n    showLineNumbers = true,\r\n    highlightRange = true,\r\n    maxLineLength = 120\r\n  } = options;\r\n\r\n  const lines = input.split('\\n');\r\n  const startLine = location.start.line;\r\n  const endLine = location.end.line;\r\n  const startCol = location.start.column;\r\n  const endCol = location.end.column;\r\n\r\n  if (startLine < 1 || startLine > lines.length) return '';\r\n\r\n  const firstLine = Math.max(1, startLine - contextLines);\r\n  const lastLine = Math.min(lines.length, endLine + contextLines);\r\n\r\n  const resultLines: string[] = [];\r\n  const maxLineNumWidth = lastLine.toString().length;\r\n\r\n  for (let i = firstLine; i <= lastLine; i++) {\r\n    const line = lines[i - 1];\r\n    const truncatedLine = line.length > maxLineLength \r\n      ? line.substring(0, maxLineLength) + '...'\r\n      : line;\r\n\r\n    const lineNumStr = showLineNumbers\r\n      ? `${i.toString().padStart(maxLineNumWidth)}: `\r\n      : '';\r\n\r\n    let displayLine = truncatedLine;\r\n\r\n    // Highlight the error range\r\n    if (highlightRange && i >= startLine && i <= endLine) {\r\n      if (useColor) {\r\n        if (i === startLine && i === endLine) {\r\n          // Single line highlight\r\n          const before = displayLine.substring(0, startCol - 1);\r\n          const highlight = displayLine.substring(startCol - 1, endCol - 1);\r\n          const after = displayLine.substring(endCol - 1);\r\n          displayLine = before + chalk.bgRed(highlight) + after;\r\n        } else if (i === startLine) {\r\n          // First line of multi-line highlight\r\n          const before = displayLine.substring(0, startCol - 1);\r\n          const highlight = displayLine.substring(startCol - 1);\r\n          displayLine = before + chalk.bgRed(highlight);\r\n        } else if (i === endLine) {\r\n          // Last line of multi-line highlight\r\n          const highlight = displayLine.substring(0, endCol - 1);\r\n          const after = displayLine.substring(endCol - 1);\r\n          displayLine = chalk.bgRed(highlight) + after;\r\n        } else {\r\n          // Middle lines of multi-line highlight\r\n          displayLine = chalk.bgRed(displayLine);\r\n        }\r\n      }\r\n    }\r\n\r\n    const fullLine = useColor && (i >= startLine && i <= endLine)\r\n      ? lineNumStr + displayLine\r\n      : lineNumStr + displayLine;\r\n\r\n    resultLines.push(fullLine);\r\n\r\n    // Add pointer line for single-line errors\r\n    if (i === startLine && startLine === endLine && highlightRange) {\r\n      const pointerStart = lineNumStr.length + startCol - 1;\r\n      const pointerLength = Math.max(1, endCol - startCol);\r\n      const pointer = ' '.repeat(pointerStart) + '^'.repeat(pointerLength);\r\n      \r\n      resultLines.push(useColor ? chalk.yellow(pointer) : pointer);\r\n    }\r\n  }\r\n\r\n  return resultLines.join('\\n');\r\n}\r\n\r\n/**\r\n * Highlight multiple locations in the same input\r\n */\r\nexport function highlightMultipleLocations(\r\n  input: string,\r\n  locations: Array<{ location: Location; label?: string; color?: string }>,\r\n  options: {\r\n    useColor?: boolean;\r\n    contextLines?: number;\r\n    showLineNumbers?: boolean;\r\n  } = {}\r\n): string {\r\n  const { useColor = true, contextLines = 1, showLineNumbers = true } = options;\r\n  \r\n  const lines = input.split('\\n');\r\n  const colors = ['red', 'blue', 'green', 'yellow', 'magenta', 'cyan'] as const;\r\n  \r\n  // Sort locations by line number\r\n  const sortedLocations = [...locations].sort((a, b) => \r\n    a.location.start.line - b.location.start.line\r\n  );\r\n\r\n  // Find the range of lines to display\r\n  const firstLine = Math.max(1, \r\n    Math.min(...sortedLocations.map(l => l.location.start.line)) - contextLines\r\n  );\r\n  const lastLine = Math.min(lines.length,\r\n    Math.max(...sortedLocations.map(l => l.location.end.line)) + contextLines\r\n  );\r\n\r\n  const resultLines: string[] = [];\r\n  const maxLineNumWidth = lastLine.toString().length;\r\n\r\n  for (let i = firstLine; i <= lastLine; i++) {\r\n    const line = lines[i - 1];\r\n    const lineNumStr = showLineNumbers\r\n      ? `${i.toString().padStart(maxLineNumWidth)}: `\r\n      : '';\r\n\r\n    let displayLine = line;\r\n\r\n    // Apply highlights for this line\r\n    const lineLocations = sortedLocations.filter(l => \r\n      l.location.start.line <= i && l.location.end.line >= i\r\n    );\r\n\r\n    if (useColor && lineLocations.length > 0) {\r\n      // Sort by column for proper highlighting\r\n      lineLocations.sort((a, b) => a.location.start.column - b.location.start.column);\r\n      \r\n      let offset = 0;\r\n      for (const [index, { location, color }] of lineLocations.entries()) {\r\n        const colorName = color || colors[index % colors.length];\r\n        const chalkColor = chalk[colorName as keyof typeof chalk] || chalk.red;\r\n        \r\n        const startCol = i === location.start.line ? location.start.column - 1 : 0;\r\n        const endCol = i === location.end.line ? location.end.column - 1 : line.length;\r\n        \r\n        const before = displayLine.substring(0, startCol + offset);\r\n        const highlight = displayLine.substring(startCol + offset, endCol + offset);\r\n        const after = displayLine.substring(endCol + offset);\r\n        \r\n        displayLine = before + (chalkColor as any).underline(highlight) + after;\r\n        offset += (chalkColor as any).underline('').length; // Account for ANSI codes\r\n      }\r\n    }\r\n\r\n    resultLines.push(lineNumStr + displayLine);\r\n\r\n    // Add pointer lines\r\n    for (const [index, { location, label }] of lineLocations.entries()) {\r\n      if (i === location.start.line && location.start.line === location.end.line) {\r\n        const colorName = colors[index % colors.length];\r\n        const chalkColor = useColor ? (chalk[colorName as keyof typeof chalk] || chalk.red) : null;\r\n        \r\n        const pointerStart = lineNumStr.length + location.start.column - 1;\r\n        const pointerLength = Math.max(1, location.end.column - location.start.column);\r\n        const pointer = ' '.repeat(pointerStart) + '^'.repeat(pointerLength);\r\n        const labelStr = label ? ` ${label}` : '';\r\n        \r\n        const pointerLine = chalkColor \r\n          ? (chalkColor as any)(pointer + labelStr)\r\n          : pointer + labelStr;\r\n        \r\n        resultLines.push(pointerLine);\r\n      }\r\n    }\r\n  }\r\n\r\n  return resultLines.join('\\n');\r\n}\r\n\r\n/**\r\n * Simple function to create a snippet without full location data\r\n */\r\nexport function createSnippet(\r\n  input: string,\r\n  line: number,\r\n  column: number,\r\n  useColor = true\r\n): string {\r\n  const location = {\r\n    start: { line, column, offset: 0 },\r\n    end: { line, column, offset: 0 }\r\n  };\r\n  return highlightSnippet(input, location, useColor);\r\n}\r\n\r\n/**\r\n * Get line and column information for a given offset\r\n */\r\nexport function getLocationFromOffset(input: string, offset: number): {\r\n  line: number;\r\n  column: number;\r\n  offset: number;\r\n} {\r\n  const lines = input.substring(0, offset).split('\\n');\r\n  const line = lines.length;\r\n  const column = lines[lines.length - 1].length + 1;\r\n  \r\n  return { line, column, offset };\r\n}\r\n\r\n/**\r\n * Get offset from line and column\r\n */\r\nexport function getOffsetFromLocation(input: string, line: number, column: number): number {\r\n  const lines = input.split('\\n');\r\n  \r\n  if (line < 1 || line > lines.length) return -1;\r\n  if (column < 1 || column > lines[line - 1].length + 1) return -1;\r\n  \r\n  let offset = 0;\r\n  for (let i = 0; i < line - 1; i++) {\r\n    offset += lines[i].length + 1; // +1 for newline\r\n  }\r\n  offset += column - 1;\r\n  \r\n  return offset;\r\n}","import type { Location } from './types';\r\nimport type { ParseError } from '../parser/index';\r\nimport { highlightSnippet } from './highlight';\r\n\r\nexport function formatLocation(location: Location): string {\r\n  const { start, end } = location;\r\n  return (start.line === end.line && start.column === end.column)\r\n    ? `Line ${start.line}, Col ${start.column}`\r\n    : `Line ${start.line}, Col ${start.column} → Line ${end.line}, Col ${end.column}`;\r\n}\r\n\r\nexport function formatError(error: ParseError): string {\r\n  const parts: string[] = [`❌ Parse Error: ${error.error}`];\r\n\r\n  if (error.location) parts.push(`↪ at ${formatLocation(error.location)}`);\r\n  if (error.expected) parts.push(`Expected: ${error.expected.join(', ')}`);\r\n  if (error.found !== undefined) parts.push(`Found: \"${error.found}\"`);\r\n  if (error.snippet || error.input) {\r\n    const snippet = error.snippet || highlightSnippet(error.input!, error.location!, true);\r\n    parts.push('\\n--- Snippet ---\\n' + snippet);\r\n  }\r\n\r\n  return parts.join('\\n');\r\n}\r\n\r\n// Enhanced error formatting with color support\r\nexport function formatErrorWithColors(error: ParseError, useColors: boolean = true): string {\r\n  const red = useColors ? '\\x1b[31m' : '';\r\n  const yellow = useColors ? '\\x1b[33m' : '';\r\n  const blue = useColors ? '\\x1b[34m' : '';\r\n  const reset = useColors ? '\\x1b[0m' : '';\r\n  \r\n  const parts: string[] = [`${red}❌ Parse Error:${reset} ${error.error}`];\r\n\r\n  if (error.location) parts.push(`${blue}↪ at ${formatLocation(error.location)}${reset}`);\r\n  if (error.expected) parts.push(`${yellow}Expected:${reset} ${error.expected.join(', ')}`);\r\n  if (error.found !== undefined) parts.push(`${yellow}Found:${reset} \"${error.found}\"`);\r\n  if (error.snippet || error.input) {\r\n    const snippet = error.snippet || highlightSnippet(error.input!, error.location!, true);\r\n    parts.push('\\n--- Snippet ---\\n' + snippet);\r\n  }\r\n\r\n  return parts.join('\\n');\r\n}","import type { Location } from './types';\r\n\r\nexport interface ASTNode {\r\n  type: string;\r\n  value?: any;\r\n  children?: ASTNode[];\r\n  location?: Location;\r\n  // Optional metadata for debugging/tooling\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n// Enhanced type for more flexible traversal\r\nexport type ASTVisitor<T = void> = (node: ASTNode, parent?: ASTNode, path?: string[]) => T;\r\n\r\nexport function createASTNode(\r\n  type: string,\r\n  value?: any,\r\n  children: ASTNode[] = [],\r\n  location?: ASTNode['location'],\r\n  metadata?: Record<string, any>\r\n): ASTNode {\r\n  const node: ASTNode = { type, value, children, location };\r\n  if (metadata) node.metadata = metadata;\r\n  return node;\r\n}\r\n\r\n// Enhanced traversal with more control\r\nexport function traverseAST(\r\n  node: ASTNode, \r\n  visit: (node: ASTNode, parent?: ASTNode, path?: string[]) => void,\r\n  parent?: ASTNode,\r\n  path: string[] = []\r\n): void {\r\n  visit(node, parent, path);\r\n  if (node.children) {\r\n    node.children.forEach((child, index) => \r\n      traverseAST(child, visit, node, [...path, `children[${index}]`])\r\n    );\r\n  }\r\n}\r\n\r\n// Pre-order traversal (visits node before children)\r\nexport function traversePreOrder<T>(\r\n  node: ASTNode,\r\n  visit: (node: ASTNode, parent?: ASTNode, path?: string[]) => T,\r\n  parent?: ASTNode,\r\n  path: string[] = []\r\n): T[] {\r\n  const results: T[] = [];\r\n  const result = visit(node, parent, path);\r\n  results.push(result);\r\n  \r\n  if (node.children) {\r\n    node.children.forEach((child, index) => {\r\n      const childResults = traversePreOrder(child, visit, node, [...path, `children[${index}]`]);\r\n      results.push(...childResults);\r\n    });\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n// Post-order traversal (visits children before node)\r\nexport function traversePostOrder<T>(\r\n  node: ASTNode,\r\n  visit: (node: ASTNode, parent?: ASTNode, path?: string[]) => T,\r\n  parent?: ASTNode,\r\n  path: string[] = []\r\n): T[] {\r\n  const results: T[] = [];\r\n  \r\n  if (node.children) {\r\n    node.children.forEach((child, index) => {\r\n      const childResults = traversePostOrder(child, visit, node, [...path, `children[${index}]`]);\r\n      results.push(...childResults);\r\n    });\r\n  }\r\n  \r\n  const result = visit(node, parent, path);\r\n  results.push(result);\r\n  \r\n  return results;\r\n}\r\n\r\n// Find nodes by type\r\nexport function findNodesByType(node: ASTNode, type: string): ASTNode[] {\r\n  const results: ASTNode[] = [];\r\n  traverseAST(node, (current) => {\r\n    if (current.type === type) {\r\n      results.push(current);\r\n    }\r\n  });\r\n  return results;\r\n}\r\n\r\n// Find first node by predicate\r\nexport function findNode(node: ASTNode, predicate: (node: ASTNode) => boolean): ASTNode | null {\r\n  if (predicate(node)) return node;\r\n  \r\n  if (node.children) {\r\n    for (const child of node.children) {\r\n      const found = findNode(child, predicate);\r\n      if (found) return found;\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n// Transform AST (immutable)\r\nexport function transformAST(\r\n  node: ASTNode,\r\n  transformer: (node: ASTNode, parent?: ASTNode) => ASTNode,\r\n  parent?: ASTNode\r\n): ASTNode {\r\n  const transformedChildren = node.children?.map(child => \r\n    transformAST(child, transformer, node)\r\n  );\r\n  \r\n  const transformedNode: ASTNode = {\r\n    ...node,\r\n    children: transformedChildren\r\n  };\r\n  \r\n  return transformer(transformedNode, parent);\r\n}\r\n\r\n// Serialize AST to JSON with optional filtering\r\nexport function serializeAST(\r\n  node: ASTNode,\r\n  filter?: (node: ASTNode) => boolean,\r\n  depth: number = 0,\r\n  maxDepth: number = Infinity\r\n): any {\r\n  if (depth > maxDepth) return null;\r\n  if (filter && !filter(node)) return null;\r\n  \r\n  const serialized: any = {\r\n    type: node.type,\r\n    ...(node.value !== undefined && { value: node.value }),\r\n    ...(node.location && { location: node.location }),\r\n    ...(node.metadata && { metadata: node.metadata })\r\n  };\r\n  \r\n  if (node.children && node.children.length > 0) {\r\n    serialized.children = node.children\r\n      .map(child => serializeAST(child, filter, depth + 1, maxDepth))\r\n      .filter(child => child !== null);\r\n  }\r\n  \r\n  return serialized;\r\n}\r\n\r\n// Pretty print AST for debugging\r\nexport function printAST(node: ASTNode, indent: string = '', isLast: boolean = true): string {\r\n  const lines: string[] = [];\r\n  const prefix = indent + (isLast ? '└── ' : '├── ');\r\n  \r\n  let nodeStr = `${prefix}${node.type}`;\r\n  if (node.value !== undefined) {\r\n    nodeStr += `: ${JSON.stringify(node.value)}`;\r\n  }\r\n  if (node.location) {\r\n    nodeStr += ` (${node.location.start.line}:${node.location.start.column})`;\r\n  }\r\n  \r\n  lines.push(nodeStr);\r\n  \r\n  if (node.children) {\r\n    const newIndent = indent + (isLast ? '    ' : '│   ');\r\n    node.children.forEach((child, index) => {\r\n      const childIsLast = index === node.children!.length - 1;\r\n      lines.push(printAST(child, newIndent, childIsLast));\r\n    });\r\n  }\r\n  \r\n  return lines.join('\\n');\r\n}\r\n\r\n// Calculate AST statistics\r\nexport function getASTStats(node: ASTNode): {\r\n  totalNodes: number;\r\n  maxDepth: number;\r\n  nodeTypes: Record<string, number>;\r\n  leafNodes: number;\r\n} {\r\n  const stats = {\r\n    totalNodes: 0,\r\n    maxDepth: 0,\r\n    nodeTypes: {} as Record<string, number>,\r\n    leafNodes: 0\r\n  };\r\n  \r\n  function collect(current: ASTNode, depth: number = 0) {\r\n    stats.totalNodes++;\r\n    stats.maxDepth = Math.max(stats.maxDepth, depth);\r\n    stats.nodeTypes[current.type] = (stats.nodeTypes[current.type] || 0) + 1;\r\n    \r\n    if (!current.children || current.children.length === 0) {\r\n      stats.leafNodes++;\r\n    } else {\r\n      current.children.forEach(child => collect(child, depth + 1));\r\n    }\r\n  }\r\n  \r\n  collect(node);\r\n  return stats;\r\n}","import type { Parser, ParserBuildOptions } from 'peggy';\r\nimport { formatError } from '../utils/index';\r\nimport PEG from 'peggy';\r\n\r\nconst generate = PEG.generate;\r\nexport interface CompiledGrammar {\r\n  parse: Parser['parse'];\r\n  source: string;\r\n  options: CompileOptions;\r\n}\r\n\r\nexport interface CompileOptions {\r\n  allowedStartRules?: string[];\r\n  cache?: boolean;\r\n  dependencies?: Record<string, any>;\r\n  exportVar?: string;\r\n  format?: 'bare' | 'commonjs' | 'es' | 'globals' | 'umd';\r\n  grammarSource?: string;\r\n  header?: string | string[];\r\n  optimize?: 'speed' | 'size';\r\n  output?: 'parser' | 'source';\r\n  plugins?: any[];\r\n  trace?: boolean;\r\n}\r\n\r\n/**\r\n * Compile a PEG grammar string into a parser\r\n */\r\nexport function compileGrammar(\r\n  grammar: string, \r\n  options: CompileOptions = {}\r\n): CompiledGrammar {\r\n  try {\r\n    const defaultOptions: CompileOptions = {\r\n      allowedStartRules: ['*'],\r\n      cache: false,\r\n      format: 'bare',\r\n      optimize: 'speed',\r\n      output: 'parser',\r\n      trace: false,\r\n      ...options\r\n    };\r\n\r\n    const parser = generate(grammar, defaultOptions as ParserBuildOptions);\r\n    return {\r\n      parse: parser.parse.bind(parser),\r\n      source: grammar,\r\n      options: defaultOptions\r\n    };\r\n  } catch (error: any) {\r\n    const formattedError = formatError(error);\r\n    throw new Error(`Grammar compilation failed: ${formattedError}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Compile grammar from file\r\n */\r\nexport async function compileGrammarFromFile(\r\n  filePath: string, \r\n  options: CompileOptions = {}\r\n): Promise<CompiledGrammar> {\r\n  try {\r\n    const fs = await import('fs/promises');\r\n    const grammar = await fs.readFile(filePath, 'utf-8');\r\n    return compileGrammar(grammar, {\r\n      ...options,\r\n      grammarSource: filePath\r\n    });\r\n  } catch (error: any) {\r\n    throw new Error(`Failed to compile grammar from file ${filePath}: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Validate grammar syntax without generating parser\r\n */\r\nexport function validateGrammar(grammar: string): { valid: boolean; error?: string } {\r\n  try {\r\n    generate(grammar, { output: 'source' });\r\n    return { valid: true };\r\n  } catch (error: any) {\r\n    return { \r\n      valid: false, \r\n      error: formatError(error) \r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Extract grammar metadata (rules, start rule, etc.)\r\n */\r\nexport function analyzeGrammar(grammar: string): {\r\n  rules: string[];\r\n  startRule?: string;\r\n  imports: string[];\r\n  exports: string[];\r\n} {\r\n  const rules: string[] = [];\r\n  const imports: string[] = [];\r\n  const exports: string[] = [];\r\n  \r\n  // Simple regex-based extraction (could be improved with proper parsing)\r\n  const rulePattern = /^(\\w+)\\s*=/gm;\r\n  const importPattern = /import\\s+(\\w+)/g;\r\n  const exportPattern = /export\\s+(\\w+)/g;\r\n  \r\n  let match;\r\n  \r\n  while ((match = rulePattern.exec(grammar)) !== null) {\r\n    rules.push(match[1]);\r\n  }\r\n  \r\n  while ((match = importPattern.exec(grammar)) !== null) {\r\n    imports.push(match[1]);\r\n  }\r\n  \r\n  while ((match = exportPattern.exec(grammar)) !== null) {\r\n    exports.push(match[1]);\r\n  }\r\n  \r\n  return {\r\n    rules,\r\n    startRule: rules[0], // First rule is typically the start rule\r\n    imports,\r\n    exports\r\n  };\r\n}\r\n\r\n/**\r\n * Create a grammar builder for fluent API\r\n */\r\nexport class GrammarBuilder {\r\n  private rules: string[] = [];\r\n  private headers: string[] = [];\r\n  private options: CompileOptions = {};\r\n  \r\n  rule(name: string, expression: string): this {\r\n    this.rules.push(`${name} = ${expression}`);\r\n    return this;\r\n  }\r\n  \r\n  header(code: string): this {\r\n    this.headers.push(code);\r\n    return this;\r\n  }\r\n  \r\n  option(key: keyof CompileOptions, value: any): this {\r\n    this.options[key] = value;\r\n    return this;\r\n  }\r\n  \r\n  build(): CompiledGrammar {\r\n    const grammar = [\r\n      ...this.headers.map(h => `{ ${h} }`),\r\n      ...this.rules\r\n    ].join('\\n\\n');\r\n    \r\n    return compileGrammar(grammar, this.options);\r\n  }\r\n  \r\n  toString(): string {\r\n    return [\r\n      ...this.headers.map(h => `{ ${h} }`),\r\n      ...this.rules\r\n    ].join('\\n\\n');\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new grammar builder\r\n */\r\nexport function createGrammarBuilder(): GrammarBuilder {\r\n  return new GrammarBuilder();\r\n}","import moo from 'moo';\r\n\r\nexport interface Token {\r\n  type: string;\r\n  value: string;\r\n  text: string;\r\n  offset: number;\r\n  lineBreaks: number;\r\n  line: number;\r\n  col: number;\r\n}\r\n\r\nexport interface LexerConfig {\r\n  [key: string]: moo.Rules | moo.Rule | RegExp | string;\r\n}\r\n\r\nexport interface LexerState {\r\n  [key: string]: LexerConfig;\r\n}\r\n\r\n/**\r\n * Create a lexer using Moo\r\n */\r\nexport function createLexer(config: LexerConfig): moo.Lexer {\r\n  try {\r\n    return moo.compile(config);\r\n  } catch (error: any) {\r\n    throw new Error(`Lexer compilation failed: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a stateful lexer with multiple states\r\n */\r\nexport function createStatefulLexer(states: LexerState): moo.Lexer {\r\n  try {\r\n    return moo.states(states);\r\n  } catch (error: any) {\r\n    throw new Error(`Stateful lexer compilation failed: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Tokenize input string\r\n */\r\nexport function tokenize(lexer: moo.Lexer, input: string): Token[] {\r\n  const tokens: Token[] = [];\r\n  lexer.reset(input);\r\n  \r\n  let token;\r\n  while ((token = lexer.next()) !== undefined) {\r\n    tokens.push({\r\n      type: token.type || 'unknown',\r\n      value: token.value,\r\n      text: token.text,\r\n      offset: token.offset,\r\n      lineBreaks: token.lineBreaks,\r\n      line: token.line,\r\n      col: token.col\r\n    });\r\n  }\r\n  \r\n  return tokens;\r\n}\r\n\r\n/**\r\n * Create a lexer for common programming language tokens\r\n */\r\nexport function createProgrammingLexer(): moo.Lexer {\r\n  return createLexer({\r\n    // Whitespace and comments\r\n    whitespace: /[ \\t]+/,\r\n    newline: { match: /\\n/, lineBreaks: true },\r\n    comment: /\\/\\/.*?$/,\r\n    multiComment: { match: /\\/\\*[\\s\\S]*?\\*\\//, lineBreaks: true },\r\n    \r\n    // Literals\r\n    number: /\\d+(?:\\.\\d+)?/,\r\n    string: /\"(?:[^\"\\\\]|\\\\.)*\"/,\r\n    char: /'(?:[^'\\\\]|\\\\.)*'/,\r\n    \r\n    // Identifiers and keywords\r\n    identifier: {\r\n      match: /[a-zA-Z_][a-zA-Z0-9_]*/,\r\n      type: moo.keywords({\r\n        keyword: ['if', 'else', 'while', 'for', 'function', 'return', 'var', 'let', 'const']\r\n      })\r\n    },\r\n    \r\n    // Operators\r\n    assign: '=',\r\n    equals: '==',\r\n    notEquals: '!=',\r\n    lessEquals: '<=',\r\n    greaterEquals: '>=',\r\n    less: '<',\r\n    greater: '>',\r\n    plus: '+',\r\n    minus: '-',\r\n    multiply: '*',\r\n    divide: '/',\r\n    modulo: '%',\r\n    and: '&&',\r\n    or: '||',\r\n    not: '!',\r\n    \r\n    // Punctuation\r\n    semicolon: ';',\r\n    comma: ',',\r\n    dot: '.',\r\n    leftParen: '(',\r\n    rightParen: ')',\r\n    leftBrace: '{',\r\n    rightBrace: '}',\r\n    leftBracket: '[',\r\n    rightBracket: ']',\r\n  });\r\n}\r\n\r\n/**\r\n * Create a lexer for mathematical expressions\r\n */\r\nexport function createMathLexer(): moo.Lexer {\r\n  return createLexer({\r\n    whitespace: /[ \\t]+/,\r\n    newline: { match: /\\n/, lineBreaks: true },\r\n    number: /\\d+(?:\\.\\d+)?/,\r\n    identifier: /[a-zA-Z_][a-zA-Z0-9_]*/,\r\n    \r\n    // Math operators\r\n    plus: '+',\r\n    minus: '-',\r\n    multiply: '*',\r\n    divide: '/',\r\n    power: '^',\r\n    modulo: '%',\r\n    \r\n    // Parentheses\r\n    leftParen: '(',\r\n    rightParen: ')',\r\n    \r\n    // Functions\r\n    function: {\r\n      match: /(?:sin|cos|tan|log|exp|sqrt|abs|floor|ceil|round)/,\r\n      type: 'function'\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Create a lexer for JSON\r\n */\r\nexport function createJSONLexer(): moo.Lexer {\r\n  return createLexer({\r\n    whitespace: /[ \\t\\n\\r]+/,\r\n    string: /\"(?:[^\"\\\\]|\\\\.)*\"/,\r\n    number: /-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/,\r\n    true: 'true',\r\n    false: 'false',\r\n    null: 'null',\r\n    leftBrace: '{',\r\n    rightBrace: '}',\r\n    leftBracket: '[',\r\n    rightBracket: ']',\r\n    comma: ',',\r\n    colon: ':',\r\n  });\r\n}\r\n\r\n/**\r\n * Lexer utilities\r\n */\r\nexport class LexerUtils {\r\n  /**\r\n   * Filter tokens by type\r\n   */\r\n  static filterTokens(tokens: Token[], types: string[]): Token[] {\r\n    return tokens.filter(token => types.includes(token.type));\r\n  }\r\n  \r\n  /**\r\n   * Remove whitespace tokens\r\n   */\r\n  static removeWhitespace(tokens: Token[]): Token[] {\r\n    return tokens.filter(token => \r\n      !['whitespace', 'newline', 'comment', 'multiComment'].includes(token.type)\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Get tokens by line\r\n   */\r\n  static getTokensByLine(tokens: Token[], line: number): Token[] {\r\n    return tokens.filter(token => token.line === line);\r\n  }\r\n  \r\n  /**\r\n   * Get token at position\r\n   */\r\n  static getTokenAtPosition(tokens: Token[], line: number, col: number): Token | null {\r\n    for (const token of tokens) {\r\n      if (token.line === line && col >= token.col && col < token.col + token.text.length) {\r\n        return token;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n   * Convert tokens back to string\r\n   */\r\n  static tokensToString(tokens: Token[]): string {\r\n    return tokens.map(token => token.text).join('');\r\n  }\r\n}\r\n\r\n/**\r\n * Lexer error class\r\n */\r\nexport class LexerError extends Error {\r\n  public line: number;\r\n  public col: number;\r\n  public offset: number;\r\n  \r\n  constructor(message: string, line: number, col: number, offset: number) {\r\n    super(message);\r\n    this.name = 'LexerError';\r\n    this.line = line;\r\n    this.col = col;\r\n    this.offset = offset;\r\n  }\r\n}\r\n\r\n/**\r\n * Safe tokenization with error handling\r\n */\r\nexport function safeTokenize(lexer: moo.Lexer, input: string): { tokens: Token[]; error?: LexerError } {\r\n  try {\r\n    const tokens = tokenize(lexer, input);\r\n    return { tokens };\r\n  } catch (error: any) {\r\n    const lexerError = new LexerError(\r\n      error.message,\r\n      error.line || 1,\r\n      error.col || 1,\r\n      error.offset || 0\r\n    );\r\n    return { tokens: [], error: lexerError };\r\n  }\r\n}","import { CompiledGrammar } from '../grammar/index.js';\r\nimport { formatError, formatLocation, type Location } from '../utils/index';\r\n\r\nexport interface ParseResult<T = any> {\r\n  result: T;\r\n  success: true;\r\n}\r\n\r\nexport interface ParseError {\r\n  success: false;\r\n  error: string;\r\n  location?: Location;\r\n  expected?: string[];\r\n  found?: string;\r\n  stack?: string;\r\n  input?: string;\r\n  snippet?: string;\r\n}\r\n\r\nexport interface ParseOptions {\r\n  grammarSource?: string;\r\n  startRule?: string;\r\n  tracer?: any;\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Parse input using a compiled grammar\r\n */\r\nexport function parseInput<T = any>(\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  options: ParseOptions = {}\r\n): ParseResult<T> | ParseError {\r\n  try {\r\n    const result = grammar.parse(input, options);\r\n    return {\r\n      result,\r\n      success: true\r\n    };\r\n  } catch (error: any) {\r\n    return createParseError(error, input, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a parser function from a compiled grammar\r\n */\r\nexport function createParser<T = any>(\r\n  grammar: CompiledGrammar,\r\n  defaultOptions: ParseOptions = {}\r\n) {\r\n  return (input: string, options: ParseOptions = {}) => {\r\n    return parseInput<T>(grammar, input, { ...defaultOptions, ...options });\r\n  };\r\n}\r\n\r\n/**\r\n * Parse with automatic error recovery\r\n */\r\nexport function parseWithRecovery<T = any>(\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  options: ParseOptions = {}\r\n): { result?: T; errors: ParseError[] } {\r\n  const errors: ParseError[] = [];\r\n\r\n  try {\r\n    const result = grammar.parse(input, options);\r\n    return { result, errors };\r\n  } catch (error: any) {\r\n    const parseError = createParseError(error, input, options);\r\n    errors.push(parseError);\r\n\r\n    // Try to recover by removing problematic lines before error\r\n    const lines = input.split('\\n');\r\n    if (parseError.location && parseError.location.start.line > 1) {\r\n      const recoveredInput = lines.slice(0, parseError.location.start.line - 1).join('\\n');\r\n      if (recoveredInput.trim()) {\r\n        try {\r\n          const result = grammar.parse(recoveredInput, options);\r\n          return { result, errors };\r\n        } catch (recoveryError: any) {\r\n          errors.push(createParseError(recoveryError, recoveredInput, options));\r\n        }\r\n      }\r\n    }\r\n\r\n    return { errors };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a detailed parse error\r\n */\r\nfunction createParseError(\r\n  error: any,\r\n  input: string,\r\n  options: ParseOptions\r\n): ParseError {\r\n  const parseError: ParseError = {\r\n    success: false,\r\n    error: error.message || 'Parse error',\r\n    input\r\n  };\r\n\r\n  if (error.location) {\r\n    parseError.location = {\r\n      start: {\r\n        line: error.location.start.line,\r\n        column: error.location.start.column,\r\n        offset: error.location.start.offset\r\n      },\r\n      end: {\r\n        line: error.location.end.line,\r\n        column: error.location.end.column,\r\n        offset: error.location.end.offset\r\n      }\r\n    };\r\n  }\r\n\r\n  if (error.expected) {\r\n    parseError.expected = error.expected.map((exp: any) =>\r\n      exp.description || exp.text || exp.toString()\r\n    );\r\n  }\r\n\r\n  if (error.found !== undefined) {\r\n    parseError.found = error.found.toString();\r\n  }\r\n\r\n  parseError.stack = error.stack;\r\n\r\n  if (parseError.location) {\r\n    parseError.snippet = generateErrorSnippet(input, parseError.location);\r\n  }\r\n\r\n  return parseError;\r\n}\r\n\r\n/**\r\n * Generate a code snippet showing the error location\r\n */\r\nfunction generateErrorSnippet(input: string, location: Location): string {\r\n  const lines = input.split('\\n');\r\n  const lineNum = location.start.line;\r\n  const colNum = location.start.column;\r\n\r\n  if (lineNum > lines.length) {\r\n    return '';\r\n  }\r\n\r\n  const line = lines[lineNum - 1];\r\n\r\n  const contextLines: string[] = [];\r\n\r\n  if (lineNum > 1) {\r\n    contextLines.push(`${lineNum - 1}: ${lines[lineNum - 2]}`);\r\n  }\r\n\r\n  contextLines.push(`${lineNum}: ${line}`);\r\n  contextLines.push(`${' '.repeat(lineNum.toString().length)}: ${' '.repeat(colNum - 1)}^`);\r\n\r\n  if (lineNum < lines.length) {\r\n    contextLines.push(`${lineNum + 1}: ${lines[lineNum]}`);\r\n  }\r\n\r\n  return contextLines.join('\\n');\r\n}\r\n\r\n/**\r\n * Batch parse multiple inputs\r\n */\r\nexport function parseMultiple<T = any>(\r\n  grammar: CompiledGrammar,\r\n  inputs: string[],\r\n  options: ParseOptions = {}\r\n): Array<ParseResult<T> | ParseError> {\r\n  return inputs.map(input => parseInput<T>(grammar, input, options));\r\n}\r\n\r\n/**\r\n * Parse stream of inputs\r\n */\r\nexport async function parseStream<T = any>(\r\n  grammar: CompiledGrammar,\r\n  inputs: AsyncIterable<string>,\r\n  options: ParseOptions = {}\r\n): Promise<Array<ParseResult<T> | ParseError>> {\r\n  const results: Array<ParseResult<T> | ParseError> = [];\r\n\r\n  for await (const input of inputs) {\r\n    const result = parseInput<T>(grammar, input, options);\r\n    results.push(result);\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n/**\r\n * Parse with timeout\r\n */\r\nexport function parseWithTimeout<T = any>(\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  timeoutMs: number,\r\n  options: ParseOptions = {}\r\n): Promise<ParseResult<T> | ParseError> {\r\n  return new Promise((resolve, reject) => {\r\n    const timer = setTimeout(() => {\r\n      reject(new Error(`Parse timeout after ${timeoutMs}ms`));\r\n    }, timeoutMs);\r\n\r\n    try {\r\n      const result = parseInput<T>(grammar, input, options);\r\n      clearTimeout(timer);\r\n      resolve(result);\r\n    } catch (error) {\r\n      clearTimeout(timer);\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Validate input syntax without generating AST\r\n */\r\nexport function validateSyntax(\r\n  grammar: CompiledGrammar,\r\n  input: string,\r\n  options: ParseOptions = {}\r\n): { valid: boolean; error?: ParseError } {\r\n  try {\r\n    grammar.parse(input, options);\r\n    return { valid: true };\r\n  } catch (error: any) {\r\n    return {\r\n      valid: false,\r\n      error: createParseError(error, input, options)\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Parser utilities\r\n */\r\nexport class ParserUtils {\r\n  static isSuccess<T>(result: ParseResult<T> | ParseError): result is ParseResult<T> {\r\n    return result.success === true;\r\n  }\r\n\r\n  static isError<T>(result: ParseResult<T> | ParseError): result is ParseError {\r\n    return result.success === false;\r\n  }\r\n\r\n  static unwrap<T>(result: ParseResult<T> | ParseError): T {\r\n    if (ParserUtils.isError(result)) {\r\n      const error = result as ParseError;\r\n      throw new Error(\r\n        `[ParseError]: ${error.error}\\n${error.snippet ?? ''}\\nExpected: ${error.expected?.join(', ') ?? 'unknown'}`\r\n      );\r\n    }\r\n    return result.result;\r\n  }\r\n}\r\n\r\n// Optional default export\r\nexport default {\r\n  parseInput,\r\n  parseMultiple,\r\n  parseStream,\r\n  parseWithTimeout,\r\n  validateSyntax,\r\n  parseWithRecovery,\r\n  createParser,\r\n  ParserUtils\r\n};\r\n"],"mappings":"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","names":[]}